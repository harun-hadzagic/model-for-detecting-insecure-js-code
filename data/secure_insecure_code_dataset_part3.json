[
  {
    "id": 1501,
    "code": "app.get('/user1501', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1501 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1502,
    "code": "app.get('/user1501', async (req, res) => {\n  const u = String(req.query.u1501 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1503,
    "code": "app.post('/zip1503', (req, res) => {\n  const archive = \"archive_1503.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1503;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1504,
    "code": "app.post('/zip1503', (req, res) => {\n  const archive = \"archive_1503.zip\";\n  const dir = String(req.body.dir1503 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1505,
    "code": "app.post('/cfg1505', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1505 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1506,
    "code": "app.post('/cfg1505', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1505 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1507,
    "code": "app.use('/api1507', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1508,
    "code": "const allowedOrigins1507 = new Set([\"https://example1507.com\"]);\napp.use('/api1507', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1507.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1509,
    "code": "app.get('/fetch1509', async (req, res) => {\n  const r = await fetch(req.query.url1509);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1510,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1509', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1509 || \"\"));\n    const allowedHosts = new Set([\"example1509.com\",\"api1509.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1511,
    "code": "app.post('/auth1511', async (req, res) => {\n  const ok = await authUser(req.body.u1511, req.body.p1511);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1512,
    "code": "const attempts1511 = new Map();\napp.post('/auth1511', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1511.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1511.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1511, req.body.p1511);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1513,
    "code": "app.post('/upload1513', (req, res) => {\n  req.files.file1513.mv(\"./uploads/\" + req.files.file1513.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1514,
    "code": "const path_up1513 = require('path');\napp.post('/upload1513', (req, res) => {\n  const f = req.files && req.files.file1513;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1513.basename(f.name);\n  f.mv(path_up1513.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1515,
    "code": "router.get('/acct1515', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1515 WHERE id = \" + req.query.id1515)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1516,
    "code": "router.get('/acct1515', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1515 WHERE id = ?\", [req.query.id1515])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1517,
    "code": "app.get('/hello1517', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1517 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1518,
    "code": "const escapeHtml1517 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1517', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1517(req.query.name1517 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1519,
    "code": "app.get('/read1519', (req, res) => {\n  const p = \"./files/\" + req.query.file1519;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1520,
    "code": "const path1519 = require('path');\napp.get('/read1519', (req, res) => {\n  const base = path1519.join(__dirname, 'files');\n  const safe = path1519.join(base, path1519.basename(String(req.query.file1519 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1521,
    "code": "app.get('/go1521', (req, res) => {\n  res.redirect(req.query.url1521);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1522,
    "code": "app.get('/go1521', (req, res) => {\n  const url = String(req.query.url1521 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1523,
    "code": "const JWT_SECRET_1523 = \"super-secret-1523\";\nfunction sign1523(data){ return \"signed-\" + JWT_SECRET_1523; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1524,
    "code": "const JWT_SECRET_1523 = process.env.JWT_SECRET_1523;\nfunction sign1523(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1525,
    "code": "app.get('/login1525', (req, res) => {\n  res.cookie('sid1525', 'token1525');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1526,
    "code": "app.get('/login1525', (req, res) => {\n  res.cookie('sid1525', 'token1525', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1527,
    "code": "app.post('/vote1527', (req, res) => {\n  const choice = req.body.choice1527;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1528,
    "code": "app.post('/vote1527', (req, res) => {\n  const choice = String(req.body.choice1527 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1529,
    "code": "app.post('/register1529', (req, res) => {\n  console.log(\"New user\", req.body.email1529, req.body.password1529);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1530,
    "code": "app.post('/register1529', (req, res) => {\n  console.log(\"New user\", req.body.email1529);\n  const body = { ...req.body }; delete body.password1529;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1531,
    "code": "app.get('/user1531', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1531 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1532,
    "code": "app.get('/user1531', async (req, res) => {\n  const u = String(req.query.u1531 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1533,
    "code": "app.post('/zip1533', (req, res) => {\n  const archive = \"archive_1533.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1533;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1534,
    "code": "app.post('/zip1533', (req, res) => {\n  const archive = \"archive_1533.zip\";\n  const dir = String(req.body.dir1533 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1535,
    "code": "app.post('/cfg1535', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1535 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1536,
    "code": "app.post('/cfg1535', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1535 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1537,
    "code": "app.use('/api1537', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1538,
    "code": "const allowedOrigins1537 = new Set([\"https://example1537.com\"]);\napp.use('/api1537', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1537.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1539,
    "code": "app.get('/fetch1539', async (req, res) => {\n  const r = await fetch(req.query.url1539);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1540,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1539', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1539 || \"\"));\n    const allowedHosts = new Set([\"example1539.com\",\"api1539.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1541,
    "code": "app.post('/auth1541', async (req, res) => {\n  const ok = await authUser(req.body.u1541, req.body.p1541);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1542,
    "code": "const attempts1541 = new Map();\napp.post('/auth1541', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1541.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1541.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1541, req.body.p1541);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1543,
    "code": "app.post('/upload1543', (req, res) => {\n  req.files.file1543.mv(\"./uploads/\" + req.files.file1543.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1544,
    "code": "const path_up1543 = require('path');\napp.post('/upload1543', (req, res) => {\n  const f = req.files && req.files.file1543;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1543.basename(f.name);\n  f.mv(path_up1543.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1545,
    "code": "router.get('/acct1545', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1545 WHERE id = \" + req.query.id1545)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1546,
    "code": "router.get('/acct1545', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1545 WHERE id = ?\", [req.query.id1545])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1547,
    "code": "app.get('/hello1547', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1547 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1548,
    "code": "const escapeHtml1547 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1547', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1547(req.query.name1547 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1549,
    "code": "app.get('/read1549', (req, res) => {\n  const p = \"./files/\" + req.query.file1549;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1550,
    "code": "const path1549 = require('path');\napp.get('/read1549', (req, res) => {\n  const base = path1549.join(__dirname, 'files');\n  const safe = path1549.join(base, path1549.basename(String(req.query.file1549 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1551,
    "code": "app.get('/go1551', (req, res) => {\n  res.redirect(req.query.url1551);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1552,
    "code": "app.get('/go1551', (req, res) => {\n  const url = String(req.query.url1551 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1553,
    "code": "const JWT_SECRET_1553 = \"super-secret-1553\";\nfunction sign1553(data){ return \"signed-\" + JWT_SECRET_1553; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1554,
    "code": "const JWT_SECRET_1553 = process.env.JWT_SECRET_1553;\nfunction sign1553(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1555,
    "code": "app.get('/login1555', (req, res) => {\n  res.cookie('sid1555', 'token1555');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1556,
    "code": "app.get('/login1555', (req, res) => {\n  res.cookie('sid1555', 'token1555', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1557,
    "code": "app.post('/vote1557', (req, res) => {\n  const choice = req.body.choice1557;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1558,
    "code": "app.post('/vote1557', (req, res) => {\n  const choice = String(req.body.choice1557 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1559,
    "code": "app.post('/register1559', (req, res) => {\n  console.log(\"New user\", req.body.email1559, req.body.password1559);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1560,
    "code": "app.post('/register1559', (req, res) => {\n  console.log(\"New user\", req.body.email1559);\n  const body = { ...req.body }; delete body.password1559;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1561,
    "code": "app.get('/user1561', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1561 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1562,
    "code": "app.get('/user1561', async (req, res) => {\n  const u = String(req.query.u1561 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1563,
    "code": "app.post('/zip1563', (req, res) => {\n  const archive = \"archive_1563.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1563;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1564,
    "code": "app.post('/zip1563', (req, res) => {\n  const archive = \"archive_1563.zip\";\n  const dir = String(req.body.dir1563 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1565,
    "code": "app.post('/cfg1565', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1565 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1566,
    "code": "app.post('/cfg1565', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1565 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1567,
    "code": "app.use('/api1567', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1568,
    "code": "const allowedOrigins1567 = new Set([\"https://example1567.com\"]);\napp.use('/api1567', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1567.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1569,
    "code": "app.get('/fetch1569', async (req, res) => {\n  const r = await fetch(req.query.url1569);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1570,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1569', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1569 || \"\"));\n    const allowedHosts = new Set([\"example1569.com\",\"api1569.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1571,
    "code": "app.post('/auth1571', async (req, res) => {\n  const ok = await authUser(req.body.u1571, req.body.p1571);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1572,
    "code": "const attempts1571 = new Map();\napp.post('/auth1571', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1571.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1571.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1571, req.body.p1571);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1573,
    "code": "app.post('/upload1573', (req, res) => {\n  req.files.file1573.mv(\"./uploads/\" + req.files.file1573.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1574,
    "code": "const path_up1573 = require('path');\napp.post('/upload1573', (req, res) => {\n  const f = req.files && req.files.file1573;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1573.basename(f.name);\n  f.mv(path_up1573.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1575,
    "code": "router.get('/acct1575', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1575 WHERE id = \" + req.query.id1575)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1576,
    "code": "router.get('/acct1575', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1575 WHERE id = ?\", [req.query.id1575])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1577,
    "code": "app.get('/hello1577', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1577 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1578,
    "code": "const escapeHtml1577 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1577', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1577(req.query.name1577 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1579,
    "code": "app.get('/read1579', (req, res) => {\n  const p = \"./files/\" + req.query.file1579;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1580,
    "code": "const path1579 = require('path');\napp.get('/read1579', (req, res) => {\n  const base = path1579.join(__dirname, 'files');\n  const safe = path1579.join(base, path1579.basename(String(req.query.file1579 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1581,
    "code": "app.get('/go1581', (req, res) => {\n  res.redirect(req.query.url1581);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1582,
    "code": "app.get('/go1581', (req, res) => {\n  const url = String(req.query.url1581 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1583,
    "code": "const JWT_SECRET_1583 = \"super-secret-1583\";\nfunction sign1583(data){ return \"signed-\" + JWT_SECRET_1583; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1584,
    "code": "const JWT_SECRET_1583 = process.env.JWT_SECRET_1583;\nfunction sign1583(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1585,
    "code": "app.get('/login1585', (req, res) => {\n  res.cookie('sid1585', 'token1585');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1586,
    "code": "app.get('/login1585', (req, res) => {\n  res.cookie('sid1585', 'token1585', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1587,
    "code": "app.post('/vote1587', (req, res) => {\n  const choice = req.body.choice1587;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1588,
    "code": "app.post('/vote1587', (req, res) => {\n  const choice = String(req.body.choice1587 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1589,
    "code": "app.post('/register1589', (req, res) => {\n  console.log(\"New user\", req.body.email1589, req.body.password1589);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1590,
    "code": "app.post('/register1589', (req, res) => {\n  console.log(\"New user\", req.body.email1589);\n  const body = { ...req.body }; delete body.password1589;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1591,
    "code": "app.get('/user1591', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1591 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1592,
    "code": "app.get('/user1591', async (req, res) => {\n  const u = String(req.query.u1591 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1593,
    "code": "app.post('/zip1593', (req, res) => {\n  const archive = \"archive_1593.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1593;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1594,
    "code": "app.post('/zip1593', (req, res) => {\n  const archive = \"archive_1593.zip\";\n  const dir = String(req.body.dir1593 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1595,
    "code": "app.post('/cfg1595', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1595 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1596,
    "code": "app.post('/cfg1595', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1595 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1597,
    "code": "app.use('/api1597', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1598,
    "code": "const allowedOrigins1597 = new Set([\"https://example1597.com\"]);\napp.use('/api1597', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1597.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1599,
    "code": "app.get('/fetch1599', async (req, res) => {\n  const r = await fetch(req.query.url1599);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1600,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1599', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1599 || \"\"));\n    const allowedHosts = new Set([\"example1599.com\",\"api1599.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1601,
    "code": "app.post('/auth1601', async (req, res) => {\n  const ok = await authUser(req.body.u1601, req.body.p1601);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1602,
    "code": "const attempts1601 = new Map();\napp.post('/auth1601', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1601.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1601.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1601, req.body.p1601);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1603,
    "code": "app.post('/upload1603', (req, res) => {\n  req.files.file1603.mv(\"./uploads/\" + req.files.file1603.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1604,
    "code": "const path_up1603 = require('path');\napp.post('/upload1603', (req, res) => {\n  const f = req.files && req.files.file1603;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1603.basename(f.name);\n  f.mv(path_up1603.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1605,
    "code": "router.get('/acct1605', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1605 WHERE id = \" + req.query.id1605)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1606,
    "code": "router.get('/acct1605', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1605 WHERE id = ?\", [req.query.id1605])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1607,
    "code": "app.get('/hello1607', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1607 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1608,
    "code": "const escapeHtml1607 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1607', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1607(req.query.name1607 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1609,
    "code": "app.get('/read1609', (req, res) => {\n  const p = \"./files/\" + req.query.file1609;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1610,
    "code": "const path1609 = require('path');\napp.get('/read1609', (req, res) => {\n  const base = path1609.join(__dirname, 'files');\n  const safe = path1609.join(base, path1609.basename(String(req.query.file1609 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1611,
    "code": "app.get('/go1611', (req, res) => {\n  res.redirect(req.query.url1611);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1612,
    "code": "app.get('/go1611', (req, res) => {\n  const url = String(req.query.url1611 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1613,
    "code": "const JWT_SECRET_1613 = \"super-secret-1613\";\nfunction sign1613(data){ return \"signed-\" + JWT_SECRET_1613; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1614,
    "code": "const JWT_SECRET_1613 = process.env.JWT_SECRET_1613;\nfunction sign1613(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1615,
    "code": "app.get('/login1615', (req, res) => {\n  res.cookie('sid1615', 'token1615');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1616,
    "code": "app.get('/login1615', (req, res) => {\n  res.cookie('sid1615', 'token1615', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1617,
    "code": "app.post('/vote1617', (req, res) => {\n  const choice = req.body.choice1617;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1618,
    "code": "app.post('/vote1617', (req, res) => {\n  const choice = String(req.body.choice1617 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1619,
    "code": "app.post('/register1619', (req, res) => {\n  console.log(\"New user\", req.body.email1619, req.body.password1619);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1620,
    "code": "app.post('/register1619', (req, res) => {\n  console.log(\"New user\", req.body.email1619);\n  const body = { ...req.body }; delete body.password1619;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1621,
    "code": "app.get('/user1621', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1621 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1622,
    "code": "app.get('/user1621', async (req, res) => {\n  const u = String(req.query.u1621 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1623,
    "code": "app.post('/zip1623', (req, res) => {\n  const archive = \"archive_1623.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1623;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1624,
    "code": "app.post('/zip1623', (req, res) => {\n  const archive = \"archive_1623.zip\";\n  const dir = String(req.body.dir1623 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1625,
    "code": "app.post('/cfg1625', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1625 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1626,
    "code": "app.post('/cfg1625', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1625 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1627,
    "code": "app.use('/api1627', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1628,
    "code": "const allowedOrigins1627 = new Set([\"https://example1627.com\"]);\napp.use('/api1627', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1627.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1629,
    "code": "app.get('/fetch1629', async (req, res) => {\n  const r = await fetch(req.query.url1629);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1630,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1629', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1629 || \"\"));\n    const allowedHosts = new Set([\"example1629.com\",\"api1629.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1631,
    "code": "app.post('/auth1631', async (req, res) => {\n  const ok = await authUser(req.body.u1631, req.body.p1631);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1632,
    "code": "const attempts1631 = new Map();\napp.post('/auth1631', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1631.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1631.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1631, req.body.p1631);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1633,
    "code": "app.post('/upload1633', (req, res) => {\n  req.files.file1633.mv(\"./uploads/\" + req.files.file1633.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1634,
    "code": "const path_up1633 = require('path');\napp.post('/upload1633', (req, res) => {\n  const f = req.files && req.files.file1633;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1633.basename(f.name);\n  f.mv(path_up1633.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1635,
    "code": "router.get('/acct1635', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1635 WHERE id = \" + req.query.id1635)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1636,
    "code": "router.get('/acct1635', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1635 WHERE id = ?\", [req.query.id1635])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1637,
    "code": "app.get('/hello1637', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1637 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1638,
    "code": "const escapeHtml1637 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1637', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1637(req.query.name1637 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1639,
    "code": "app.get('/read1639', (req, res) => {\n  const p = \"./files/\" + req.query.file1639;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1640,
    "code": "const path1639 = require('path');\napp.get('/read1639', (req, res) => {\n  const base = path1639.join(__dirname, 'files');\n  const safe = path1639.join(base, path1639.basename(String(req.query.file1639 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1641,
    "code": "app.get('/go1641', (req, res) => {\n  res.redirect(req.query.url1641);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1642,
    "code": "app.get('/go1641', (req, res) => {\n  const url = String(req.query.url1641 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1643,
    "code": "const JWT_SECRET_1643 = \"super-secret-1643\";\nfunction sign1643(data){ return \"signed-\" + JWT_SECRET_1643; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1644,
    "code": "const JWT_SECRET_1643 = process.env.JWT_SECRET_1643;\nfunction sign1643(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1645,
    "code": "app.get('/login1645', (req, res) => {\n  res.cookie('sid1645', 'token1645');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1646,
    "code": "app.get('/login1645', (req, res) => {\n  res.cookie('sid1645', 'token1645', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1647,
    "code": "app.post('/vote1647', (req, res) => {\n  const choice = req.body.choice1647;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1648,
    "code": "app.post('/vote1647', (req, res) => {\n  const choice = String(req.body.choice1647 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1649,
    "code": "app.post('/register1649', (req, res) => {\n  console.log(\"New user\", req.body.email1649, req.body.password1649);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1650,
    "code": "app.post('/register1649', (req, res) => {\n  console.log(\"New user\", req.body.email1649);\n  const body = { ...req.body }; delete body.password1649;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1651,
    "code": "app.get('/user1651', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1651 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1652,
    "code": "app.get('/user1651', async (req, res) => {\n  const u = String(req.query.u1651 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1653,
    "code": "app.post('/zip1653', (req, res) => {\n  const archive = \"archive_1653.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1653;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1654,
    "code": "app.post('/zip1653', (req, res) => {\n  const archive = \"archive_1653.zip\";\n  const dir = String(req.body.dir1653 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1655,
    "code": "app.post('/cfg1655', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1655 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1656,
    "code": "app.post('/cfg1655', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1655 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1657,
    "code": "app.use('/api1657', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1658,
    "code": "const allowedOrigins1657 = new Set([\"https://example1657.com\"]);\napp.use('/api1657', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1657.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1659,
    "code": "app.get('/fetch1659', async (req, res) => {\n  const r = await fetch(req.query.url1659);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1660,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1659', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1659 || \"\"));\n    const allowedHosts = new Set([\"example1659.com\",\"api1659.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1661,
    "code": "app.post('/auth1661', async (req, res) => {\n  const ok = await authUser(req.body.u1661, req.body.p1661);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1662,
    "code": "const attempts1661 = new Map();\napp.post('/auth1661', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1661.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1661.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1661, req.body.p1661);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1663,
    "code": "app.post('/upload1663', (req, res) => {\n  req.files.file1663.mv(\"./uploads/\" + req.files.file1663.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1664,
    "code": "const path_up1663 = require('path');\napp.post('/upload1663', (req, res) => {\n  const f = req.files && req.files.file1663;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1663.basename(f.name);\n  f.mv(path_up1663.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1665,
    "code": "router.get('/acct1665', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1665 WHERE id = \" + req.query.id1665)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1666,
    "code": "router.get('/acct1665', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1665 WHERE id = ?\", [req.query.id1665])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1667,
    "code": "app.get('/hello1667', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1667 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1668,
    "code": "const escapeHtml1667 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1667', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1667(req.query.name1667 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1669,
    "code": "app.get('/read1669', (req, res) => {\n  const p = \"./files/\" + req.query.file1669;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1670,
    "code": "const path1669 = require('path');\napp.get('/read1669', (req, res) => {\n  const base = path1669.join(__dirname, 'files');\n  const safe = path1669.join(base, path1669.basename(String(req.query.file1669 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1671,
    "code": "app.get('/go1671', (req, res) => {\n  res.redirect(req.query.url1671);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1672,
    "code": "app.get('/go1671', (req, res) => {\n  const url = String(req.query.url1671 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1673,
    "code": "const JWT_SECRET_1673 = \"super-secret-1673\";\nfunction sign1673(data){ return \"signed-\" + JWT_SECRET_1673; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1674,
    "code": "const JWT_SECRET_1673 = process.env.JWT_SECRET_1673;\nfunction sign1673(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1675,
    "code": "app.get('/login1675', (req, res) => {\n  res.cookie('sid1675', 'token1675');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1676,
    "code": "app.get('/login1675', (req, res) => {\n  res.cookie('sid1675', 'token1675', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1677,
    "code": "app.post('/vote1677', (req, res) => {\n  const choice = req.body.choice1677;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1678,
    "code": "app.post('/vote1677', (req, res) => {\n  const choice = String(req.body.choice1677 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1679,
    "code": "app.post('/register1679', (req, res) => {\n  console.log(\"New user\", req.body.email1679, req.body.password1679);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1680,
    "code": "app.post('/register1679', (req, res) => {\n  console.log(\"New user\", req.body.email1679);\n  const body = { ...req.body }; delete body.password1679;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1681,
    "code": "app.get('/user1681', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1681 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1682,
    "code": "app.get('/user1681', async (req, res) => {\n  const u = String(req.query.u1681 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1683,
    "code": "app.post('/zip1683', (req, res) => {\n  const archive = \"archive_1683.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1683;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1684,
    "code": "app.post('/zip1683', (req, res) => {\n  const archive = \"archive_1683.zip\";\n  const dir = String(req.body.dir1683 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1685,
    "code": "app.post('/cfg1685', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1685 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1686,
    "code": "app.post('/cfg1685', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1685 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1687,
    "code": "app.use('/api1687', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1688,
    "code": "const allowedOrigins1687 = new Set([\"https://example1687.com\"]);\napp.use('/api1687', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1687.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1689,
    "code": "app.get('/fetch1689', async (req, res) => {\n  const r = await fetch(req.query.url1689);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1690,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1689', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1689 || \"\"));\n    const allowedHosts = new Set([\"example1689.com\",\"api1689.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1691,
    "code": "app.post('/auth1691', async (req, res) => {\n  const ok = await authUser(req.body.u1691, req.body.p1691);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1692,
    "code": "const attempts1691 = new Map();\napp.post('/auth1691', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1691.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1691.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1691, req.body.p1691);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1693,
    "code": "app.post('/upload1693', (req, res) => {\n  req.files.file1693.mv(\"./uploads/\" + req.files.file1693.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1694,
    "code": "const path_up1693 = require('path');\napp.post('/upload1693', (req, res) => {\n  const f = req.files && req.files.file1693;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1693.basename(f.name);\n  f.mv(path_up1693.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1695,
    "code": "router.get('/acct1695', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1695 WHERE id = \" + req.query.id1695)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1696,
    "code": "router.get('/acct1695', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1695 WHERE id = ?\", [req.query.id1695])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1697,
    "code": "app.get('/hello1697', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1697 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1698,
    "code": "const escapeHtml1697 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1697', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1697(req.query.name1697 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1699,
    "code": "app.get('/read1699', (req, res) => {\n  const p = \"./files/\" + req.query.file1699;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1700,
    "code": "const path1699 = require('path');\napp.get('/read1699', (req, res) => {\n  const base = path1699.join(__dirname, 'files');\n  const safe = path1699.join(base, path1699.basename(String(req.query.file1699 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1701,
    "code": "app.get('/go1701', (req, res) => {\n  res.redirect(req.query.url1701);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1702,
    "code": "app.get('/go1701', (req, res) => {\n  const url = String(req.query.url1701 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1703,
    "code": "const JWT_SECRET_1703 = \"super-secret-1703\";\nfunction sign1703(data){ return \"signed-\" + JWT_SECRET_1703; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1704,
    "code": "const JWT_SECRET_1703 = process.env.JWT_SECRET_1703;\nfunction sign1703(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1705,
    "code": "app.get('/login1705', (req, res) => {\n  res.cookie('sid1705', 'token1705');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1706,
    "code": "app.get('/login1705', (req, res) => {\n  res.cookie('sid1705', 'token1705', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1707,
    "code": "app.post('/vote1707', (req, res) => {\n  const choice = req.body.choice1707;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1708,
    "code": "app.post('/vote1707', (req, res) => {\n  const choice = String(req.body.choice1707 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1709,
    "code": "app.post('/register1709', (req, res) => {\n  console.log(\"New user\", req.body.email1709, req.body.password1709);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1710,
    "code": "app.post('/register1709', (req, res) => {\n  console.log(\"New user\", req.body.email1709);\n  const body = { ...req.body }; delete body.password1709;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1711,
    "code": "app.get('/user1711', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1711 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1712,
    "code": "app.get('/user1711', async (req, res) => {\n  const u = String(req.query.u1711 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1713,
    "code": "app.post('/zip1713', (req, res) => {\n  const archive = \"archive_1713.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1713;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1714,
    "code": "app.post('/zip1713', (req, res) => {\n  const archive = \"archive_1713.zip\";\n  const dir = String(req.body.dir1713 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1715,
    "code": "app.post('/cfg1715', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1715 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1716,
    "code": "app.post('/cfg1715', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1715 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1717,
    "code": "app.use('/api1717', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1718,
    "code": "const allowedOrigins1717 = new Set([\"https://example1717.com\"]);\napp.use('/api1717', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1717.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1719,
    "code": "app.get('/fetch1719', async (req, res) => {\n  const r = await fetch(req.query.url1719);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1720,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1719', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1719 || \"\"));\n    const allowedHosts = new Set([\"example1719.com\",\"api1719.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1721,
    "code": "app.post('/auth1721', async (req, res) => {\n  const ok = await authUser(req.body.u1721, req.body.p1721);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1722,
    "code": "const attempts1721 = new Map();\napp.post('/auth1721', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1721.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1721.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1721, req.body.p1721);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1723,
    "code": "app.post('/upload1723', (req, res) => {\n  req.files.file1723.mv(\"./uploads/\" + req.files.file1723.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1724,
    "code": "const path_up1723 = require('path');\napp.post('/upload1723', (req, res) => {\n  const f = req.files && req.files.file1723;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1723.basename(f.name);\n  f.mv(path_up1723.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1725,
    "code": "router.get('/acct1725', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1725 WHERE id = \" + req.query.id1725)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1726,
    "code": "router.get('/acct1725', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1725 WHERE id = ?\", [req.query.id1725])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1727,
    "code": "app.get('/hello1727', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1727 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1728,
    "code": "const escapeHtml1727 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1727', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1727(req.query.name1727 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1729,
    "code": "app.get('/read1729', (req, res) => {\n  const p = \"./files/\" + req.query.file1729;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1730,
    "code": "const path1729 = require('path');\napp.get('/read1729', (req, res) => {\n  const base = path1729.join(__dirname, 'files');\n  const safe = path1729.join(base, path1729.basename(String(req.query.file1729 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1731,
    "code": "app.get('/go1731', (req, res) => {\n  res.redirect(req.query.url1731);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1732,
    "code": "app.get('/go1731', (req, res) => {\n  const url = String(req.query.url1731 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1733,
    "code": "const JWT_SECRET_1733 = \"super-secret-1733\";\nfunction sign1733(data){ return \"signed-\" + JWT_SECRET_1733; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1734,
    "code": "const JWT_SECRET_1733 = process.env.JWT_SECRET_1733;\nfunction sign1733(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1735,
    "code": "app.get('/login1735', (req, res) => {\n  res.cookie('sid1735', 'token1735');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1736,
    "code": "app.get('/login1735', (req, res) => {\n  res.cookie('sid1735', 'token1735', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1737,
    "code": "app.post('/vote1737', (req, res) => {\n  const choice = req.body.choice1737;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1738,
    "code": "app.post('/vote1737', (req, res) => {\n  const choice = String(req.body.choice1737 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1739,
    "code": "app.post('/register1739', (req, res) => {\n  console.log(\"New user\", req.body.email1739, req.body.password1739);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1740,
    "code": "app.post('/register1739', (req, res) => {\n  console.log(\"New user\", req.body.email1739);\n  const body = { ...req.body }; delete body.password1739;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1741,
    "code": "app.get('/user1741', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1741 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1742,
    "code": "app.get('/user1741', async (req, res) => {\n  const u = String(req.query.u1741 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1743,
    "code": "app.post('/zip1743', (req, res) => {\n  const archive = \"archive_1743.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1743;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1744,
    "code": "app.post('/zip1743', (req, res) => {\n  const archive = \"archive_1743.zip\";\n  const dir = String(req.body.dir1743 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1745,
    "code": "app.post('/cfg1745', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1745 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1746,
    "code": "app.post('/cfg1745', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1745 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1747,
    "code": "app.use('/api1747', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1748,
    "code": "const allowedOrigins1747 = new Set([\"https://example1747.com\"]);\napp.use('/api1747', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1747.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1749,
    "code": "app.get('/fetch1749', async (req, res) => {\n  const r = await fetch(req.query.url1749);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1750,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1749', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1749 || \"\"));\n    const allowedHosts = new Set([\"example1749.com\",\"api1749.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1751,
    "code": "app.post('/auth1751', async (req, res) => {\n  const ok = await authUser(req.body.u1751, req.body.p1751);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1752,
    "code": "const attempts1751 = new Map();\napp.post('/auth1751', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1751.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1751.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1751, req.body.p1751);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1753,
    "code": "app.post('/upload1753', (req, res) => {\n  req.files.file1753.mv(\"./uploads/\" + req.files.file1753.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1754,
    "code": "const path_up1753 = require('path');\napp.post('/upload1753', (req, res) => {\n  const f = req.files && req.files.file1753;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1753.basename(f.name);\n  f.mv(path_up1753.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1755,
    "code": "router.get('/acct1755', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1755 WHERE id = \" + req.query.id1755)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1756,
    "code": "router.get('/acct1755', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1755 WHERE id = ?\", [req.query.id1755])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1757,
    "code": "app.get('/hello1757', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1757 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1758,
    "code": "const escapeHtml1757 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1757', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1757(req.query.name1757 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1759,
    "code": "app.get('/read1759', (req, res) => {\n  const p = \"./files/\" + req.query.file1759;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1760,
    "code": "const path1759 = require('path');\napp.get('/read1759', (req, res) => {\n  const base = path1759.join(__dirname, 'files');\n  const safe = path1759.join(base, path1759.basename(String(req.query.file1759 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1761,
    "code": "app.get('/go1761', (req, res) => {\n  res.redirect(req.query.url1761);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1762,
    "code": "app.get('/go1761', (req, res) => {\n  const url = String(req.query.url1761 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1763,
    "code": "const JWT_SECRET_1763 = \"super-secret-1763\";\nfunction sign1763(data){ return \"signed-\" + JWT_SECRET_1763; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1764,
    "code": "const JWT_SECRET_1763 = process.env.JWT_SECRET_1763;\nfunction sign1763(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1765,
    "code": "app.get('/login1765', (req, res) => {\n  res.cookie('sid1765', 'token1765');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1766,
    "code": "app.get('/login1765', (req, res) => {\n  res.cookie('sid1765', 'token1765', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1767,
    "code": "app.post('/vote1767', (req, res) => {\n  const choice = req.body.choice1767;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1768,
    "code": "app.post('/vote1767', (req, res) => {\n  const choice = String(req.body.choice1767 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1769,
    "code": "app.post('/register1769', (req, res) => {\n  console.log(\"New user\", req.body.email1769, req.body.password1769);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1770,
    "code": "app.post('/register1769', (req, res) => {\n  console.log(\"New user\", req.body.email1769);\n  const body = { ...req.body }; delete body.password1769;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1771,
    "code": "app.get('/user1771', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1771 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1772,
    "code": "app.get('/user1771', async (req, res) => {\n  const u = String(req.query.u1771 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1773,
    "code": "app.post('/zip1773', (req, res) => {\n  const archive = \"archive_1773.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1773;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1774,
    "code": "app.post('/zip1773', (req, res) => {\n  const archive = \"archive_1773.zip\";\n  const dir = String(req.body.dir1773 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1775,
    "code": "app.post('/cfg1775', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1775 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1776,
    "code": "app.post('/cfg1775', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1775 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1777,
    "code": "app.use('/api1777', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1778,
    "code": "const allowedOrigins1777 = new Set([\"https://example1777.com\"]);\napp.use('/api1777', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1777.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1779,
    "code": "app.get('/fetch1779', async (req, res) => {\n  const r = await fetch(req.query.url1779);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1780,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1779', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1779 || \"\"));\n    const allowedHosts = new Set([\"example1779.com\",\"api1779.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1781,
    "code": "app.post('/auth1781', async (req, res) => {\n  const ok = await authUser(req.body.u1781, req.body.p1781);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1782,
    "code": "const attempts1781 = new Map();\napp.post('/auth1781', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1781.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1781.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1781, req.body.p1781);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1783,
    "code": "app.post('/upload1783', (req, res) => {\n  req.files.file1783.mv(\"./uploads/\" + req.files.file1783.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1784,
    "code": "const path_up1783 = require('path');\napp.post('/upload1783', (req, res) => {\n  const f = req.files && req.files.file1783;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1783.basename(f.name);\n  f.mv(path_up1783.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1785,
    "code": "router.get('/acct1785', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1785 WHERE id = \" + req.query.id1785)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1786,
    "code": "router.get('/acct1785', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1785 WHERE id = ?\", [req.query.id1785])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1787,
    "code": "app.get('/hello1787', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1787 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1788,
    "code": "const escapeHtml1787 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1787', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1787(req.query.name1787 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1789,
    "code": "app.get('/read1789', (req, res) => {\n  const p = \"./files/\" + req.query.file1789;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1790,
    "code": "const path1789 = require('path');\napp.get('/read1789', (req, res) => {\n  const base = path1789.join(__dirname, 'files');\n  const safe = path1789.join(base, path1789.basename(String(req.query.file1789 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1791,
    "code": "app.get('/go1791', (req, res) => {\n  res.redirect(req.query.url1791);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1792,
    "code": "app.get('/go1791', (req, res) => {\n  const url = String(req.query.url1791 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1793,
    "code": "const JWT_SECRET_1793 = \"super-secret-1793\";\nfunction sign1793(data){ return \"signed-\" + JWT_SECRET_1793; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1794,
    "code": "const JWT_SECRET_1793 = process.env.JWT_SECRET_1793;\nfunction sign1793(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1795,
    "code": "app.get('/login1795', (req, res) => {\n  res.cookie('sid1795', 'token1795');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1796,
    "code": "app.get('/login1795', (req, res) => {\n  res.cookie('sid1795', 'token1795', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1797,
    "code": "app.post('/vote1797', (req, res) => {\n  const choice = req.body.choice1797;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1798,
    "code": "app.post('/vote1797', (req, res) => {\n  const choice = String(req.body.choice1797 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1799,
    "code": "app.post('/register1799', (req, res) => {\n  console.log(\"New user\", req.body.email1799, req.body.password1799);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1800,
    "code": "app.post('/register1799', (req, res) => {\n  console.log(\"New user\", req.body.email1799);\n  const body = { ...req.body }; delete body.password1799;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1801,
    "code": "app.get('/user1801', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1801 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1802,
    "code": "app.get('/user1801', async (req, res) => {\n  const u = String(req.query.u1801 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1803,
    "code": "app.post('/zip1803', (req, res) => {\n  const archive = \"archive_1803.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1803;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1804,
    "code": "app.post('/zip1803', (req, res) => {\n  const archive = \"archive_1803.zip\";\n  const dir = String(req.body.dir1803 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1805,
    "code": "app.post('/cfg1805', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1805 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1806,
    "code": "app.post('/cfg1805', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1805 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1807,
    "code": "app.use('/api1807', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1808,
    "code": "const allowedOrigins1807 = new Set([\"https://example1807.com\"]);\napp.use('/api1807', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1807.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1809,
    "code": "app.get('/fetch1809', async (req, res) => {\n  const r = await fetch(req.query.url1809);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1810,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1809', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1809 || \"\"));\n    const allowedHosts = new Set([\"example1809.com\",\"api1809.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1811,
    "code": "app.post('/auth1811', async (req, res) => {\n  const ok = await authUser(req.body.u1811, req.body.p1811);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1812,
    "code": "const attempts1811 = new Map();\napp.post('/auth1811', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1811.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1811.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1811, req.body.p1811);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1813,
    "code": "app.post('/upload1813', (req, res) => {\n  req.files.file1813.mv(\"./uploads/\" + req.files.file1813.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1814,
    "code": "const path_up1813 = require('path');\napp.post('/upload1813', (req, res) => {\n  const f = req.files && req.files.file1813;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1813.basename(f.name);\n  f.mv(path_up1813.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1815,
    "code": "router.get('/acct1815', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1815 WHERE id = \" + req.query.id1815)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1816,
    "code": "router.get('/acct1815', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1815 WHERE id = ?\", [req.query.id1815])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1817,
    "code": "app.get('/hello1817', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1817 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1818,
    "code": "const escapeHtml1817 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1817', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1817(req.query.name1817 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1819,
    "code": "app.get('/read1819', (req, res) => {\n  const p = \"./files/\" + req.query.file1819;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1820,
    "code": "const path1819 = require('path');\napp.get('/read1819', (req, res) => {\n  const base = path1819.join(__dirname, 'files');\n  const safe = path1819.join(base, path1819.basename(String(req.query.file1819 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1821,
    "code": "app.get('/go1821', (req, res) => {\n  res.redirect(req.query.url1821);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1822,
    "code": "app.get('/go1821', (req, res) => {\n  const url = String(req.query.url1821 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1823,
    "code": "const JWT_SECRET_1823 = \"super-secret-1823\";\nfunction sign1823(data){ return \"signed-\" + JWT_SECRET_1823; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1824,
    "code": "const JWT_SECRET_1823 = process.env.JWT_SECRET_1823;\nfunction sign1823(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1825,
    "code": "app.get('/login1825', (req, res) => {\n  res.cookie('sid1825', 'token1825');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1826,
    "code": "app.get('/login1825', (req, res) => {\n  res.cookie('sid1825', 'token1825', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1827,
    "code": "app.post('/vote1827', (req, res) => {\n  const choice = req.body.choice1827;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1828,
    "code": "app.post('/vote1827', (req, res) => {\n  const choice = String(req.body.choice1827 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1829,
    "code": "app.post('/register1829', (req, res) => {\n  console.log(\"New user\", req.body.email1829, req.body.password1829);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1830,
    "code": "app.post('/register1829', (req, res) => {\n  console.log(\"New user\", req.body.email1829);\n  const body = { ...req.body }; delete body.password1829;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1831,
    "code": "app.get('/user1831', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1831 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1832,
    "code": "app.get('/user1831', async (req, res) => {\n  const u = String(req.query.u1831 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1833,
    "code": "app.post('/zip1833', (req, res) => {\n  const archive = \"archive_1833.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1833;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1834,
    "code": "app.post('/zip1833', (req, res) => {\n  const archive = \"archive_1833.zip\";\n  const dir = String(req.body.dir1833 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1835,
    "code": "app.post('/cfg1835', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1835 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1836,
    "code": "app.post('/cfg1835', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1835 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1837,
    "code": "app.use('/api1837', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1838,
    "code": "const allowedOrigins1837 = new Set([\"https://example1837.com\"]);\napp.use('/api1837', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1837.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1839,
    "code": "app.get('/fetch1839', async (req, res) => {\n  const r = await fetch(req.query.url1839);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1840,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1839', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1839 || \"\"));\n    const allowedHosts = new Set([\"example1839.com\",\"api1839.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1841,
    "code": "app.post('/auth1841', async (req, res) => {\n  const ok = await authUser(req.body.u1841, req.body.p1841);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1842,
    "code": "const attempts1841 = new Map();\napp.post('/auth1841', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1841.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1841.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1841, req.body.p1841);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1843,
    "code": "app.post('/upload1843', (req, res) => {\n  req.files.file1843.mv(\"./uploads/\" + req.files.file1843.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1844,
    "code": "const path_up1843 = require('path');\napp.post('/upload1843', (req, res) => {\n  const f = req.files && req.files.file1843;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1843.basename(f.name);\n  f.mv(path_up1843.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1845,
    "code": "router.get('/acct1845', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1845 WHERE id = \" + req.query.id1845)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1846,
    "code": "router.get('/acct1845', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1845 WHERE id = ?\", [req.query.id1845])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1847,
    "code": "app.get('/hello1847', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1847 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1848,
    "code": "const escapeHtml1847 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1847', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1847(req.query.name1847 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1849,
    "code": "app.get('/read1849', (req, res) => {\n  const p = \"./files/\" + req.query.file1849;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1850,
    "code": "const path1849 = require('path');\napp.get('/read1849', (req, res) => {\n  const base = path1849.join(__dirname, 'files');\n  const safe = path1849.join(base, path1849.basename(String(req.query.file1849 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1851,
    "code": "app.get('/go1851', (req, res) => {\n  res.redirect(req.query.url1851);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1852,
    "code": "app.get('/go1851', (req, res) => {\n  const url = String(req.query.url1851 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1853,
    "code": "const JWT_SECRET_1853 = \"super-secret-1853\";\nfunction sign1853(data){ return \"signed-\" + JWT_SECRET_1853; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1854,
    "code": "const JWT_SECRET_1853 = process.env.JWT_SECRET_1853;\nfunction sign1853(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1855,
    "code": "app.get('/login1855', (req, res) => {\n  res.cookie('sid1855', 'token1855');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1856,
    "code": "app.get('/login1855', (req, res) => {\n  res.cookie('sid1855', 'token1855', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1857,
    "code": "app.post('/vote1857', (req, res) => {\n  const choice = req.body.choice1857;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1858,
    "code": "app.post('/vote1857', (req, res) => {\n  const choice = String(req.body.choice1857 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1859,
    "code": "app.post('/register1859', (req, res) => {\n  console.log(\"New user\", req.body.email1859, req.body.password1859);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1860,
    "code": "app.post('/register1859', (req, res) => {\n  console.log(\"New user\", req.body.email1859);\n  const body = { ...req.body }; delete body.password1859;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1861,
    "code": "app.get('/user1861', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1861 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1862,
    "code": "app.get('/user1861', async (req, res) => {\n  const u = String(req.query.u1861 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1863,
    "code": "app.post('/zip1863', (req, res) => {\n  const archive = \"archive_1863.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1863;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1864,
    "code": "app.post('/zip1863', (req, res) => {\n  const archive = \"archive_1863.zip\";\n  const dir = String(req.body.dir1863 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1865,
    "code": "app.post('/cfg1865', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1865 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1866,
    "code": "app.post('/cfg1865', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1865 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1867,
    "code": "app.use('/api1867', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1868,
    "code": "const allowedOrigins1867 = new Set([\"https://example1867.com\"]);\napp.use('/api1867', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1867.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1869,
    "code": "app.get('/fetch1869', async (req, res) => {\n  const r = await fetch(req.query.url1869);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1870,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1869', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1869 || \"\"));\n    const allowedHosts = new Set([\"example1869.com\",\"api1869.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1871,
    "code": "app.post('/auth1871', async (req, res) => {\n  const ok = await authUser(req.body.u1871, req.body.p1871);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1872,
    "code": "const attempts1871 = new Map();\napp.post('/auth1871', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1871.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1871.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1871, req.body.p1871);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1873,
    "code": "app.post('/upload1873', (req, res) => {\n  req.files.file1873.mv(\"./uploads/\" + req.files.file1873.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1874,
    "code": "const path_up1873 = require('path');\napp.post('/upload1873', (req, res) => {\n  const f = req.files && req.files.file1873;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1873.basename(f.name);\n  f.mv(path_up1873.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1875,
    "code": "router.get('/acct1875', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1875 WHERE id = \" + req.query.id1875)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1876,
    "code": "router.get('/acct1875', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1875 WHERE id = ?\", [req.query.id1875])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1877,
    "code": "app.get('/hello1877', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1877 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1878,
    "code": "const escapeHtml1877 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1877', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1877(req.query.name1877 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1879,
    "code": "app.get('/read1879', (req, res) => {\n  const p = \"./files/\" + req.query.file1879;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1880,
    "code": "const path1879 = require('path');\napp.get('/read1879', (req, res) => {\n  const base = path1879.join(__dirname, 'files');\n  const safe = path1879.join(base, path1879.basename(String(req.query.file1879 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1881,
    "code": "app.get('/go1881', (req, res) => {\n  res.redirect(req.query.url1881);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1882,
    "code": "app.get('/go1881', (req, res) => {\n  const url = String(req.query.url1881 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1883,
    "code": "const JWT_SECRET_1883 = \"super-secret-1883\";\nfunction sign1883(data){ return \"signed-\" + JWT_SECRET_1883; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1884,
    "code": "const JWT_SECRET_1883 = process.env.JWT_SECRET_1883;\nfunction sign1883(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1885,
    "code": "app.get('/login1885', (req, res) => {\n  res.cookie('sid1885', 'token1885');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1886,
    "code": "app.get('/login1885', (req, res) => {\n  res.cookie('sid1885', 'token1885', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1887,
    "code": "app.post('/vote1887', (req, res) => {\n  const choice = req.body.choice1887;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1888,
    "code": "app.post('/vote1887', (req, res) => {\n  const choice = String(req.body.choice1887 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1889,
    "code": "app.post('/register1889', (req, res) => {\n  console.log(\"New user\", req.body.email1889, req.body.password1889);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1890,
    "code": "app.post('/register1889', (req, res) => {\n  console.log(\"New user\", req.body.email1889);\n  const body = { ...req.body }; delete body.password1889;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1891,
    "code": "app.get('/user1891', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1891 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1892,
    "code": "app.get('/user1891', async (req, res) => {\n  const u = String(req.query.u1891 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1893,
    "code": "app.post('/zip1893', (req, res) => {\n  const archive = \"archive_1893.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1893;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1894,
    "code": "app.post('/zip1893', (req, res) => {\n  const archive = \"archive_1893.zip\";\n  const dir = String(req.body.dir1893 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1895,
    "code": "app.post('/cfg1895', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1895 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1896,
    "code": "app.post('/cfg1895', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1895 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1897,
    "code": "app.use('/api1897', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1898,
    "code": "const allowedOrigins1897 = new Set([\"https://example1897.com\"]);\napp.use('/api1897', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1897.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1899,
    "code": "app.get('/fetch1899', async (req, res) => {\n  const r = await fetch(req.query.url1899);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1900,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1899', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1899 || \"\"));\n    const allowedHosts = new Set([\"example1899.com\",\"api1899.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1901,
    "code": "app.post('/auth1901', async (req, res) => {\n  const ok = await authUser(req.body.u1901, req.body.p1901);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1902,
    "code": "const attempts1901 = new Map();\napp.post('/auth1901', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1901.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1901.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1901, req.body.p1901);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1903,
    "code": "app.post('/upload1903', (req, res) => {\n  req.files.file1903.mv(\"./uploads/\" + req.files.file1903.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1904,
    "code": "const path_up1903 = require('path');\napp.post('/upload1903', (req, res) => {\n  const f = req.files && req.files.file1903;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1903.basename(f.name);\n  f.mv(path_up1903.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1905,
    "code": "router.get('/acct1905', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1905 WHERE id = \" + req.query.id1905)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1906,
    "code": "router.get('/acct1905', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1905 WHERE id = ?\", [req.query.id1905])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1907,
    "code": "app.get('/hello1907', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1907 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1908,
    "code": "const escapeHtml1907 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1907', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1907(req.query.name1907 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1909,
    "code": "app.get('/read1909', (req, res) => {\n  const p = \"./files/\" + req.query.file1909;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1910,
    "code": "const path1909 = require('path');\napp.get('/read1909', (req, res) => {\n  const base = path1909.join(__dirname, 'files');\n  const safe = path1909.join(base, path1909.basename(String(req.query.file1909 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1911,
    "code": "app.get('/go1911', (req, res) => {\n  res.redirect(req.query.url1911);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1912,
    "code": "app.get('/go1911', (req, res) => {\n  const url = String(req.query.url1911 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1913,
    "code": "const JWT_SECRET_1913 = \"super-secret-1913\";\nfunction sign1913(data){ return \"signed-\" + JWT_SECRET_1913; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1914,
    "code": "const JWT_SECRET_1913 = process.env.JWT_SECRET_1913;\nfunction sign1913(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1915,
    "code": "app.get('/login1915', (req, res) => {\n  res.cookie('sid1915', 'token1915');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1916,
    "code": "app.get('/login1915', (req, res) => {\n  res.cookie('sid1915', 'token1915', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1917,
    "code": "app.post('/vote1917', (req, res) => {\n  const choice = req.body.choice1917;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1918,
    "code": "app.post('/vote1917', (req, res) => {\n  const choice = String(req.body.choice1917 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1919,
    "code": "app.post('/register1919', (req, res) => {\n  console.log(\"New user\", req.body.email1919, req.body.password1919);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1920,
    "code": "app.post('/register1919', (req, res) => {\n  console.log(\"New user\", req.body.email1919);\n  const body = { ...req.body }; delete body.password1919;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1921,
    "code": "app.get('/user1921', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1921 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1922,
    "code": "app.get('/user1921', async (req, res) => {\n  const u = String(req.query.u1921 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1923,
    "code": "app.post('/zip1923', (req, res) => {\n  const archive = \"archive_1923.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1923;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1924,
    "code": "app.post('/zip1923', (req, res) => {\n  const archive = \"archive_1923.zip\";\n  const dir = String(req.body.dir1923 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1925,
    "code": "app.post('/cfg1925', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1925 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1926,
    "code": "app.post('/cfg1925', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1925 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1927,
    "code": "app.use('/api1927', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1928,
    "code": "const allowedOrigins1927 = new Set([\"https://example1927.com\"]);\napp.use('/api1927', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1927.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1929,
    "code": "app.get('/fetch1929', async (req, res) => {\n  const r = await fetch(req.query.url1929);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1930,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1929', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1929 || \"\"));\n    const allowedHosts = new Set([\"example1929.com\",\"api1929.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1931,
    "code": "app.post('/auth1931', async (req, res) => {\n  const ok = await authUser(req.body.u1931, req.body.p1931);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1932,
    "code": "const attempts1931 = new Map();\napp.post('/auth1931', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1931.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1931.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1931, req.body.p1931);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1933,
    "code": "app.post('/upload1933', (req, res) => {\n  req.files.file1933.mv(\"./uploads/\" + req.files.file1933.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1934,
    "code": "const path_up1933 = require('path');\napp.post('/upload1933', (req, res) => {\n  const f = req.files && req.files.file1933;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1933.basename(f.name);\n  f.mv(path_up1933.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1935,
    "code": "router.get('/acct1935', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1935 WHERE id = \" + req.query.id1935)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1936,
    "code": "router.get('/acct1935', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1935 WHERE id = ?\", [req.query.id1935])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1937,
    "code": "app.get('/hello1937', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1937 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1938,
    "code": "const escapeHtml1937 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1937', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1937(req.query.name1937 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1939,
    "code": "app.get('/read1939', (req, res) => {\n  const p = \"./files/\" + req.query.file1939;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1940,
    "code": "const path1939 = require('path');\napp.get('/read1939', (req, res) => {\n  const base = path1939.join(__dirname, 'files');\n  const safe = path1939.join(base, path1939.basename(String(req.query.file1939 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1941,
    "code": "app.get('/go1941', (req, res) => {\n  res.redirect(req.query.url1941);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1942,
    "code": "app.get('/go1941', (req, res) => {\n  const url = String(req.query.url1941 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1943,
    "code": "const JWT_SECRET_1943 = \"super-secret-1943\";\nfunction sign1943(data){ return \"signed-\" + JWT_SECRET_1943; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1944,
    "code": "const JWT_SECRET_1943 = process.env.JWT_SECRET_1943;\nfunction sign1943(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1945,
    "code": "app.get('/login1945', (req, res) => {\n  res.cookie('sid1945', 'token1945');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1946,
    "code": "app.get('/login1945', (req, res) => {\n  res.cookie('sid1945', 'token1945', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1947,
    "code": "app.post('/vote1947', (req, res) => {\n  const choice = req.body.choice1947;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1948,
    "code": "app.post('/vote1947', (req, res) => {\n  const choice = String(req.body.choice1947 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1949,
    "code": "app.post('/register1949', (req, res) => {\n  console.log(\"New user\", req.body.email1949, req.body.password1949);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1950,
    "code": "app.post('/register1949', (req, res) => {\n  console.log(\"New user\", req.body.email1949);\n  const body = { ...req.body }; delete body.password1949;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1951,
    "code": "app.get('/user1951', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1951 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1952,
    "code": "app.get('/user1951', async (req, res) => {\n  const u = String(req.query.u1951 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1953,
    "code": "app.post('/zip1953', (req, res) => {\n  const archive = \"archive_1953.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1953;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1954,
    "code": "app.post('/zip1953', (req, res) => {\n  const archive = \"archive_1953.zip\";\n  const dir = String(req.body.dir1953 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1955,
    "code": "app.post('/cfg1955', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1955 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1956,
    "code": "app.post('/cfg1955', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1955 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1957,
    "code": "app.use('/api1957', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1958,
    "code": "const allowedOrigins1957 = new Set([\"https://example1957.com\"]);\napp.use('/api1957', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1957.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1959,
    "code": "app.get('/fetch1959', async (req, res) => {\n  const r = await fetch(req.query.url1959);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1960,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1959', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1959 || \"\"));\n    const allowedHosts = new Set([\"example1959.com\",\"api1959.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1961,
    "code": "app.post('/auth1961', async (req, res) => {\n  const ok = await authUser(req.body.u1961, req.body.p1961);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1962,
    "code": "const attempts1961 = new Map();\napp.post('/auth1961', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1961.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1961.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1961, req.body.p1961);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1963,
    "code": "app.post('/upload1963', (req, res) => {\n  req.files.file1963.mv(\"./uploads/\" + req.files.file1963.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1964,
    "code": "const path_up1963 = require('path');\napp.post('/upload1963', (req, res) => {\n  const f = req.files && req.files.file1963;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1963.basename(f.name);\n  f.mv(path_up1963.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1965,
    "code": "router.get('/acct1965', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1965 WHERE id = \" + req.query.id1965)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1966,
    "code": "router.get('/acct1965', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1965 WHERE id = ?\", [req.query.id1965])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1967,
    "code": "app.get('/hello1967', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1967 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1968,
    "code": "const escapeHtml1967 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1967', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1967(req.query.name1967 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1969,
    "code": "app.get('/read1969', (req, res) => {\n  const p = \"./files/\" + req.query.file1969;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 1970,
    "code": "const path1969 = require('path');\napp.get('/read1969', (req, res) => {\n  const base = path1969.join(__dirname, 'files');\n  const safe = path1969.join(base, path1969.basename(String(req.query.file1969 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1971,
    "code": "app.get('/go1971', (req, res) => {\n  res.redirect(req.query.url1971);\n});",
    "label": "insecure",
    "vulnerability_type": "Open Redirect",
    "explanation": "Redirecting to arbitrary URLs can be abused for phishing. Secure version restricts to relative paths."
  },
  {
    "id": 1972,
    "code": "app.get('/go1971', (req, res) => {\n  const url = String(req.query.url1971 || \"\");\n  if (!/^\\/[^\\s]*$/.test(url)) return res.status(400).send(\"Bad url\");\n  res.redirect(url);\n});",
    "label": "secure",
    "vulnerability_type": "Open Redirect",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1973,
    "code": "const JWT_SECRET_1973 = \"super-secret-1973\";\nfunction sign1973(data){ return \"signed-\" + JWT_SECRET_1973; }",
    "label": "insecure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "Secrets are hardcoded in source. Secure version loads from environment."
  },
  {
    "id": 1974,
    "code": "const JWT_SECRET_1973 = process.env.JWT_SECRET_1973;\nfunction sign1973(data){ /* use library with env secret */ return \"signed\"; }",
    "label": "secure",
    "vulnerability_type": "Hardcoded Secret",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1975,
    "code": "app.get('/login1975', (req, res) => {\n  res.cookie('sid1975', 'token1975');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "Cookies without security flags risk theft. Secure version sets httpOnly, secure, and SameSite."
  },
  {
    "id": 1976,
    "code": "app.get('/login1975', (req, res) => {\n  res.cookie('sid1975', 'token1975', { httpOnly: true, secure: true, sameSite: 'lax' });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1977,
    "code": "app.post('/vote1977', (req, res) => {\n  const choice = req.body.choice1977;\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "Accepting arbitrary values can corrupt state. Secure version validates against an allowlist."
  },
  {
    "id": 1978,
    "code": "app.post('/vote1977', (req, res) => {\n  const choice = String(req.body.choice1977 || \"\");\n  const allowed = new Set([\"A\",\"B\",\"C\"]);\n  if (!allowed.has(choice)) return res.status(400).send(\"Invalid choice\");\n  saveVote(choice);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Input Validation",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1979,
    "code": "app.post('/register1979', (req, res) => {\n  console.log(\"New user\", req.body.email1979, req.body.password1979);\n  createUser(req.body);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "Logging passwords leaks secrets. Secure version avoids logging sensitive fields."
  },
  {
    "id": 1980,
    "code": "app.post('/register1979', (req, res) => {\n  console.log(\"New user\", req.body.email1979);\n  const body = { ...req.body }; delete body.password1979;\n  createUser(body);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Sensitive Data Exposure (Logging)",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1981,
    "code": "app.get('/user1981', async (req, res) => {\n  // $where with user input\n  const users = await Users.find({ $where: \"this.username == '\" + req.query.u1981 + \"'\" });\n  res.send(users);\n});",
    "label": "insecure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "Using $where with user-controlled strings enables NoSQL injection. Secure version uses field match with basic sanitization."
  },
  {
    "id": 1982,
    "code": "app.get('/user1981', async (req, res) => {\n  const u = String(req.query.u1981 || \"\").replace(/[^\\w.-]/g, \"\");\n  const users = await Users.find({ username: u }).lean();\n  res.send(users);\n});",
    "label": "secure",
    "vulnerability_type": "NoSQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1983,
    "code": "app.post('/zip1983', (req, res) => {\n  const archive = \"archive_1983.zip\";\n  const cmd = \"zip -r \" + archive + \" \" + req.body.dir1983;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "insecure",
    "vulnerability_type": "Command Injection",
    "explanation": "Shell command built with unsanitized input. Secure version restricts allowed characters."
  },
  {
    "id": 1984,
    "code": "app.post('/zip1983', (req, res) => {\n  const archive = \"archive_1983.zip\";\n  const dir = String(req.body.dir1983 || \"\").replace(/[^\\w\\-\\/]/g, \"\");\n  const cmd = \"zip -r \" + archive + \" \" + dir;\n  require('child_process').exec(cmd, (e, out) => res.send(out));\n});",
    "label": "secure",
    "vulnerability_type": "Command Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1985,
    "code": "app.post('/cfg1985', (req, res) => {\n  const cfg = eval(\"(\" + req.body.cfg1985 + \")\");\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Evaluating untrusted input enables code execution. Secure version uses JSON.parse with error handling."
  },
  {
    "id": 1986,
    "code": "app.post('/cfg1985', (req, res) => {\n  let cfg;\n  try {\n    cfg = JSON.parse(String(req.body.cfg1985 || \"\"));\n  } catch (e) {\n    return res.status(400).send(\"Invalid config\");\n  }\n  applyConfig(cfg);\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1987,
    "code": "app.use('/api1987', (req, res, next) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "Allowing '*' with credentials violates CORS security. Secure version reflects only allowlisted origins."
  },
  {
    "id": 1988,
    "code": "const allowedOrigins1987 = new Set([\"https://example1987.com\"]);\napp.use('/api1987', (req, res, next) => {\n  const origin = req.get('Origin');\n  if (allowedOrigins1987.has(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n    res.set('Access-Control-Allow-Credentials', 'true');\n  }\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Insecure CORS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1989,
    "code": "app.get('/fetch1989', async (req, res) => {\n  const r = await fetch(req.query.url1989);\n  res.send(await r.text());\n});",
    "label": "insecure",
    "vulnerability_type": "SSRF",
    "explanation": "Fetching arbitrary URLs can hit internal services. Secure version allowlists hosts."
  },
  {
    "id": 1990,
    "code": "const {\"URL\"} = require('url');\napp.get('/fetch1989', async (req, res) => {\n  try {\n    const u = new URL(String(req.query.url1989 || \"\"));\n    const allowedHosts = new Set([\"example1989.com\",\"api1989.example.com\"]);\n    if (!allowedHosts.has(u.hostname)) return res.status(400).send(\"Disallowed host\");\n    const r = await fetch(u.toString());\n    res.send(await r.text());\n  } catch(e) {\n    res.status(400).send(\"Bad URL\");\n  }\n});",
    "label": "secure",
    "vulnerability_type": "SSRF",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1991,
    "code": "app.post('/auth1991', async (req, res) => {\n  const ok = await authUser(req.body.u1991, req.body.p1991);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "No throttling allows brute force. Secure version adds a basic per-IP rate limit."
  },
  {
    "id": 1992,
    "code": "const attempts1991 = new Map();\napp.post('/auth1991', async (req, res) => {\n  const ip = req.ip;\n  const now = Date.now();\n  const rec = attempts1991.get(ip) || [];\n  const recent = rec.filter(t => now - t < 60_000);\n  recent.push(now);\n  attempts1991.set(ip, recent);\n  if (recent.length > 10) return res.status(429).send(\"Too many attempts\");\n  const ok = await authUser(req.body.u1991, req.body.p1991);\n  res.send(ok ? \"ok\" : \"no\");\n});",
    "label": "secure",
    "vulnerability_type": "Missing Rate Limiting",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1993,
    "code": "app.post('/upload1993', (req, res) => {\n  req.files.file1993.mv(\"./uploads/\" + req.files.file1993.name);\n  res.send(\"ok\");\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "Accepting any file without checks is risky. Secure version validates MIME type and filename."
  },
  {
    "id": 1994,
    "code": "const path_up1993 = require('path');\napp.post('/upload1993', (req, res) => {\n  const f = req.files && req.files.file1993;\n  if (!f || !/^image\\/(png|jpeg)$/.test(f.mimetype)) return res.status(400).send(\"Invalid file\");\n  const name = Date.now() + \"-\" + path_up1993.basename(f.name);\n  f.mv(path_up1993.join(__dirname, \"uploads\", name));\n  res.send(\"ok\");\n});",
    "label": "secure",
    "vulnerability_type": "Insecure File Upload",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1995,
    "code": "router.get('/acct1995', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1995 WHERE id = \" + req.query.id1995)\n    .then(r => res.send(r));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Concatenating user input into SQL query introduces SQL injection. Secure version uses parameterized queries."
  },
  {
    "id": 1996,
    "code": "router.get('/acct1995', (req, res) => {\n  db.query(\"SELECT balance FROM accounts_1995 WHERE id = ?\", [req.query.id1995])\n    .then(r => res.send(r));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1997,
    "code": "app.get('/hello1997', (req, res) => {\n  res.send(\"<h2>Hello \" + (req.query.name1997 || \"\") + \"</h2>\");\n});",
    "label": "insecure",
    "vulnerability_type": "XSS",
    "explanation": "Unescaped user input is reflected in HTML. Secure version escapes special characters."
  },
  {
    "id": 1998,
    "code": "const escapeHtml1997 = s => String(s).replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#039;'}[m]));\napp.get('/hello1997', (req, res) => {\n  res.send(\"<h2>Hello \" + escapeHtml1997(req.query.name1997 || \"\") + \"</h2>\");\n});",
    "label": "secure",
    "vulnerability_type": "XSS",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 1999,
    "code": "app.get('/read1999', (req, res) => {\n  const p = \"./files/\" + req.query.file1999;\n  res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2000,
    "code": "const path1999 = require('path');\napp.get('/read1999', (req, res) => {\n  const base = path1999.join(__dirname, 'files');\n  const safe = path1999.join(base, path1999.basename(String(req.query.file1999 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2001,
    "code": "app.get('/read2001', (req, res) => {\n  const p = \"./files/\" + req.query.file2001;\n res.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2002,
    "code": "const path2002 = require('path');\\napp.get('/read2002', (req, res) => {\\n  const base = path2002.join(__dirname, 'files');\\n  const safe = path2002.join(base, path2002.basename(String(req.query.file2002 || \\\"\\\")));\\n  res.sendFile(safe);\\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2003,
    "code": "app.get('/read2003', (req, res) => {\\n  const p = \\\"./files/\\\" + req.query.file2003;\\n  res.sendFile(p);\\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2004,
    "code": "const path2004 = require('path');\napp.get('/read2004', (req, res) => {\n  const base = \npath2004.join(__dirname, 'files');\n  const safe = path2004.join(base, \npath2004.basename(String(req.query.file2004 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2005,
    "code": "app.get('/read2005', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2005;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2006,
    "code": "const path2006 = require('path');\napp.get('/read2006', (req, res) => {\n  const base = \npath2006.join(__dirname, 'files');\n  const safe = path2006.join(base, \npath2006.basename(String(req.query.file2006 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2007,
    "code": "app.get('/read2007', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2007;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2008,
    "code": "const path2008 = require('path');\napp.get('/read2008', (req, res) => {\n  const base = \npath2008.join(__dirname, 'files');\n  const safe = path2008.join(base, \npath2008.basename(String(req.query.file2008 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2009,
    "code": "app.get('/read2009', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2009;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2010,
    "code": "const path2010 = require('path');\napp.get('/read2010', (req, res) => {\n  const base = \npath2010.join(__dirname, 'files');\n  const safe = path2010.join(base, \npath2010.basename(String(req.query.file2010 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2011,
    "code": "app.get('/read2011', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2011;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2012,
    "code": "const path2012 = require('path');\napp.get('/read2012', (req, res) => {\n  const base = \npath2012.join(__dirname, 'files');\n  const safe = path2012.join(base, \npath2012.basename(String(req.query.file2012 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2013,
    "code": "app.get('/read2013', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2013;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2014,
    "code": "const path2014 = require('path');\napp.get('/read2014', (req, res) => {\n  const base = \npath2014.join(__dirname, 'files');\n  const safe = path2014.join(base, \npath2014.basename(String(req.query.file2014 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2015,
    "code": "app.get('/read2015', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2015;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2016,
    "code": "const path2016 = require('path');\napp.get('/read2016', (req, res) => {\n  const base = \npath2016.join(__dirname, 'files');\n  const safe = path2016.join(base, \npath2016.basename(String(req.query.file2016 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2017,
    "code": "app.get('/read2017', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2017;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2018,
    "code": "const path2018 = require('path');\napp.get('/read2018', (req, res) => {\n  const base = \npath2018.join(__dirname, 'files');\n  const safe = path2018.join(base, \npath2018.basename(String(req.query.file2018 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2019,
    "code": "app.get('/read2019', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2019;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2020,
    "code": "const path2020 = require('path');\napp.get('/read2020', (req, res) => {\n  const base = \npath2020.join(__dirname, 'files');\n  const safe = path2020.join(base, \npath2020.basename(String(req.query.file2020 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2021,
    "code": "app.get('/read2021', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2021;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2022,
    "code": "const path2022 = require('path');\napp.get('/read2022', (req, res) => {\n  const base = \npath2022.join(__dirname, 'files');\n  const safe = path2022.join(base, \npath2022.basename(String(req.query.file2022 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2023,
    "code": "app.get('/read2023', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2023;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2024,
    "code": "const path2024 = require('path');\napp.get('/read2024', (req, res) => {\n  const base = \npath2024.join(__dirname, 'files');\n  const safe = path2024.join(base, \npath2024.basename(String(req.query.file2024 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2025,
    "code": "app.get('/read2025', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2025;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2026,
    "code": "const path2026 = require('path');\napp.get('/read2026', (req, res) => {\n  const base = \npath2026.join(__dirname, 'files');\n  const safe = path2026.join(base, \npath2026.basename(String(req.query.file2026 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2027,
    "code": "app.get('/read2027', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2027;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2028,
    "code": "const path2028 = require('path');\napp.get('/read2028', (req, res) => {\n  const base = \npath2028.join(__dirname, 'files');\n  const safe = path2028.join(base, \npath2028.basename(String(req.query.file2028 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2029,
    "code": "app.get('/read2029', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2029;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2030,
    "code": "const path2030 = require('path');\napp.get('/read2030', (req, res) => {\n  const base = \npath2030.join(__dirname, 'files');\n  const safe = path2030.join(base, \npath2030.basename(String(req.query.file2030 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2031,
    "code": "app.get('/read2031', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2031;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2032,
    "code": "const path2032 = require('path');\napp.get('/read2032', (req, res) => {\n  const base = \npath2032.join(__dirname, 'files');\n  const safe = path2032.join(base, \npath2032.basename(String(req.query.file2032 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2033,
    "code": "app.get('/read2033', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2033;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2034,
    "code": "const path2034 = require('path');\napp.get('/read2034', (req, res) => {\n  const base = \npath2034.join(__dirname, 'files');\n  const safe = path2034.join(base, \npath2034.basename(String(req.query.file2034 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2035,
    "code": "app.get('/read2035', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2035;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2036,
    "code": "const path2036 = require('path');\napp.get('/read2036', (req, res) => {\n  const base = \npath2036.join(__dirname, 'files');\n  const safe = path2036.join(base, \npath2036.basename(String(req.query.file2036 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2037,
    "code": "app.get('/read2037', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2037;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2038,
    "code": "const path2038 = require('path');\napp.get('/read2038', (req, res) => {\n  const base = \npath2038.join(__dirname, 'files');\n  const safe = path2038.join(base, \npath2038.basename(String(req.query.file2038 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2039,
    "code": "app.get('/read2039', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2039;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2040,
    "code": "const path2040 = require('path');\napp.get('/read2040', (req, res) => {\n  const base = \npath2040.join(__dirname, 'files');\n  const safe = path2040.join(base, \npath2040.basename(String(req.query.file2040 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2041,
    "code": "app.get('/read2041', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2041;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2042,
    "code": "const path2042 = require('path');\napp.get('/read2042', (req, res) => {\n  const base = \npath2042.join(__dirname, 'files');\n  const safe = path2042.join(base, \npath2042.basename(String(req.query.file2042 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2043,
    "code": "app.get('/read2043', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2043;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2044,
    "code": "const path2044 = require('path');\napp.get('/read2044', (req, res) => {\n  const base = \npath2044.join(__dirname, 'files');\n  const safe = path2044.join(base, \npath2044.basename(String(req.query.file2044 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2045,
    "code": "app.get('/read2045', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2045;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2046,
    "code": "const path2046 = require('path');\napp.get('/read2046', (req, res) => {\n  const base = \npath2046.join(__dirname, 'files');\n  const safe = path2046.join(base, \npath2046.basename(String(req.query.file2046 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2047,
    "code": "app.get('/read2047', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2047;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2048,
    "code": "const path2048 = require('path');\napp.get('/read2048', (req, res) => {\n  const base = \npath2048.join(__dirname, 'files');\n  const safe = path2048.join(base, \npath2048.basename(String(req.query.file2048 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2049,
    "code": "app.get('/read2049', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2049;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2050,
    "code": "const path2050 = require('path');\napp.get('/read2050', (req, res) => {\n  const base = \npath2050.join(__dirname, 'files');\n  const safe = path2050.join(base, \npath2050.basename(String(req.query.file2050 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2051,
    "code": "app.get('/read2051', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2051;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2052,
    "code": "const path2052 = require('path');\napp.get('/read2052', (req, res) => {\n  const base = \npath2052.join(__dirname, 'files');\n  const safe = path2052.join(base, \npath2052.basename(String(req.query.file2052 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2053,
    "code": "app.get('/read2053', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2053;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2054,
    "code": "const path2054 = require('path');\napp.get('/read2054', (req, res) => {\n  const base = \npath2054.join(__dirname, 'files');\n  const safe = path2054.join(base, \npath2054.basename(String(req.query.file2054 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2055,
    "code": "app.get('/read2055', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2055;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2056,
    "code": "const path2056 = require('path');\napp.get('/read2056', (req, res) => {\n  const base = \npath2056.join(__dirname, 'files');\n  const safe = path2056.join(base, \npath2056.basename(String(req.query.file2056 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2057,
    "code": "app.get('/read2057', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2057;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2058,
    "code": "const path2058 = require('path');\napp.get('/read2058', (req, res) => {\n  const base = \npath2058.join(__dirname, 'files');\n  const safe = path2058.join(base, \npath2058.basename(String(req.query.file2058 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2059,
    "code": "app.get('/read2059', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2059;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2060,
    "code": "const path2060 = require('path');\napp.get('/read2060', (req, res) => {\n  const base = \npath2060.join(__dirname, 'files');\n  const safe = path2060.join(base, \npath2060.basename(String(req.query.file2060 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2061,
    "code": "app.get('/read2061', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2061;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2062,
    "code": "const path2062 = require('path');\napp.get('/read2062', (req, res) => {\n  const base = \npath2062.join(__dirname, 'files');\n  const safe = path2062.join(base, \npath2062.basename(String(req.query.file2062 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2063,
    "code": "app.get('/read2063', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2063;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2064,
    "code": "const path2064 = require('path');\napp.get('/read2064', (req, res) => {\n  const base = \npath2064.join(__dirname, 'files');\n  const safe = path2064.join(base, \npath2064.basename(String(req.query.file2064 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2065,
    "code": "app.get('/read2065', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2065;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2066,
    "code": "const path2066 = require('path');\napp.get('/read2066', (req, res) => {\n  const base = \npath2066.join(__dirname, 'files');\n  const safe = path2066.join(base, \npath2066.basename(String(req.query.file2066 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2067,
    "code": "app.get('/read2067', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2067;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2068,
    "code": "const path2068 = require('path');\napp.get('/read2068', (req, res) => {\n  const base = \npath2068.join(__dirname, 'files');\n  const safe = path2068.join(base, \npath2068.basename(String(req.query.file2068 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2069,
    "code": "app.get('/read2069', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2069;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2070,
    "code": "const path2070 = require('path');\napp.get('/read2070', (req, res) => {\n  const base = \npath2070.join(__dirname, 'files');\n  const safe = path2070.join(base, \npath2070.basename(String(req.query.file2070 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2071,
    "code": "app.get('/read2071', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2071;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2072,
    "code": "const path2072 = require('path');\napp.get('/read2072', (req, res) => {\n  const base = \npath2072.join(__dirname, 'files');\n  const safe = path2072.join(base, \npath2072.basename(String(req.query.file2072 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2073,
    "code": "app.get('/read2073', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2073;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2074,
    "code": "const path2074 = require('path');\napp.get('/read2074', (req, res) => {\n  const base = \npath2074.join(__dirname, 'files');\n  const safe = path2074.join(base, \npath2074.basename(String(req.query.file2074 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2075,
    "code": "app.get('/read2075', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2075;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2076,
    "code": "const path2076 = require('path');\napp.get('/read2076', (req, res) => {\n  const base = \npath2076.join(__dirname, 'files');\n  const safe = path2076.join(base, \npath2076.basename(String(req.query.file2076 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2077,
    "code": "app.get('/read2077', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2077;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2078,
    "code": "const path2078 = require('path');\napp.get('/read2078', (req, res) => {\n  const base = \npath2078.join(__dirname, 'files');\n  const safe = path2078.join(base, \npath2078.basename(String(req.query.file2078 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2079,
    "code": "app.get('/read2079', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2079;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2080,
    "code": "const path2080 = require('path');\napp.get('/read2080', (req, res) => {\n  const base = \npath2080.join(__dirname, 'files');\n  const safe = path2080.join(base, \npath2080.basename(String(req.query.file2080 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2081,
    "code": "app.get('/read2081', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2081;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2082,
    "code": "const path2082 = require('path');\napp.get('/read2082', (req, res) => {\n  const base = \npath2082.join(__dirname, 'files');\n  const safe = path2082.join(base, \npath2082.basename(String(req.query.file2082 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2083,
    "code": "app.get('/read2083', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2083;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2084,
    "code": "const path2084 = require('path');\napp.get('/read2084', (req, res) => {\n  const base = \npath2084.join(__dirname, 'files');\n  const safe = path2084.join(base, \npath2084.basename(String(req.query.file2084 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2085,
    "code": "app.get('/read2085', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2085;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2086,
    "code": "const path2086 = require('path');\napp.get('/read2086', (req, res) => {\n  const base = \npath2086.join(__dirname, 'files');\n  const safe = path2086.join(base, \npath2086.basename(String(req.query.file2086 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2087,
    "code": "app.get('/read2087', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2087;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2088,
    "code": "const path2088 = require('path');\napp.get('/read2088', (req, res) => {\n  const base = \npath2088.join(__dirname, 'files');\n  const safe = path2088.join(base, \npath2088.basename(String(req.query.file2088 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2089,
    "code": "app.get('/read2089', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2089;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2090,
    "code": "const path2090 = require('path');\napp.get('/read2090', (req, res) => {\n  const base = \npath2090.join(__dirname, 'files');\n  const safe = path2090.join(base, \npath2090.basename(String(req.query.file2090 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2091,
    "code": "app.get('/read2091', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2091;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2092,
    "code": "const path2092 = require('path');\napp.get('/read2092', (req, res) => {\n  const base = \npath2092.join(__dirname, 'files');\n  const safe = path2092.join(base, \npath2092.basename(String(req.query.file2092 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2093,
    "code": "app.get('/read2093', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2093;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2094,
    "code": "const path2094 = require('path');\napp.get('/read2094', (req, res) => {\n  const base = \npath2094.join(__dirname, 'files');\n  const safe = path2094.join(base, \npath2094.basename(String(req.query.file2094 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2095,
    "code": "app.get('/read2095', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2095;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2096,
    "code": "const path2096 = require('path');\napp.get('/read2096', (req, res) => {\n  const base = \npath2096.join(__dirname, 'files');\n  const safe = path2096.join(base, \npath2096.basename(String(req.query.file2096 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2097,
    "code": "app.get('/read2097', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2097;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2098,
    "code": "const path2098 = require('path');\napp.get('/read2098', (req, res) => {\n  const base = \npath2098.join(__dirname, 'files');\n  const safe = path2098.join(base, \npath2098.basename(String(req.query.file2098 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2099,
    "code": "app.get('/read2099', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2099;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2100,
    "code": "const path2100 = require('path');\napp.get('/read2100', (req, res) => {\n  const base = \npath2100.join(__dirname, 'files');\n  const safe = path2100.join(base, \npath2100.basename(String(req.query.file2100 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2101,
    "code": "app.get('/read2101', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2101;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2102,
    "code": "const path2102 = require('path');\napp.get('/read2102', (req, res) => {\n  const base = \npath2102.join(__dirname, 'files');\n  const safe = path2102.join(base, \npath2102.basename(String(req.query.file2102 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2103,
    "code": "app.get('/read2103', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2103;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2104,
    "code": "const path2104 = require('path');\napp.get('/read2104', (req, res) => {\n  const base = \npath2104.join(__dirname, 'files');\n  const safe = path2104.join(base, \npath2104.basename(String(req.query.file2104 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2105,
    "code": "app.get('/read2105', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2105;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2106,
    "code": "const path2106 = require('path');\napp.get('/read2106', (req, res) => {\n  const base = \npath2106.join(__dirname, 'files');\n  const safe = path2106.join(base, \npath2106.basename(String(req.query.file2106 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2107,
    "code": "app.get('/read2107', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2107;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2108,
    "code": "const path2108 = require('path');\napp.get('/read2108', (req, res) => {\n  const base = \npath2108.join(__dirname, 'files');\n  const safe = path2108.join(base, \npath2108.basename(String(req.query.file2108 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2109,
    "code": "app.get('/read2109', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2109;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2110,
    "code": "const path2110 = require('path');\napp.get('/read2110', (req, res) => {\n  const base = \npath2110.join(__dirname, 'files');\n  const safe = path2110.join(base, \npath2110.basename(String(req.query.file2110 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2111,
    "code": "app.get('/read2111', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2111;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2112,
    "code": "const path2112 = require('path');\napp.get('/read2112', (req, res) => {\n  const base = \npath2112.join(__dirname, 'files');\n  const safe = path2112.join(base, \npath2112.basename(String(req.query.file2112 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2113,
    "code": "app.get('/read2113', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2113;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2114,
    "code": "const path2114 = require('path');\napp.get('/read2114', (req, res) => {\n  const base = \npath2114.join(__dirname, 'files');\n  const safe = path2114.join(base, \npath2114.basename(String(req.query.file2114 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2115,
    "code": "app.get('/read2115', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2115;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2116,
    "code": "const path2116 = require('path');\napp.get('/read2116', (req, res) => {\n  const base = \npath2116.join(__dirname, 'files');\n  const safe = path2116.join(base, \npath2116.basename(String(req.query.file2116 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2117,
    "code": "app.get('/read2117', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2117;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2118,
    "code": "const path2118 = require('path');\napp.get('/read2118', (req, res) => {\n  const base = \npath2118.join(__dirname, 'files');\n  const safe = path2118.join(base, \npath2118.basename(String(req.query.file2118 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2119,
    "code": "app.get('/read2119', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2119;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2120,
    "code": "const path2120 = require('path');\napp.get('/read2120', (req, res) => {\n  const base = \npath2120.join(__dirname, 'files');\n  const safe = path2120.join(base, \npath2120.basename(String(req.query.file2120 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2121,
    "code": "app.get('/read2121', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2121;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2122,
    "code": "const path2122 = require('path');\napp.get('/read2122', (req, res) => {\n  const base = \npath2122.join(__dirname, 'files');\n  const safe = path2122.join(base, \npath2122.basename(String(req.query.file2122 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2123,
    "code": "app.get('/read2123', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2123;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2124,
    "code": "const path2124 = require('path');\napp.get('/read2124', (req, res) => {\n  const base = \npath2124.join(__dirname, 'files');\n  const safe = path2124.join(base, \npath2124.basename(String(req.query.file2124 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2125,
    "code": "app.get('/read2125', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2125;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2126,
    "code": "const path2126 = require('path');\napp.get('/read2126', (req, res) => {\n  const base = \npath2126.join(__dirname, 'files');\n  const safe = path2126.join(base, \npath2126.basename(String(req.query.file2126 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2127,
    "code": "app.get('/read2127', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2127;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2128,
    "code": "const path2128 = require('path');\napp.get('/read2128', (req, res) => {\n  const base = \npath2128.join(__dirname, 'files');\n  const safe = path2128.join(base, \npath2128.basename(String(req.query.file2128 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2129,
    "code": "app.get('/read2129', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2129;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2130,
    "code": "const path2130 = require('path');\napp.get('/read2130', (req, res) => {\n  const base = \npath2130.join(__dirname, 'files');\n  const safe = path2130.join(base, \npath2130.basename(String(req.query.file2130 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2131,
    "code": "app.get('/read2131', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2131;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2132,
    "code": "const path2132 = require('path');\napp.get('/read2132', (req, res) => {\n  const base = \npath2132.join(__dirname, 'files');\n  const safe = path2132.join(base, \npath2132.basename(String(req.query.file2132 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2133,
    "code": "app.get('/read2133', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2133;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2134,
    "code": "const path2134 = require('path');\napp.get('/read2134', (req, res) => {\n  const base = \npath2134.join(__dirname, 'files');\n  const safe = path2134.join(base, \npath2134.basename(String(req.query.file2134 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2135,
    "code": "app.get('/read2135', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2135;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2136,
    "code": "const path2136 = require('path');\napp.get('/read2136', (req, res) => {\n  const base = \npath2136.join(__dirname, 'files');\n  const safe = path2136.join(base, \npath2136.basename(String(req.query.file2136 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2137,
    "code": "app.get('/read2137', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2137;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2138,
    "code": "const path2138 = require('path');\napp.get('/read2138', (req, res) => {\n  const base = \npath2138.join(__dirname, 'files');\n  const safe = path2138.join(base, \npath2138.basename(String(req.query.file2138 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2139,
    "code": "app.get('/read2139', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2139;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2140,
    "code": "const path2140 = require('path');\napp.get('/read2140', (req, res) => {\n  const base = \npath2140.join(__dirname, 'files');\n  const safe = path2140.join(base, \npath2140.basename(String(req.query.file2140 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2141,
    "code": "app.get('/read2141', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2141;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2142,
    "code": "const path2142 = require('path');\napp.get('/read2142', (req, res) => {\n  const base = \npath2142.join(__dirname, 'files');\n  const safe = path2142.join(base, \npath2142.basename(String(req.query.file2142 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2143,
    "code": "app.get('/read2143', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2143;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2144,
    "code": "const path2144 = require('path');\napp.get('/read2144', (req, res) => {\n  const base = \npath2144.join(__dirname, 'files');\n  const safe = path2144.join(base, \npath2144.basename(String(req.query.file2144 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2145,
    "code": "app.get('/read2145', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2145;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2146,
    "code": "const path2146 = require('path');\napp.get('/read2146', (req, res) => {\n  const base = \npath2146.join(__dirname, 'files');\n  const safe = path2146.join(base, \npath2146.basename(String(req.query.file2146 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2147,
    "code": "app.get('/read2147', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2147;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2148,
    "code": "const path2148 = require('path');\napp.get('/read2148', (req, res) => {\n  const base = \npath2148.join(__dirname, 'files');\n  const safe = path2148.join(base, \npath2148.basename(String(req.query.file2148 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2149,
    "code": "app.get('/read2149', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2149;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2150,
    "code": "const path2150 = require('path');\napp.get('/read2150', (req, res) => {\n  const base = \npath2150.join(__dirname, 'files');\n  const safe = path2150.join(base, \npath2150.basename(String(req.query.file2150 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2151,
    "code": "app.get('/read2151', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2151;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2152,
    "code": "const path2152 = require('path');\napp.get('/read2152', (req, res) => {\n  const base = \npath2152.join(__dirname, 'files');\n  const safe = path2152.join(base, \npath2152.basename(String(req.query.file2152 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2153,
    "code": "app.get('/read2153', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2153;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2154,
    "code": "const path2154 = require('path');\napp.get('/read2154', (req, res) => {\n  const base = \npath2154.join(__dirname, 'files');\n  const safe = path2154.join(base, \npath2154.basename(String(req.query.file2154 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2155,
    "code": "app.get('/read2155', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2155;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2156,
    "code": "const path2156 = require('path');\napp.get('/read2156', (req, res) => {\n  const base = \npath2156.join(__dirname, 'files');\n  const safe = path2156.join(base, \npath2156.basename(String(req.query.file2156 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2157,
    "code": "app.get('/read2157', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2157;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2158,
    "code": "const path2158 = require('path');\napp.get('/read2158', (req, res) => {\n  const base = \npath2158.join(__dirname, 'files');\n  const safe = path2158.join(base, \npath2158.basename(String(req.query.file2158 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2159,
    "code": "app.get('/read2159', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2159;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2160,
    "code": "const path2160 = require('path');\napp.get('/read2160', (req, res) => {\n  const base = \npath2160.join(__dirname, 'files');\n  const safe = path2160.join(base, \npath2160.basename(String(req.query.file2160 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2161,
    "code": "app.get('/read2161', (req, res) => {\n  const p = \\\"./files/\\\" + req.query.file2161;\n  \nres.sendFile(p);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "User-controlled path may escape directory. Secure version uses basename and fixed root."
  },
  {
    "id": 2162,
    "code": "const path2162 = require('path');\napp.get('/read2162', (req, res) => {\n  const base = \npath2162.join(__dirname, 'files');\n  const safe = path2162.join(base, \npath2162.basename(String(req.query.file2162 || \"\")));\n  res.sendFile(safe);\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "This is the secure version of the previous example."
  },
  {
    "id": 2163,
    "code": "app.get('/file', (req, res) => {\n  res.sendFile('/var/data/' + req.query.name);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal",
    "explanation": "Directly concatenates user input (`req.query.name`) into a file path, allowing an attacker to access files outside the `/var/data/` directory using sequences like `../`."
  },
  {
    "id": 2164,
    "code": "app.get('/file', (req, res) => {\n  const filename = path.basename(req.query.name);\n  res.sendFile(path.join('/var/data/', filename));\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal",
    "explanation": "Uses `path.basename()` to strip any directory information from the user input and `path.join()` to safely construct the file path, preventing path traversal."
  },
  {
    "id": 2165,
    "code": "app.get('/search', (req, res) => {\n  const query = 'SELECT * FROM products WHERE name = \"' + req.query.q + '\"';\n  db.query(query).then(result => res.send(result));\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection",
    "explanation": "User input (`req.query.q`) is directly concatenated into the SQL query string, enabling SQL injection attacks."
  },
  {
    "id": 2166,
    "code": "app.get('/search', (req, res) => {\n  const query = 'SELECT * FROM products WHERE name = ?';\n  db.query(query, [req.query.q]).then(result => res.send(result));\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection",
    "explanation": "Uses a parameterized query (prepared statement) with `?` as a placeholder, separating the SQL command from the user data."
  },
  {
    "id": 2167,
    "code": "router.post('/login', async (req, res) => {\n  const token = jwt.sign({ user: req.body.user }, 'SECRET');\n  res.send(token);\n});",
    "label": "insecure",
    "vulnerability_type": "Weak Cryptography",
    "explanation": "Uses a hardcoded, non-environmentally managed secret ('SECRET') for JWT signing. This key is easily compromised."
  },
  {
    "id": 2168,
    "code": "router.post('/login', async (req, res) => {\n  const token = jwt.sign({ user: req.body.user }, process.env.JWT_SECRET, { expiresIn: '1h' });\n  res.send(token);\n});",
    "label": "secure",
    "vulnerability_type": "Weak Cryptography",
    "explanation": "Uses an environmentally stored secret (`process.env.JWT_SECRET`) and includes an expiration time, improving security."
  },
  {
    "id": 2169,
    "code": "app.post('/eval', (req, res) => {\n  const code = req.body.script;\n  eval(code);\n  res.send('Executed');\n});",
    "label": "insecure",
    "vulnerability_type": "Code Injection",
    "explanation": "The `eval()` function executes arbitrary JavaScript code passed in the request body, leading to remote code execution."
  },
  {
    "id": 2170,
    "code": "app.post('/eval', (req, res) => {\n  res.status(403).send('Code execution is forbidden.');\n});",
    "label": "secure",
    "vulnerability_type": "Code Injection",
    "explanation": "The dangerous `eval()` function has been removed entirely, or replaced with a safe, sandboxed interpreter if required."
  },
  {
    "id": 2171,
    "code": "app.get('/render', (req, res) => {\n  res.send('<h1>' + req.query.name + '</h1>');\n});",
    "label": "insecure",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "explanation": "Reflects unsanitized user input (`req.query.name`) directly into the HTML response, enabling Cross-Site Scripting (XSS)."
  },
  {
    "id": 2172,
    "code": "app.get('/render', (req, res) => {\n  const name = escapeHtml(req.query.name);\n  res.send(`<h1>${name}</h1>`);\n});",
    "label": "secure",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "explanation": "Uses an escaping function (`escapeHtml`) to convert HTML special characters in user input into their safe, harmless entities."
  },
  {
    "id": 2173,
    "code": "const username = req.body.user;\nconst userObj = JSON.parse(username);\nif(userObj.admin) { /* do something */ }",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Using `JSON.parse` with untrusted input can lead to object prototype manipulation (Prototype Pollution) or unexpected behavior if the input format changes."
  },
  {
    "id": 2174,
    "code": "const username = req.body.user;\nconst userObj = validator.safeParse(username);\nif(userObj && userObj.admin) { /* do something */ }",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization",
    "explanation": "Uses a dedicated validation or safe-parsing library to ensure the input is exactly the expected structure and type, preventing malicious object manipulation."
  },
  {
    "id": 2175,
    "code": "app.get('/api/data', checkAuth, (req, res) => {\n  if (req.user.role !== 'admin') {\n    return res.status(403).send('Forbidden');\n  }\n  db.query('SELECT * FROM sensitive_data');\n});",
    "label": "insecure",
    "vulnerability_type": "Broken Access Control",
    "explanation": "The check for the 'admin' role is applied too late or can be easily bypassed if an external endpoint exposes the data without the check."
  },
  {
    "id": 2176,
    "code": "const isAdmin = (req, res, next) => {\n  if (req.user.role === 'admin') { next(); } else { res.status(403).send('Forbidden'); }\n};\napp.get('/api/data', checkAuth, isAdmin, (req, res) => {\n  db.query('SELECT * FROM sensitive_data');\n});",
    "label": "secure",
    "vulnerability_type": "Broken Access Control",
    "explanation": "Access control logic is enforced as middleware (`isAdmin`) at the start of the request handling chain, ensuring authorization is checked before sensitive logic executes."
  },
  {
    "id": 2177,
    "code": "const username = req.body.user;\nconst password = req.body.pass;\nif (username.length > 0 && password.length > 0) { /* login */ }",
    "label": "insecure",
    "vulnerability_type": "Insufficient Validation",
    "explanation": "Only checks for non-empty input; does not validate the input against any expected format, length, or character set, making it vulnerable to various injection attacks."
  },
  {
    "id": 2178,
    "code": "const username = req.body.user;\nconst password = req.body.pass;\nconst userRegex = /^[a-zA-Z0-9_-]{3,16}$/;\nif (userRegex.test(username) && password.length >= 8) { /* login */ }",
    "label": "secure",
    "vulnerability_type": "Insufficient Validation",
    "explanation": "Applies explicit and restrictive validation (regex for username, minimum length for password) to ensure inputs conform to a safe pattern."
  },
  {
    "id": 2179,
    "code": "const file = fs.readFileSync('/tmp/user_data.txt', 'utf8');",
    "label": "insecure",
    "vulnerability_type": "Synchronous I/O in Server",
    "explanation": "Using synchronous file I/O (`fs.readFileSync`) blocks the Node.js event loop, creating a Denial of Service (DoS) vulnerability under load."
  },
  {
    "id": 2180,
    "code": "fs.readFile('/tmp/user_data.txt', 'utf8', (err, file) => {});",
    "label": "secure",
    "vulnerability_type": "Synchronous I/O in Server",
    "explanation": "Uses asynchronous file I/O (`fs.readFile` or `fs.promises.readFile`) to keep the event loop non-blocking and the server responsive."
  },
  {
    "id": 2181,
    "code": "app.use(helmet());\napp.use(cors());",
    "label": "insecure",
    "vulnerability_type": "Configuration Weakness",
    "explanation": "Missing `csrf` token middleware exposes the application to Cross-Site Request Forgery (CSRF) attacks."
  },
  {
    "id": 2182,
    "code": "app.use(helmet());\napp.use(cors());\napp.use(csurf({ cookie: true }));",
    "label": "secure",
    "vulnerability_type": "Configuration Weakness",
    "explanation": "Includes CSRF protection middleware (like `csurf`) to ensure that all state-changing requests are verified with a token."
  },
  {
    "id": 2183,
    "code": "const url = new URL(req.query.target);\nfetch(url).then(r => res.send(r));",
    "label": "insecure",
    "vulnerability_type": "Server-Side Request Forgery (SSRF)",
    "explanation": "Allows a user to specify the `target` URL for the server to fetch, potentially targeting internal network resources (SSRF)."
  },
  {
    "id": 2184,
    "code": "const url = new URL(req.query.target);\nif (!url.hostname.endsWith('trusted.com')) {\n  return res.status(403).send('Forbidden');\n}\nfetch(url).then(r => res.send(r));",
    "label": "secure",
    "vulnerability_type": "Server-Side Request Forgery (SSRF)",
    "explanation": "Validates that the provided hostname belongs to an allowed list (e.g., ends with `trusted.com`) before performing the server-side request."
  },
  {
    "id": 2185,
    "code": "let rate = 0;\nif (req.user.premium) { rate = 1000; } else { rate = 10; }\n// apply rate limit: 1000/min for premium, 10/min for others.",
    "label": "insecure",
    "vulnerability_type": "Race Condition",
    "explanation": "If multiple concurrent requests are made, the rate limit check might not be atomic, allowing a user to bypass the intended limit."
  },
  {
    "id": 2186,
    "code": "const limit = req.user.premium ? 1000 : 10;\napp.use(rateLimit({ windowMs: 60 * 1000, max: limit, keyGenerator: (req) => req.user.id }));",
    "label": "secure",
    "vulnerability_type": "Race Condition",
    "explanation": "Uses a dedicated, atomic rate-limiting middleware that properly handles concurrent requests and applies different limits based on user role."
  },
  {
    "id": 2187,
    "code": "let config = {};\nconfig.port = 8080;\nconfig.user = 'guest';",
    "label": "insecure",
    "vulnerability_type": "Information Leakage",
    "explanation": "Configuration is hardcoded in the source code, potentially including default credentials or unchangeable settings."
  },
  {
    "id": 2188,
    "code": "const config = { \n  port: process.env.PORT || 8080,\n  user: process.env.DB_USER || 'default_user'\n};",
    "label": "secure",
    "vulnerability_type": "Information Leakage",
    "explanation": "Uses environment variables (`process.env`) for sensitive configurations, ensuring they are not present in the deployed source code."
  },
  {
    "id": 2189,
    "code": "app.get('/log', (req, res) => {\n  fs.appendFileSync('app.log', 'User: ' + req.query.user + '\\n');\n  res.send('Logged');\n});",
    "label": "insecure",
    "vulnerability_type": "Log Injection",
    "explanation": "Unsanitized user input is written to a log file, which can allow an attacker to inject log forging entries or control log file content."
  },
  {
    "id": 2190,
    "code": "app.get('/log', (req, res) => {\n  const safeUser = req.query.user.replace(/\\n/g, '_');\n  fs.appendFileSync('app.log', `User: ${safeUser}\\n`);\n  res.send('Logged');\n});",
    "label": "secure",
    "vulnerability_type": "Log Injection",
    "explanation": "Sanitizes user input by removing/replacing newline characters (`\\n`) before writing to the log, preventing log forging."
  },
  {
    "id": 2191,
    "code": "const encrypted = encrypt(req.body.data, 'AES-128-CBC', 'a-fixed-key');",
    "label": "insecure",
    "vulnerability_type": "Insecure Cryptographic Storage",
    "explanation": "Uses a hardcoded, weak encryption algorithm and a fixed key and IV, making the encryption easily reversible."
  },
  {
    "id": 2192,
    "code": "const key = crypto.randomBytes(32);\nconst iv = crypto.randomBytes(16);\nconst encrypted = encrypt(req.body.data, 'AES-256-GCM', key, iv);",
    "label": "secure",
    "vulnerability_type": "Insecure Cryptographic Storage",
    "explanation": "Uses a strong, modern algorithm (`AES-256-GCM`) and generates cryptographically secure, random keys and Initialization Vectors (IVs) for each operation."
  },
  {
    "id": 2193,
    "code": "const { JSDOM } = require('jsdom');\nconst dom = new JSDOM(req.body.html);",
    "label": "insecure",
    "vulnerability_type": "XML External Entity (XXE)",
    "explanation": "Parsing user-supplied HTML/XML content with a non-secure parser (like a standard DOM parser) can allow XXE attacks or DoS."
  },
  {
    "id": 2194,
    "code": "const { JSDOM } = require('jsdom');\nconst dom = new JSDOM(req.body.html, { parsingMode: 'html' });\n// Use a dedicated HTML sanitizer library like 'dompurify' on the result.",
    "label": "secure",
    "vulnerability_type": "XML External Entity (XXE)",
    "explanation": "When parsing untrusted content, the parser should be configured to disable DTD/entity resolution, or a library should be used to sanitize the final output."
  },
  {
    "id": 2195,
    "code": "app.get('/user', (req, res) => {\n  const user = req.query.id;\n  res.set('X-User', user);\n  res.send(`User ID is ${user}`);\n});",
    "label": "insecure",
    "vulnerability_type": "Header Injection",
    "explanation": "User input is directly inserted into an HTTP header without sanitization, allowing an attacker to inject newline characters and subsequent headers (HTTP Response Splitting)."
  },
  {
    "id": 2196,
    "code": "app.get('/user', (req, res) => {\n  const user = encodeURIComponent(req.query.id);\n  res.setHeader('X-User', user);\n  res.send(`User ID is ${user}`);\n});",
    "label": "secure",
    "vulnerability_type": "Header Injection",
    "explanation": "Uses `encodeURIComponent` to escape the user input before inserting it into the header, ensuring no malicious characters can break the header structure."
  },
  {
    "id": 2197,
    "code": "if (req.query.debug === 'true') {\n  console.log('Debug enabled!');}",
    "label": "insecure",
    "vulnerability_type": "Debug Functionality Exposure",
    "explanation": "Sensitive debug features are exposed via a simple URL parameter, allowing any user to potentially trigger them without authentication."
  },
  {
    "id": 2198,
    "code": "if (process.env.NODE_ENV === 'development' && req.user.isAdmin) {\n  console.log('Admin-only debug enabled!');}",
    "label": "secure",
    "vulnerability_type": "Debug Functionality Exposure",
    "explanation": "Debug features are locked behind multiple checks: the application must be in a non-production environment AND the user must be authenticated as an administrator."
  },
  {
    "id": 2199,
    "code": "const data = new Buffer(req.body.input, 'base64');",
    "label": "insecure",
    "vulnerability_type": "Insecure API Usage",
    "explanation": "The `new Buffer()` constructor with a string argument is deprecated and unsafe due to potential initialization with malicious data, leading to information disclosure."
  },
  {
    "id": 2200,
    "code": "const data = Buffer.from(req.body.input, 'base64');",
    "label": "secure",
    "vulnerability_type": "Insecure API Usage",
    "explanation": "Uses the safer, modern `Buffer.from()` constructor which correctly handles and initializes the buffer content, preventing unintended memory exposure."
  },
{
"id": 2201,
"code": "app.get('/admin', (req, res) => {\n  if (req.session.is_admin) {\n    res.render('admin_panel');\n  } else {\n    res.redirect('/login');\n  }\n});",
"label": "insecure",
"vulnerability_type": "Session Hijacking/Fixation",
"explanation": "Does not regenerate the session ID after a successful login, making the session vulnerable to fixation or hijacking if the initial session was compromised."
},
{
"id": 2202,
"code": "app.post('/login', (req, res) => {\n  // successful authentication...\n  req.session.regenerate((err) => {\n    req.session.is_admin = true;\n    res.redirect('/admin');\n  });\n});",
"label": "secure",
"vulnerability_type": "Session Hijacking/Fixation",
"explanation": "Regenerates the session ID upon successful login, destroying any prior session ID that an attacker may have fixed or hijacked."
},
{
"id": 2203,
"code": "const userInput = req.query.data;\nconst result = 'User data: ' + userInput.toLowerCase();\nres.send(result);",
"label": "insecure",
"vulnerability_type": "Output Encoding Failure",
"explanation": "Although converting to lowercase, it does not encode the output before sending it to the client, still allowing XSS if the input is non-case-sensitive HTML/JS."
},
{
"id": 2204,
"code": "const userInput = req.query.data;\nconst result = 'User data: ' + encodeURIComponent(userInput);\nres.set('Content-Type', 'text/plain');\nres.send(result);",
"label": "secure",
"vulnerability_type": "Output Encoding Failure",
"explanation": "Uses encodeURIComponent and sets a plain text content type to ensure the browser interprets the user input as data, not executable HTML/JavaScript."
},
{
"id": 2205,
"code": "const cmd = 'echo ' + req.query.msg + ' >> log.txt';\nrequire('child_process').exec(cmd, () => {});",
"label": "insecure",
"vulnerability_type": "Command Injection",
"explanation": "Concatenates unsanitized user input (req.query.msg) into a shell command string, allowing an attacker to inject shell metacharacters (e.g., &, |, ;)."
},
{
"id": 2206,
"code": "const safeMsg = [req.query.msg];\nrequire('child_process').execFile('echo', [...safeMsg, '>> log.txt'], (err) => {});",
"label": "secure",
"vulnerability_type": "Command Injection",
"explanation": "Uses child_process.execFile which executes the command directly without invoking a shell, treating arguments as literal strings, or uses a dedicated sanitization library."
},
{
"id": 2207,
"code": "const connection = mysql.createConnection({\n  host: 'localhost', user: 'root', password: 'password123', database: 'data'\n});",
"label": "insecure",
"vulnerability_type": "Hardcoded Credentials",
"explanation": "Database credentials ('root', 'password123') are hardcoded directly into the source code, posing a severe security risk if the code is compromised."
},
{
"id": 2208,
"code": "const connection = mysql.createConnection({\n  host: process.env.DB_HOST, user: process.env.DB_USER, password: process.env.DB_PASS, database: process.env.DB_NAME\n});",
"label": "secure",
"vulnerability_type": "Hardcoded Credentials",
"explanation": "All sensitive credentials are retrieved from secure environment variables, decoupling them from the source code."
},
{
"id": 2209,
"code": "const html = <div>Welcome, ${req.query.username}</div>;\nres.send(html);",
"label": "insecure",
"vulnerability_type": "DOM-based XSS",
"explanation": "The template literal embeds user input directly into an HTML string sent to the client, leading to reflected Cross-Site Scripting (XSS)."
},
{
"id": 2210,
"code": "const username = sanitizeHtml(req.query.username);\nconst html = <div>Welcome, ${username}</div>;\nres.send(html);",
"label": "secure",
"vulnerability_type": "DOM-based XSS",
"explanation": "Uses a dedicated library (sanitizeHtml) to strip potentially dangerous elements and attributes from user input before it is rendered to the page."
},
{
  "id": 2211,
  "code": "const username = req.cookies.user;\nres.cookie('last_user', username);",
  "label": "insecure",
  "vulnerability_type": "Missing Security Headers (Cookies)",
  "explanation": "The cookie is set without the `HttpOnly` or `Secure` flags, allowing JavaScript access (XSS risk) and transmission over unencrypted HTTP."
},
{
  "id": 2212,
  "code": "const username = req.cookies.user;\nres.cookie('last_user', username, { httpOnly: true, secure: true, sameSite: 'strict' });",
  "label": "secure",
  "vulnerability_type": "Missing Security Headers (Cookies)",
  "explanation": "Sets `HttpOnly: true` (prevents client-side access), `Secure: true` (requires HTTPS), and `SameSite: 'strict'` (mitigates CSRF), enhancing cookie security."
},
{
  "id": 2213,
  "code": "app.get('/api/users/:id', async (req, res) => {\n  const user = await db.getUser(req.params.id);\n  res.json(user);\n});",
  "label": "insecure",
  "vulnerability_type": "Mass Assignment / Data Exposure",
  "explanation": "The endpoint returns the entire user object directly from the database, potentially exposing sensitive fields like `password_hash` or `ssn`."
},
{
  "id": 2214,
  "code": "app.get('/api/users/:id', async (req, res) => {\n  const user = await db.getUser(req.params.id);\n  const safeUser = { id: user.id, username: user.username, email: user.email };\n  res.json(safeUser);\n});",
  "label": "secure",
  "vulnerability_type": "Mass Assignment / Data Exposure",
  "explanation": "Explicitly filters the user object to only include non-sensitive fields before sending the response, preventing accidental data leakage."
},
{
  "id": 2215,
  "code": "app.post('/update', async (req, res) => {\n  await db.updateUser(req.session.userId, req.body);\n  res.send('Updated');\n});",
  "label": "insecure",
  "vulnerability_type": "Mass Assignment / Insecure Direct Object Reference (IDOR)",
  "explanation": "Passes the entire request body directly to the update function. If the body contains fields like `isAdmin: true`, an attacker can elevate privileges (Mass Assignment)."
},
{
  "id": 2216,
  "code": "app.post('/update', async (req, res) => {\n  const allowedFields = { email: req.body.email, name: req.body.name };\n  await db.updateUser(req.session.userId, allowedFields);\n  res.send('Updated');\n});",
  "label": "secure",
  "vulnerability_type": "Mass Assignment / Insecure Direct Object Reference (IDOR)",
  "explanation": "Uses a whitelist approach, explicitly specifying and extracting only the safe fields from the request body before passing them to the database update function."
},
{
  "id": 2217,
  "code": "const result = await db.query(`SELECT * FROM articles WHERE published = 1 ORDER BY ${req.query.sort}`);",
  "label": "insecure",
  "vulnerability_type": "SQL Injection (Order By)",
  "explanation": "The `ORDER BY` clause is constructed using unsanitized user input (`req.query.sort`), allowing an attacker to inject additional SQL commands."
},
{
  "id": 2218,
  "code": "const sortField = ['title', 'date', 'views'].includes(req.query.sort) ? req.query.sort : 'date';\nconst result = await db.query(`SELECT * FROM articles WHERE published = 1 ORDER BY ${sortField}`);",
  "label": "secure",
  "vulnerability_type": "SQL Injection (Order By)",
  "explanation": "Uses a whitelist check to ensure the sorting column name is one of the explicitly allowed, safe values, preventing SQL injection."
},
{
  "id": 2219,
  "code": "app.get('/status', (req, res) => {\n  const message = 'Service status: ' + req.query.status;\n  res.json({ message });\n});",
  "label": "insecure",
  "vulnerability_type": "Content Spoofing",
  "explanation": "Reflects user input directly back to the client, which can be used to spoof application messages or error content."
},
{
  "id": 2220,
  "code": "app.get('/status', (req, res) => {\n  const safeStatus = req.query.status.replace(/[^\\w\\s]/g, '');\n  const message = 'Service status: ' + safeStatus;\n  res.json({ message });\n});",
  "label": "secure",
  "vulnerability_type": "Content Spoofing",
  "explanation": "Uses strong input validation, stripping out all non-alphanumeric characters, to ensure the input is simply data, not script or HTML."
},
{
  "id": 2221,
  "code": "const secret = process.env.TOKEN_SECRET;\nconst token = jwt.sign(payload, secret, { algorithm: 'none' });",
  "label": "insecure",
  "vulnerability_type": "Weak Cryptography (JWT alg: None)",
  "explanation": "Specifying `algorithm: 'none'` in JWT signing allows an attacker to create a valid, unverified token, bypassing authentication."
},
{
  "id": 2222,
  "code": "const secret = process.env.TOKEN_SECRET;\nconst token = jwt.sign(payload, secret, { algorithm: 'HS256' });",
  "label": "secure",
  "vulnerability_type": "Weak Cryptography (JWT alg: None)",
  "explanation": "Uses a strong, symmetric hashing algorithm like 'HS256' and ensures the verification routine checks that the token algorithm matches the expected signature type."
},
{
  "id": 2223,
  "code": "app.post('/register', async (req, res) => {\n  const user = { username: req.body.user, pass: req.body.pass };\n  await db.insertUser(user);\n  res.send('User created.');\n});",
  "label": "insecure",
  "vulnerability_type": "Missing Password Hashing",
  "explanation": "The user object is inserted into the database without hashing the password, storing credentials in plain text."
},
{
  "id": 2224,
  "code": "app.post('/register', async (req, res) => {\n  const hashedPassword = await bcrypt.hash(req.body.pass, 10);\n  const user = { username: req.body.user, pass: hashedPassword };\n  await db.insertUser(user);\n  res.send('User created.');\n});",
  "label": "secure",
  "vulnerability_type": "Missing Password Hashing",
  "explanation": "Uses a strong, modern, work-factor based hashing algorithm (like bcrypt) with a high cost factor (10) before storing the password hash."
},
{
  "id": 2225,
  "code": "const query = JSON.parse(req.query.data);\nif (query.command === 'delete') { db.execute('DELETE FROM logs'); }",
  "label": "insecure",
  "vulnerability_type": "Logic Vulnerability / Insecure Deserialization",
  "explanation": "Allows a user to specify a command within a JSON object that is executed without any authentication or authorization checks."
},
{
  "id": 2226,
  "code": "const query = JSON.parse(req.query.data);\nif (query.command === 'delete') {\n  if (req.user.role !== 'admin') { return res.status(403).send(); }\n  db.execute('DELETE FROM logs');\n}",
  "label": "secure",
  "vulnerability_type": "Logic Vulnerability / Insecure Deserialization",
  "explanation": "Enforces a strict authorization check (`req.user.role !== 'admin'`) before allowing the execution of any destructive or sensitive command."
},
{
  "id": 2227,
  "code": "const htmlContent = '<div>' + req.query.msg + '</div>';\nconst pdf = convertToPdf(htmlContent);",
  "label": "insecure",
  "vulnerability_type": "Injection (PDF Generation)",
  "explanation": "If the `convertToPdf` function is based on a browser engine (like Puppeteer), the unsanitized HTML input can lead to XSS or local file access via injected script/iframe."
},
{
  "id": 2228,
  "code": "const safeMsg = sanitizeHtml(req.query.msg);\nconst htmlContent = '<div>' + safeMsg + '</div>';\nconst pdf = convertToPdf(htmlContent);",
  "label": "secure",
  "vulnerability_type": "Injection (PDF Generation)",
  "explanation": "Sanitizes the user input using a secure HTML sanitization library before it is processed by the PDF generation engine."
},
{
  "id": 2229,
  "code": "app.post('/upload', (req, res) => {\n  fs.writeFile(req.files.file.name, req.files.file.data, () => {});\n});",
  "label": "insecure",
  "vulnerability_type": "Unrestricted File Upload",
  "explanation": "Uses the file's original name from the request (`req.files.file.name`), allowing an attacker to upload files with dangerous extensions (e.g., `.js`, `.php`, `.exe`)."
},
{
  "id": 2230,
  "code": "app.post('/upload', (req, res) => {\n  const safeFilename = path.join('/uploads', uuid.v4() + '.png');\n  fs.writeFile(safeFilename, req.files.file.data, () => {});\n});",
  "label": "secure",
  "vulnerability_type": "Unrestricted File Upload",
  "explanation": "Generates a Universally Unique Identifier (UUID) for the filename and explicitly forces a safe, non-executable extension (e.g., `.png`), preventing execution attacks."
},
{
  "id": 2231,
  "code": "const cookieValue = req.cookies.user;\nres.send(cookieValue);",
  "label": "insecure",
  "vulnerability_type": "Sensitive Data Exposure (Unencrypted Cookies)",
  "explanation": "Retrieves and displays a cookie that may be sensitive, and does not enforce encryption (like signing) or protection flags."
},
{
  "id": 2232,
  "code": "const cookieValue = req.signedCookies.user;\nres.send(cookieValue);",
  "label": "secure",
  "vulnerability_type": "Sensitive Data Exposure (Unencrypted Cookies)",
  "explanation": "Uses signed cookies (`req.signedCookies`) which prevents cookie tampering and detects if an attacker has modified the cookie's value."
},
{
  "id": 2233,
  "code": "app.get('/redirect', (req, res) => {\n  res.redirect(req.query.url);\n});",
  "label": "insecure",
  "vulnerability_type": "Open Redirect",
  "explanation": "Redirects the user to an arbitrary URL specified in the query parameter, which can be exploited for phishing attacks."
},
{
  "id": 2234,
  "code": "app.get('/redirect', (req, res) => {\n  const url = req.query.url;\n  if (url && url.startsWith('/')) {\n    res.redirect(url);\n  } else {\n    res.redirect('/');\n  }\n});",
  "label": "secure",
  "vulnerability_type": "Open Redirect",
  "explanation": "Validates the redirection URL, ensuring it is a local path (starts with `/`) or a whitelisted external domain, preventing external phishing redirects."
},
{
  "id": 2235,
  "code": "app.use(express.urlencoded({ extended: true }));\napp.use(express.json());",
  "label": "insecure",
  "vulnerability_type": "DoS via Payload Size",
  "explanation": "The body parser limits are set to default or are missing, which could allow an attacker to send a massive JSON or URL-encoded payload to cause a Denial of Service (DoS)."
},
{
  "id": 2236,
  "code": "app.use(express.urlencoded({ extended: true, limit: '10kb' }));\napp.use(express.json({ limit: '10kb' }));",
  "label": "secure",
  "vulnerability_type": "DoS via Payload Size",
  "explanation": "Explicitly sets a small, reasonable payload size limit (e.g., `10kb`) on the body parsers to mitigate resource-exhaustion DoS attacks."
},
{
  "id": 2237,
  "code": "if (req.query.user === 'admin') {\n  console.log('Login successful');\n}",
  "label": "insecure",
  "vulnerability_type": "Weak Comparison (Type Coercion)",
  "explanation": "Using loose equality (`==` or `===` incorrectly) when comparing user-supplied data can lead to unintended matches or type coercion vulnerabilities."
},
{
  "id": 2238,
  "code": "if (String(req.query.user) === 'admin') {\n  console.log('Login successful');\n}",
  "label": "secure",
  "vulnerability_type": "Weak Comparison (Type Coercion)",
  "explanation": "Uses strict equality (`===`) and explicitly ensures data types (e.g., by coercing to `String()`) to avoid unexpected type coercion during comparison."
},
{
  "id": 2239,
  "code": "const result = 'data: ' + config.get(req.query.key);",
  "label": "insecure",
  "vulnerability_type": "Configuration Exposure",
  "explanation": "Allows a user to retrieve arbitrary configuration values via the query string, potentially exposing sensitive API keys or connection strings."
},
{
  "id": 2240,
  "code": "const key = req.query.key;\nconst safeKeys = ['app_name', 'version'];\nif (safeKeys.includes(key)) {\n  const result = 'data: ' + config.get(key);\n  res.send(result);\n} else { res.status(403).send('Forbidden key'); }",
  "label": "secure",
  "vulnerability_type": "Configuration Exposure",
  "explanation": "Uses a whitelist of explicitly safe configuration keys, denying access to any other key requested by the user."
},
{
  "id": 2241,
  "code": "const xml = req.body.data;\nconst result = parseXml(xml);",
  "label": "insecure",
  "vulnerability_type": "XML External Entity (XXE) / DoS",
  "explanation": "If the `parseXml` function uses a standard XML parser, it may be vulnerable to XXE attacks or Billion Laughs DoS attacks."
},
{
  "id": 2242,
  "code": "const xml = req.body.data;\n// Example using a secure parser that disables DTD and external entities\nconst result = secureParseXml(xml, { disableDTD: true, externalEntities: false });",
  "label": "secure",
  "vulnerability_type": "XML External Entity (XXE) / DoS",
  "explanation": "Uses a secure XML parser configured explicitly to disable Document Type Definitions (DTD) and external entity resolution, mitigating XXE and DoS risks."
},
{
  "id": 2243,
  "code": "app.get('/profile/:id', async (req, res) => {\n  const user = await db.getUser(req.params.id);\n  // Check if user is fetching their own profile\n  if (user.id !== req.session.userId) {\n    return res.status(403).send('Forbidden');\n  }\n  res.json(user);\n});",
  "label": "insecure",
  "vulnerability_type": "Insecure Direct Object Reference (IDOR) Timing",
  "explanation": "The check for user ownership is applied *after* fetching the user data from the database, which is an unnecessary overhead and potential timing side-channel."
},
{
  "id": 2244,
  "code": "app.get('/profile/:id', async (req, res) => {\n  // Direct query using session ID\n  if (req.params.id !== req.session.userId) {\n    return res.status(403).send('Forbidden');\n  }\n  const user = await db.getUser(req.session.userId);\n  res.json(user);\n});",
  "label": "secure",
  "vulnerability_type": "Insecure Direct Object Reference (IDOR) Timing",
  "explanation": "The authorization check (ID comparison) is performed immediately, and the database query only uses the trusted, authenticated session ID (`req.session.userId`)."
},
{
  "id": 2245,
  "code": "app.get('/api', (req, res) => {\n  const api_key = req.query.key;\n  // ... use api_key ...\n});",
  "label": "insecure",
  "vulnerability_type": "API Key Exposure (URL)",
  "explanation": "API keys are passed directly in the URL query string, which exposes them in server logs, browser history, and network monitoring."
},
{
  "id": 2246,
  "code": "app.get('/api', (req, res) => {\n  const api_key = req.headers['x-api-key'];\n  // ... use api_key ...\n});",
  "label": "secure",
  "vulnerability_type": "API Key Exposure (URL)",
  "explanation": "API keys are passed via HTTP headers (e.g., `X-API-Key`), which are generally not logged by default and offer better security than URL parameters."
},
{
  "id": 2247,
  "code": "const username = req.body.user;\nconst password = req.body.pass;\nif (username === 'admin' && password === 'admin123') { /* login */ }",
  "label": "insecure",
  "vulnerability_type": "Weak Default Credentials",
  "explanation": "The code uses fixed, easily guessed default administrative credentials, posing a major risk if not changed."
},
{
  "id": 2248,
  "code": "const username = req.body.user;\nconst password = req.body.pass;\nif (username === process.env.ADMIN_USER && bcrypt.compareSync(password, process.env.ADMIN_HASH)) { /* login */ }",
  "label": "secure",
  "vulnerability_type": "Weak Default Credentials",
  "explanation": "Uses environment variables for all administrative credentials and ensures the password is a cryptographically strong hash, not a plaintext string."
},
{
  "id": 2249,
  "code": "app.get('/send-email', (req, res) => {\n  smtp.send(req.query.to, 'Subject', 'Body');\n  res.send('Email sent');\n});",
  "label": "insecure",
  "vulnerability_type": "Uncontrolled Resource Consumption (Spam)",
  "explanation": "The email sending function is directly exposed via a GET endpoint without any rate-limiting, allowing an attacker to quickly spam the mail server or targeted users (DoS)."
},
{
  "id": 2250,
  "code": "app.post('/send-email', rateLimiter, (req, res) => {\n  // Requires POST, rateLimiter middleware is applied\n  smtp.send(req.body.to, 'Subject', 'Body');\n  res.send('Email sent');\n});",
  "label": "secure",
  "vulnerability_type": "Uncontrolled Resource Consumption (Spam)",
  "explanation": "Enforces rate-limiting middleware (`rateLimiter`) and requires the request method to be POST, preventing simple, repeated GET requests from exhausting resources."
},
{
  "id": 2251,
  "code": "if (req.header('X-Forwarded-For')) {\n  console.log('Client IP: ' + req.header('X-Forwarded-For'));\n}",
  "label": "insecure",
  "vulnerability_type": "Untrusted Header Use",
  "explanation": "Trusts the `X-Forwarded-For` header directly. If the application is not behind a trustworthy proxy, an attacker can spoof their IP address."
},
{
  "id": 2252,
  "code": "app.set('trust proxy', 1);\nconsole.log('Client IP: ' + req.ip);",
  "label": "secure",
  "vulnerability_type": "Untrusted Header Use",
  "explanation": "Uses the framework's trusted proxy configuration (`app.set('trust proxy', 1)`) and relies on the standardized `req.ip` property for the client IP, which is safe."
},
{
  "id": 2253,
  "code": "const userProfile = { user: req.query.name, data: JSON.parse(req.query.data) };",
  "label": "insecure",
  "vulnerability_type": "Unsafe Client-Side Storage",
  "explanation": "A pattern that often leads to storing sensitive user data (including internal structure) directly from an untrusted client, which is unsafe."
},
{
  "id": 2254,
  "code": "const userProfile = {\n  user: sanitizeInput(req.query.name),\n  data: safeParse(req.query.data, { whitelist: ['setting1', 'setting2'] })\n};",
  "label": "secure",
  "vulnerability_type": "Unsafe Client-Side Storage",
  "explanation": "All client-side data is sanitized and parsed with a whitelist, preventing injection and ensuring only known, non-sensitive data structures are accepted."
},
{
  "id": 2255,
  "code": "const result = db.execute(`CALL ${req.query.procedure}('param');`);",
  "label": "insecure",
  "vulnerability_type": "Stored Procedure Injection",
  "explanation": "Allows a user to specify the name of the database stored procedure to call, which can lead to command execution if the input is not validated."
},
{
  "id": 2256,
  "code": "const procName = ['get_data', 'update_data'].includes(req.query.procedure) ? req.query.procedure : null;\nif (procName) { db.execute(`CALL ${procName}('param');`); }",
  "label": "secure",
  "vulnerability_type": "Stored Procedure Injection",
  "explanation": "The stored procedure name is validated against a strict whitelist before it is incorporated into the execution command."
},
{
  "id": 2257,
  "code": "const data = { id: 1, name: 'Alice' };\nres.send(JSON.stringify(data, null, 4));",
  "label": "insecure",
  "vulnerability_type": "JSON Data Exposure (Pretty Print)",
  "explanation": "Formatting JSON output with pretty-printing (indentation `4`) in a production environment can inadvertently expose sensitive data structure details and increase bandwidth usage."
},
{
  "id": 2258,
  "code": "const data = { id: 1, name: 'Alice' };\nres.json(data);",
  "label": "secure",
  "vulnerability_type": "JSON Data Exposure (Pretty Print)",
  "explanation": "Uses `res.json()` which sends compact, unindented JSON output by default, reducing exposure of structure and optimizing payload size."
},
{
  "id": 2259,
  "code": "const hash = crypto.createHash('sha1').update(password).digest('hex');",
  "label": "insecure",
  "vulnerability_type": "Weak Cryptography (SHA-1)",
  "explanation": "Uses the outdated and cryptographically weak SHA-1 hashing algorithm, which is susceptible to collision attacks."
},
{
  "id": 2260,
  "code": "const hash = crypto.createHash('sha256').update(password).digest('hex');\n// Better practice is to use bcrypt/scrypt/argon2 with a salt and work factor.",
  "label": "secure",
  "vulnerability_type": "Weak Cryptography (SHA-1)",
  "explanation": "Uses the cryptographically stronger SHA-256 algorithm. For password hashing, bcrypt, scrypt, or Argon2 are superior for their built-in salt and work factor."
},
{
  "id": 2261,
  "code": "app.get('/search', (req, res) => {\n  const results = articles.filter(a => a.title.includes(req.query.q));\n  res.json(results);\n});",
  "label": "insecure",
  "vulnerability_type": "Inefficient Search / DoS",
  "explanation": "Performs a simple, case-sensitive string search (`.includes`) on a potentially large in-memory array (`articles`), which is inefficient and can be targeted for performance DoS."
},
{
  "id": 2262,
  "code": "app.get('/search', (req, res) => {\n  const normalizedQuery = req.query.q.toLowerCase();\n  const results = articles.filter(a => a.normalizedTitle.includes(normalizedQuery));\n  // Using an external search engine (Elasticsearch/Algolia) is the true secure fix.\n  res.json(results);\n});",
  "label": "secure",
  "vulnerability_type": "Inefficient Search / DoS",
  "explanation": "At a minimum, converts the query to lowercase for a better match, but a proper fix involves using indexed database queries or an optimized search service."
},
{
  "id": 2263,
  "code": "app.use(express.static('public'));",
  "label": "insecure",
  "vulnerability_type": "Static File Exposure",
  "explanation": "Serves all files within the 'public' directory, potentially exposing sensitive backup files, `.env` files, or configuration files if they are accidentally placed there."
},
{
  "id": 2264,
  "code": "const options = { dotfiles: 'ignore', index: false };\napp.use('/', express.static('public', options));",
  "label": "secure",
  "vulnerability_type": "Static File Exposure",
  "explanation": "Configures the static server to ignore dotfiles (`.env`, `.htaccess`) and disables directory listing (`index: false`), reducing file exposure."
},
{
  "id": 2265,
  "code": "const xml = `<root>${req.query.input}</root>`;\nres.set('Content-Type', 'application/xml').send(xml);",
  "label": "insecure",
  "vulnerability_type": "XML Injection / XSS",
  "explanation": "Injects unsanitized user input into an XML response. If rendered by a browser, this can lead to XSS or XML injection."
},
{
  "id": 2266,
  "code": "const safeInput = escapeXml(req.query.input);\nconst xml = `<root>${safeInput}</root>`;\nres.set('Content-Type', 'application/xml').send(xml);",
  "label": "secure",
  "vulnerability_type": "XML Injection / XSS",
  "explanation": "Uses an XML-specific encoding/escaping function (`escapeXml`) to ensure user input is treated as text data within the XML structure."
},
{
  "id": 2267,
  "code": "app.post('/profile', (req, res) => {\n  const user = req.body;\n  db.save(user);\n  res.send('Saved');\n});",
  "label": "insecure",
  "vulnerability_type": "Parameter Pollution (HPP)",
  "explanation": "Does not account for HTTP Parameter Pollution (HPP), where an attacker sends multiple values for the same key, which can be misused during data storage."
},
{
  "id": 2268,
  "code": "app.post('/profile', (req, res) => {\n  const user = { name: req.body.name, email: req.body.email }; // Explicit extraction\n  db.save(user);\n  res.send('Saved');\n});",
  "label": "secure",
  "vulnerability_type": "Parameter Pollution (HPP)",
  "explanation": "Explicitly extracts desired parameters instead of blindly copying the request body, which mitigates HPP by only using the first value received for a given parameter."
},
{
  "id": 2269,
  "code": "app.get('/data', (req, res) => {\n  res.set('Cache-Control', 'no-cache');\n  res.send(sensitiveData);\n});",
  "label": "insecure",
  "vulnerability_type": "Insecure Caching",
  "explanation": "Sets `Cache-Control: no-cache`, which forces revalidation but still allows the browser to store sensitive data in the cache."
},
{
  "id": 2270,
  "code": "app.get('/data', (req, res) => {\n  res.set('Cache-Control', 'no-store, no-cache, must-revalidate, private');\n  res.send(sensitiveData);\n});",
  "label": "secure",
  "vulnerability_type": "Insecure Caching",
  "explanation": "Sets `Cache-Control: no-store` to explicitly forbid any caching of the sensitive response by the browser or intermediate proxies."
},
{
  "id": 2271,
  "code": "const data = req.body.input;\nconst result = someFunction(data);\nres.send(result);",
  "label": "insecure",
  "vulnerability_type": "Business Logic Abuse (General)",
  "explanation": "A general logic flow that processes user input without sufficient contextual validation, potentially allowing abuse of business rules (e.g., unauthorized price changes)."
},
{
  "id": 2272,
  "code": "const data = validateSchema(req.body.input);\nif (!data) { return res.status(400).send('Invalid input'); }\nconst result = safeFunction(data);\nres.send(result);",
  "label": "secure",
  "vulnerability_type": "Business Logic Abuse (General)",
  "explanation": "Applies schema validation to the request body and enforces strict input constraints before processing, ensuring data adheres to the expected business rules."
},
{
  "id": 2273,
  "code": "db.execute(`UPDATE users SET status = 1 WHERE user_id = ${req.query.id}`);",
  "label": "insecure",
  "vulnerability_type": "SQL Injection (Numeric ID)",
  "explanation": "Treats the numeric user ID as a simple string concatenation, which is vulnerable to SQL injection if the input is not strictly validated as an integer."
},
{
  "id": 2274,
  "code": "const userId = parseInt(req.query.id, 10);\nif (isNaN(userId)) { return res.status(400).send(); }\ndb.execute(`UPDATE users SET status = 1 WHERE user_id = ?`, [userId]);",
  "label": "secure",
  "vulnerability_type": "SQL Injection (Numeric ID)",
  "explanation": "Uses `parseInt` to ensure the input is a number and utilizes parameterized queries, eliminating the SQL injection risk."
},
{
  "id": 2275,
  "code": "const input = req.query.name;\nconst result = process.env[input];",
  "label": "insecure",
  "vulnerability_type": "Environment Variable Disclosure",
  "explanation": "Allows a user to specify the key to look up in `process.env`, potentially revealing sensitive environment variables (e.g., database credentials)."
},
{
  "id": 2276,
  "code": "const input = req.query.name;\nif (['APP_VERSION', 'SERVICE_NAME'].includes(input)) {\n  const result = process.env[input];\n  res.send(result);\n} else { res.status(403).send('Forbidden key'); }",
  "label": "secure",
  "vulnerability_type": "Environment Variable Disclosure",
  "explanation": "Restricts environment variable access to a strict whitelist of non-sensitive keys, preventing arbitrary key lookup."
},
{
  "id": 2277,
  "code": "app.get('/debug', (req, res) => {\n  if (req.query.pass === '1234') {\n    res.send(process.version);\n  }\n});",
  "label": "insecure",
  "vulnerability_type": "Weak Authentication (Debug Endpoint)",
  "explanation": "A debug endpoint is protected only by a weak, hardcoded, URL-based password, making it easily accessible to attackers."
},
{
  "id": 2278,
  "code": "app.get('/debug', authMiddleware, (req, res) => {\n  if (req.user.role === 'support') {\n    res.send(process.version);\n  }\n});",
  "label": "secure",
  "vulnerability_type": "Weak Authentication (Debug Endpoint)",
  "explanation": "The debug endpoint is protected by a strong authentication middleware and an authorization check against a specific trusted user role."
},
{
  "id": 2279,
  "code": "if (req.body.data) {\n  const result = JSON.parse(req.body.data);\n  // ... use result ...\n}",
  "label": "insecure",
  "vulnerability_type": "Prototype Pollution via JSON Parsing",
  "explanation": "Certain JSON parsing libraries can be vulnerable to Prototype Pollution if they allow keys like `__proto__` or `constructor.prototype`."
},
{
  "id": 2280,
  "code": "if (req.body.data) {\n  const result = safeJsonParse(req.body.data);\n  // Use a library that sanitizes JSON or explicitly checks for dangerous keys.\n  // ... use result ...\n}",
  "label": "secure",
  "vulnerability_type": "Prototype Pollution via JSON Parsing",
  "explanation": "Uses a known-safe JSON parsing utility or explicitly checks and rejects keys related to prototype manipulation to prevent pollution."
},
{
  "id": 2281,
  "code": "app.get('/api', (req, res) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.send('ok');\n});",
  "label": "insecure",
  "vulnerability_type": "Missing X-Frame-Options",
  "explanation": "Missing the `X-Frame-Options` header exposes the page to clickjacking attacks where it can be embedded in a malicious iframe."
},
{
  "id": 2282,
  "code": "app.get('/api', (req, res) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-Frame-Options', 'DENY');\n  res.send('ok');\n});",
  "label": "secure",
  "vulnerability_type": "Missing X-Frame-Options",
  "explanation": "Sets `X-Frame-Options: DENY` (or `SAMEORIGIN`) to prevent the page from being rendered in an iframe, mitigating clickjacking."
},
{
  "id": 2283,
  "code": "const username = req.body.user;\nconst password = req.body.pass;\nif (db.verify(username, password)) { req.session.user = username; }",
  "label": "insecure",
  "vulnerability_type": "Session Management (Unprotected Session)",
  "explanation": "Stores the username directly in the session object without rotating the session ID, making the session susceptible to theft/fixation."
},
{
  "id": 2284,
  "code": "const username = req.body.user;\nconst password = req.body.pass;\nif (db.verify(username, password)) {\n  req.session.regenerate(() => { req.session.user = username; });\n}",
  "label": "secure",
  "vulnerability_type": "Session Management (Unprotected Session)",
  "explanation": "Regenerates the session ID immediately after a successful authentication, ensuring a new, clean session is used."
},
{
  "id": 2285,
  "code": "app.get('/data', (req, res) => {\n  const query = 'SELECT ' + req.query.fields + ' FROM products';\n  db.query(query).then(result => res.json(result));\n});",
  "label": "insecure",
  "vulnerability_type": "SQL Injection (Select Field)",
  "explanation": "Allows the user to specify the column names in the `SELECT` clause, vulnerable to injection if the user inserts malicious SQL functions or commands."
},
{
  "id": 2286,
  "code": "app.get('/data', (req, res) => {\n  const allowedFields = req.query.fields.split(',').filter(f => ['name', 'price'].includes(f));\n  if (allowedFields.length === 0) { return res.status(400).send(); }\n  const query = 'SELECT ' + allowedFields.join(',') + ' FROM products';\n  db.query(query).then(result => res.json(result));\n});",
  "label": "secure",
  "vulnerability_type": "SQL Injection (Select Field)",
  "explanation": "Implements a robust whitelist check on the requested fields, ensuring only safe column names are ever used in the query."
},
{
  "id": 2287,
  "code": "const url = 'http://' + req.query.host + '/api/data';\nconst response = await fetch(url);",
  "label": "insecure",
  "vulnerability_type": "Server-Side Request Forgery (SSRF) via Host",
  "explanation": "Concatenates user input directly into the hostname of a server-side request, allowing the attacker to target internal network services."
},
{
  "id": 2288,
  "code": "const host = req.query.host;\nif (!host.endsWith('external-api.com')) {\n  return res.status(403).send('Invalid host');\n}\nconst url = 'http://' + host + '/api/data';\nconst response = await fetch(url);",
  "label": "secure",
  "vulnerability_type": "Server-Side Request Forgery (SSRF) via Host",
  "explanation": "Strictly validates the hostname against a whitelist of external hosts that the server is allowed to connect to, preventing SSRF to internal addresses."
},
{
  "id": 2289,
  "code": "const { performance } = require('perf_hooks');\nconst start = performance.now();\n// sensitive operation...\nconst end = performance.now();\nconsole.log(`Time: ${end - start}`);",
  "label": "insecure",
  "vulnerability_type": "Timing Attack (Exposure)",
  "explanation": "The code measures the time taken for a sensitive operation (e.g., password comparison) and leaks this precise timing information, enabling timing attacks."
},
{
  "id": 2290,
  "code": "const secureCompare = (a, b) => {\n  let diff = a.length ^ b.length;\n  for (let i = 0; i < a.length && i < b.length; i++) {\n    diff |= a.charCodeAt(i) ^ b.charCodeAt(i);\n  }\n  return diff === 0;\n};\n// Use a constant-time comparison for sensitive checks.",
  "label": "secure",
  "vulnerability_type": "Timing Attack (Exposure)",
  "explanation": "Uses a constant-time string comparison function (`secureCompare`) to ensure the comparison time does not depend on the difference between the strings, mitigating timing attacks."
},
{
  "id": 2291,
  "code": "const payload = req.body.payload;\nconst result = JSON.parse(payload);",
  "label": "insecure",
  "vulnerability_type": "DoS via Input Structure",
  "explanation": "Parsing deeply nested JSON structures from untrusted input can exhaust memory and CPU resources, leading to a DoS attack."
},
{
  "id": 2292,
  "code": "const payload = req.body.payload;\n// Use a parser with depth limits or a schema validator\nconst result = limitedJsonParse(payload, { maxDepth: 5 });",
  "label": "secure",
  "vulnerability_type": "DoS via Input Structure",
  "explanation": "Uses a parsing mechanism that enforces a maximum depth limit (`maxDepth: 5`) on the JSON structure, preventing deep nesting that can lead to DoS."
},
{
  "id": 2293,
  "code": "app.get('/search', (req, res) => {\n  res.send('<input value=\"' + req.query.term + '\">');\n});",
  "label": "insecure",
  "vulnerability_type": "XSS (HTML Attribute)",
  "explanation": "Injects unsanitized user input into an HTML attribute (`value`), allowing an attacker to escape the attribute and inject JavaScript using quotes."
},
{
  "id": 2294,
  "code": "app.get('/search', (req, res) => {\n  const term = encodeHtmlAttribute(req.query.term);\n  res.send(`<input value=\"${term}\">`);\n});",
  "label": "secure",
  "vulnerability_type": "XSS (HTML Attribute)",
  "explanation": "Uses a dedicated function (`encodeHtmlAttribute`) to escape characters like quotes, ensuring the input remains safely contained within the HTML attribute."
},
{
  "id": 2295,
  "code": "const userAgent = req.headers['user-agent'];\nres.send('Your UA: ' + userAgent);",
  "label": "insecure",
  "vulnerability_type": "Header Reflection",
  "explanation": "Reflects an HTTP header (User-Agent) back to the client without sanitization, which can be used to inject XSS payloads."
},
{
  "id": 2296,
  "code": "const userAgent = encodeURIComponent(req.headers['user-agent']);\nres.send('Your UA: ' + userAgent);",
  "label": "secure",
  "vulnerability_type": "Header Reflection",
  "explanation": "Uses `encodeURIComponent` to sanitize the reflected header content, preventing any embedded HTML or script from executing."
},
{
  "id": 2297,
  "code": "const file = req.query.file;\nfs.unlink(file, () => {});",
  "label": "insecure",
  "vulnerability_type": "Insecure File Operation",
  "explanation": "Allows a user to specify any filename to be deleted using `fs.unlink`, enabling an attacker to delete critical application files or configuration."
},
{
  "id": 2298,
  "code": "const file = path.join('/temp/user-files', path.basename(req.query.file));\nfs.unlink(file, () => {});",
  "label": "secure",
  "vulnerability_type": "Insecure File Operation",
  "explanation": "Restricts the file path to a specific, non-critical directory (`/temp/user-files`) and uses `path.basename` to eliminate path traversal, ensuring only intended files are deleted."
},
{
  "id": 2299,
  "code": "const url = 'http://' + req.headers.host + '/login';\nres.redirect(url);",
  "label": "insecure",
  "vulnerability_type": "Host Header Injection",
  "explanation": "Uses the unvalidated `Host` header to construct an absolute URL for redirection, which can be spoofed by an attacker to create a phishing link."
},
{
  "id": 2300,
  "code": "const url = process.env.APP_URL + '/login';\nres.redirect(url);",
  "label": "secure",
  "vulnerability_type": "Host Header Injection",
  "explanation": "Uses a trusted, hardcoded or environment-configured value (`process.env.APP_URL`) to build the absolute URL, ignoring the potentially spoofed `Host` header."
},
  {
    "id": 2301,
    "code": "app.get('/data/:id', async (req, res) => {\n  const id = req.params.id;\n  const result = await db.query(`SELECT data FROM records WHERE id = ${id}`);\n  res.json(result);\n});",
    "label": "insecure",
    "vulnerability_type": "SQL Injection (Unsanitized Param)",
    "explanation": "Directly injecting a path parameter (`req.params.id`) into the SQL query without using prepared statements creates a classic SQL Injection vulnerability."
  },
  {
    "id": 2302,
    "code": "app.get('/data/:id', async (req, res) => {\n  const id = parseInt(req.params.id, 10);\n  if (isNaN(id)) return res.status(400).send();\n  const result = await db.query(`SELECT data FROM records WHERE id = ?`, [id]);\n  res.json(result);\n});",
    "label": "secure",
    "vulnerability_type": "SQL Injection (Unsanitized Param)",
    "explanation": "Enforces type validation (`parseInt`) and uses a **parameterized query** (`?`, `[id]`) to safely pass the value to the database, preventing injection."
  },
  {
    "id": 2303,
    "code": "if (req.query.isAdmin) { req.session.role = 'admin'; }",
    "label": "insecure",
    "vulnerability_type": "Authorization Bypass (Client Control)",
    "explanation": "Allows a client to directly control their session role via a query parameter, completely bypassing server-side authorization checks."
  },
  {
    "id": 2304,
    "code": "if (req.session.isLoggedIn && db.checkAdmin(req.session.userId)) {\n  req.session.role = 'admin';\n}",
    "label": "secure",
    "vulnerability_type": "Authorization Bypass (Client Control)",
    "explanation": "The session role is determined exclusively by server-side logic and database lookups, ignoring any client-supplied role parameters."
  },
  {
    "id": 2305,
    "code": "const tempFile = req.query.filename;\nfs.writeFileSync(tempFile, req.body.data);",
    "label": "insecure",
    "vulnerability_type": "Path Traversal (Write)",
    "explanation": "Allows a user to specify the full filename and path for a write operation, enabling path traversal to overwrite system files or write to sensitive directories."
  },
  {
    "id": 2306,
    "code": "const tempDir = path.join(os.tmpdir(), req.session.userId);\nfs.mkdirSync(tempDir, { recursive: true });\nconst tempFile = path.join(tempDir, path.basename(req.query.filename));\nfs.writeFileSync(tempFile, req.body.data);",
    "label": "secure",
    "vulnerability_type": "Path Traversal (Write)",
    "explanation": "Restricts file writes to a user-specific temporary directory and uses `path.basename` to sanitize the filename, ensuring safe and contained operations."
  },
  {
    "id": 2307,
    "code": "const response = await axios.get('http://' + req.query.domain + '/status');",
    "label": "insecure",
    "vulnerability_type": "Server-Side Request Forgery (SSRF) - Unvalidated Host",
    "explanation": "Concatenates unvalidated user input (`req.query.domain`) into a request URL, allowing the server to be tricked into connecting to internal resources (SSRF)."
  },
  {
    "id": 2308,
    "code": "const domain = req.query.domain;\nconst safeDomain = domain.match(/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$/);\nif (!safeDomain) return res.status(400).send();\nconst response = await axios.get(`http://${safeDomain[0]}/status`);",
    "label": "secure",
    "vulnerability_type": "Server-Side Request Forgery (SSRF) - Unvalidated Host",
    "explanation": "Uses a regular expression to strictly validate the user-supplied domain against known safe characters and structures, mitigating SSRF."
  },
  {
    "id": 2309,
    "code": "const token = req.headers.authorization.split(' ')[1];\nconst user = jwt.verify(token, 'a-guessable-secret');",
    "label": "insecure",
    "vulnerability_type": "Weak Cryptography (Guessable Secret)",
    "explanation": "Uses a hardcoded, extremely weak secret (`'a-guessable-secret'`) for JWT verification, allowing attackers to forge tokens easily."
  },
  {
    "id": 2310,
    "code": "const token = req.headers.authorization.split(' ')[1];\nconst secret = Buffer.from(process.env.JWT_SECRET, 'base64');\nconst user = jwt.verify(token, secret);",
    "label": "secure",
    "vulnerability_type": "Weak Cryptography (Guessable Secret)",
    "explanation": "Uses a large, cryptographically secure secret loaded from a secure environment variable, significantly increasing the difficulty of token forgery."
  },
  {
    "id": 2311,
    "code": "app.post('/register', async (req, res) => {\n  const user = req.body;\n  await User.create(user);\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Mass Assignment (ORMs)",
    "explanation": "Passing the entire request body (`req.body`) directly to an ORM's create function allows an attacker to set unauthorized fields (e.g., `role: 'admin'`)."
  },
  {
    "id": 2312,
    "code": "app.post('/register', async (req, res) => {\n  const { username, email, password } = req.body;\n  const hashedPassword = await bcrypt.hash(password, 10);\n  await User.create({ username, email, password: hashedPassword });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Mass Assignment (ORMs)",
    "explanation": "Uses destructuring to explicitly whitelist only the expected, non-sensitive fields from `req.body` and hashes the password before creation."
  },
  {
    "id": 2313,
    "code": "app.get('/download', (req, res) => {\n  res.download('/data/' + req.query.file);\n});",
    "label": "insecure",
    "vulnerability_type": "Path Traversal (Download)",
    "explanation": "Concatenates user input (`req.query.file`) to the file path, allowing attackers to download arbitrary files using `../` sequences."
  },
  {
    "id": 2314,
    "code": "app.get('/download', (req, res) => {\n  const filename = path.normalize(req.query.file).replace(/^(\\.\\.\\/)+/, '');\n  res.download(path.join('/data/', filename));\n});",
    "label": "secure",
    "vulnerability_type": "Path Traversal (Download)",
    "explanation": "Uses `path.normalize` and a regex to strip all parent directory traversal sequences (`../`), then safely joins the path to a fixed base directory."
  },
  {
    "id": 2315,
    "code": "app.get('/info', (req, res) => {\n  if (req.headers.origin) {\n    res.set('Access-Control-Allow-Origin', req.headers.origin);\n  }\n  res.send('Data');\n});",
    "label": "insecure",
    "vulnerability_type": "CORS Misconfiguration (Reflected Origin)",
    "explanation": "Reflects an arbitrary client-supplied `Origin` header back into the `Access-Control-Allow-Origin` header, allowing any domain to bypass SOP (Same-Origin Policy)."
  },
  {
    "id": 2316,
    "code": "const allowedOrigins = ['https://trusted.com', 'https://safe.net'];\napp.get('/info', (req, res) => {\n  const origin = req.headers.origin;\n  if (allowedOrigins.includes(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n  }\n  res.send('Data');\n});",
    "label": "secure",
    "vulnerability_type": "CORS Misconfiguration (Reflected Origin)",
    "explanation": "Uses a strict whitelist (`allowedOrigins`) to validate the `Origin` header before reflecting it, ensuring only trusted domains can access the resource."
  },
  {
    "id": 2317,
    "code": "const userProfile = { name: req.body.name };\nconst serialized = JSON.stringify(userProfile);",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization (General)",
    "explanation": "While JSON is generally safer than other formats, this pattern sets up the data to be vulnerable if an unsafe parser or format (like YAML or a binary format) were used instead."
  },
  {
    "id": 2318,
    "code": "const userProfile = { name: validator.escape(req.body.name) };\nconst serialized = JSON.stringify(userProfile);",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization (General)",
    "explanation": "Input is sanitized even for safe serialization formats to prevent injection attacks if the serialized data is ever reflected or used unsafely later."
  },
  {
    "id": 2319,
    "code": "app.get('/api/v2', (req, res) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-XSS-Protection', '0');\n  res.send('API');\n});",
    "label": "insecure",
    "vulnerability_type": "Missing Security Header (X-XSS-Protection)",
    "explanation": "Disabling the browser's built-in XSS protection (`X-XSS-Protection: 0`) intentionally weakens client-side defense layers."
  },
  {
    "id": 2320,
    "code": "app.get('/api/v2', (req, res) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-XSS-Protection', '1; mode=block');\n  res.send('API');\n});",
    "label": "secure",
    "vulnerability_type": "Missing Security Header (X-XSS-Protection)",
    "explanation": "Sets `X-XSS-Protection: 1; mode=block` to explicitly enable the browser's XSS filter and block the page render if an attack is detected."
  },
  {
    "id": 2321,
    "code": "const userToken = req.query.token;\nconst query = `DELETE FROM tokens WHERE token = '${userToken}'`;\ndb.query(query);",
    "label": "insecure",
    "vulnerability_type": "SQL Injection (Delete)",
    "explanation": "The user token is directly injected into the DELETE statement, allowing SQL injection to delete unauthorized records (e.g., `' OR '1'='1`)."
  },
  {
    "id": 2322,
    "code": "const userToken = req.query.token;\ndb.query(`DELETE FROM tokens WHERE token = ?`, [userToken]);",
    "label": "secure",
    "vulnerability_type": "SQL Injection (Delete)",
    "explanation": "Uses a parameterized query for the DELETE statement, ensuring the token is treated as a literal string value and not as executable SQL code."
  },
  {
    "id": 2323,
    "code": "const data = req.body.data;\nconst result = btoa(data); // Base64 encoding",
    "label": "insecure",
    "vulnerability_type": "Weak Security Transformation (Encoding)",
    "explanation": "Using client-side methods like `btoa()` for server-side encoding/decoding is generally weak, especially if the data needs cryptographic integrity or is mistaken for encryption."
  },
  {
    "id": 2324,
    "code": "const data = req.body.data;\nconst result = Buffer.from(data).toString('base64');",
    "label": "secure",
    "vulnerability_type": "Weak Security Transformation (Encoding)",
    "explanation": "Uses the native Node.js `Buffer.from()` utility for Base64 encoding/decoding, which is correct for server-side operations and avoids confusion with client-side functions."
  },
  {
    "id": 2325,
    "code": "app.get('/profile', (req, res) => {\n  const user = db.getById(req.session.userId);\n  res.send(user.profile);\n});",
    "label": "insecure",
    "vulnerability_type": "Insufficient Auditing",
    "explanation": "This sensitive access endpoint lacks proper auditing/logging, meaning unauthorized access or breaches would leave no forensic trail."
  },
  {
    "id": 2326,
    "code": "app.get('/profile', (req, res) => {\n  logger.info(`User ${req.session.userId} accessed profile.`);\n  const user = db.getById(req.session.userId);\n  res.send(user.profile);\n});",
    "label": "secure",
    "vulnerability_type": "Insufficient Auditing",
    "explanation": "Integrates an explicit logging statement (auditing) for sensitive actions, recording the user ID and action for forensic analysis."
  },
  {
    "id": 2327,
    "code": "if (req.headers['x-api-key'] === 'TEST-KEY') { /* allow access */ }",
    "label": "insecure",
    "vulnerability_type": "Weak API Key Management",
    "explanation": "Uses a weak, fixed, hardcoded API key (`TEST-KEY`) for authentication, which is easily discovered and compromised."
  },
  {
    "id": 2328,
    "code": "const validKey = crypto.timingSafeEqual(Buffer.from(req.headers['x-api-key']), Buffer.from(process.env.API_KEY));\nif (validKey) { /* allow access */ }",
    "label": "secure",
    "vulnerability_type": "Weak API Key Management",
    "explanation": "Uses a secure, constant-time comparison (`crypto.timingSafeEqual`) against a long, secure API key stored in an environment variable, mitigating timing attacks."
  },
  {
    "id": 2329,
    "code": "const cmd = 'ping ' + req.query.ip;\nrequire('child_process').exec(cmd, (err, stdout) => res.send(stdout));",
    "label": "insecure",
    "vulnerability_type": "Command Injection (Shell)",
    "explanation": "Unsanitized user input (`req.query.ip`) is passed to `exec`, which spawns a shell, allowing the attacker to inject arbitrary shell commands."
  },
  {
    "id": 2330,
    "code": "const ip = req.query.ip;\n// Basic validation: ensure it looks like an IP address\nif (!/^[0-9.]*$/.test(ip)) return res.status(400).send();\nconst cmd = 'ping ' + ip;\nrequire('child_process').exec(cmd, (err, stdout) => res.send(stdout));",
    "label": "secure",
    "vulnerability_type": "Command Injection (Shell)",
    "explanation": "Applies a strict regular expression validation to ensure the input contains only numeric digits and dots, preventing shell metacharacters."
  },
  {
    "id": 2331,
    "code": "const url = new URL(req.query.link);\nres.redirect(url.toString());",
    "label": "insecure",
    "vulnerability_type": "Open Redirect (URL Object)",
    "explanation": "Though using the `URL` object helps, directly redirecting to a user-supplied URL object is still vulnerable to phishing (Open Redirect)."
  },
  {
    "id": 2332,
    "code": "const link = req.query.link;\nif (link && (link.startsWith('/') || link.startsWith(process.env.APP_DOMAIN))) {\n  res.redirect(link);\n} else {\n  res.redirect('/');\n}",
    "label": "secure",
    "vulnerability_type": "Open Redirect (URL Object)",
    "explanation": "Enforces a strict check: the link must be either an internal relative path (`/`) or match a whitelisted base domain, preventing arbitrary external redirects."
  },
  {
    "id": 2333,
    "code": "app.get('/metrics', (req, res) => {\n  res.send(process.version + ' ' + process.pid);\n});",
    "label": "insecure",
    "vulnerability_type": "Information Leakage (Server Details)",
    "explanation": "Exposes technical details like the Node.js version and the server's Process ID (PID), which can aid an attacker in targeting specific vulnerabilities."
  },
  {
    "id": 2334,
    "code": "app.get('/metrics', (req, res) => {\n  res.send('Server Status: OK');\n});",
    "label": "secure",
    "vulnerability_type": "Information Leakage (Server Details)",
    "explanation": "The endpoint is stripped of all technical information and returns only a generic status message."
  },
  {
    "id": 2335,
    "code": "const userAgent = req.headers['user-agent'];\nconst logEntry = { ua: userAgent };\nlogger.info(JSON.stringify(logEntry));",
    "label": "insecure",
    "vulnerability_type": "Log Injection (JSON)",
    "explanation": "Injecting unsanitized header content into a JSON log file can break the JSON structure, allowing an attacker to inject false log entries."
  },
  {
    "id": 2336,
    "code": "const userAgent = req.headers['user-agent'];\nconst logEntry = { ua: userAgent.replace(/[\\r\\n]/g, '_') };\nlogger.info(JSON.stringify(logEntry));",
    "label": "secure",
    "vulnerability_type": "Log Injection (JSON)",
    "explanation": "Sanitizes the user agent string by removing or replacing carriage returns and newlines, preserving the integrity of the JSON log structure."
  },
  {
    "id": 2337,
    "code": "db.query(`UPDATE users SET name = '${req.body.name}' WHERE id = ${req.session.userId}`);",
    "label": "insecure",
    "vulnerability_type": "SQL Injection (Authenticated)",
    "explanation": "Although authenticated (`req.session.userId` is used), the user's name input (`req.body.name`) is still directly concatenated, leading to SQL injection."
  },
  {
    "id": 2338,
    "code": "db.query(`UPDATE users SET name = ? WHERE id = ?`, [req.body.name, req.session.userId]);",
    "label": "secure",
    "vulnerability_type": "SQL Injection (Authenticated)",
    "explanation": "Both user input (`req.body.name`) and the session ID are passed as parameters to the prepared statement, eliminating the injection risk."
  },
  {
    "id": 2339,
    "code": "app.use((req, res, next) => {\n  res.set('X-Powered-By', 'NodeJS');\n  next();\n});",
    "label": "insecure",
    "vulnerability_type": "Information Leakage (X-Powered-By)",
    "explanation": "Explicitly sets a header that reveals the underlying server technology, which can be used by attackers to target known vulnerabilities in Node.js."
  },
  {
    "id": 2340,
    "code": "app.disable('x-powered-by');\napp.use((req, res, next) => {\n  // No X-Powered-By header is sent\n  next();\n});",
    "label": "secure",
    "vulnerability_type": "Information Leakage (X-Powered-By)",
    "explanation": "Disables the automatic `X-Powered-By` header (a default feature in frameworks like Express), minimizing server technology disclosure."
  },
  {
    "id": 2341,
    "code": "app.get('/render', (req, res) => {\n  res.render(req.query.page);\n});",
    "label": "insecure",
    "vulnerability_type": "Server-Side Template Injection (SSTI)",
    "explanation": "Allows a user to specify the name of the template file to render, potentially leading to directory traversal or unauthorized template access."
  },
  {
    "id": 2342,
    "code": "app.get('/render', (req, res) => {\n  const page = ['home', 'about', 'contact'].includes(req.query.page) ? req.query.page : 'home';\n  res.render(page);\n});",
    "label": "secure",
    "vulnerability_type": "Server-Side Template Injection (SSTI)",
    "explanation": "Uses a strict whitelist to validate the template name, ensuring the user can only request pre-approved, safe templates."
  },
  {
    "id": 2343,
    "code": "const data = req.body.json;\nconst obj = JSON.parse(data);",
    "label": "insecure",
    "vulnerability_type": "DoS via Input Complexity",
    "explanation": "Allows high-complexity JSON input (deeply nested or highly repetitive keys) that can slow down parsing and lead to a CPU-based Denial of Service."
  },
  {
    "id": 2344,
    "code": "const data = req.body.json;\n// Use a library that enforces complexity limits during parsing (e.g., node-json-limit)\nconst obj = limitedJsonParse(data);",
    "label": "secure",
    "vulnerability_type": "DoS via Input Complexity",
    "explanation": "Uses a dedicated library or mechanism to enforce limits on JSON parsing complexity (nesting depth, key length, etc.), mitigating DoS."
  },
  {
    "id": 2345,
    "code": "app.post('/api/profile', (req, res) => {\n  if (req.user.id !== req.body.id) { return res.status(403).send(); }\n  db.update(req.body);\n});",
    "label": "insecure",
    "vulnerability_type": "Mass Assignment (Authenticated IDOR)",
    "explanation": "The authorization check (`req.user.id !== req.body.id`) is correct, but passing the entire `req.body` to `db.update` still allows Mass Assignment of unauthorized fields."
  },
  {
    "id": 2346,
    "code": "app.post('/api/profile', (req, res) => {\n  if (req.user.id !== req.body.id) { return res.status(403).send(); }\n  const { email, phone } = req.body;\n  db.update({ id: req.user.id, email, phone });\n});",
    "label": "secure",
    "vulnerability_type": "Mass Assignment (Authenticated IDOR)",
    "explanation": "Combines a correct IDOR check with **explicit field whitelisting** (destructuring `{ email, phone }`), ensuring only permitted fields are updated."
  },
  {
    "id": 2347,
    "code": "const date = new Date(req.query.date);\nres.send(date.toString());",
    "label": "insecure",
    "vulnerability_type": "Date/Time Injection (DoS)",
    "explanation": "Passing arbitrary, unvalidated strings to the `Date()` constructor can cause excessive CPU usage due to complex date parsing, leading to DoS."
  },
  {
    "id": 2348,
    "code": "const dateString = req.query.date;\nif (!/^\\d{4}-\\d{2}-\\d{2}$/.test(dateString)) { return res.status(400).send(); }\nconst date = new Date(dateString);",
    "label": "secure",
    "vulnerability_type": "Date/Time Injection (DoS)",
    "explanation": "Validates the input string against a strict, simple date format regex before passing it to the date constructor, mitigating complex string parsing DoS."
  },
  {
    "id": 2349,
    "code": "const userEmail = req.query.email;\nif (userEmail.includes('@example.com')) { /* allow access */ }",
    "label": "insecure",
    "vulnerability_type": "Weak Regular Expression (ReDoS Potential)",
    "explanation": "While this example uses `includes`, complex regular expressions, if used on unvalidated user input, can be vulnerable to Regular Expression Denial of Service (ReDoS)."
  },
  {
    "id": 2350,
    "code": "const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$/;\nif (emailRegex.test(req.query.email)) { /* check for complex ReDoS issues if using more complex regex */ }",
    "label": "secure",
    "vulnerability_type": "Weak Regular Expression (ReDoS Potential)",
    "explanation": "Uses known safe regex patterns and/or uses a ReDoS-safe validation library to avoid catastrophic backtracking on complex regex patterns."
  },
  {
    "id": 2351,
    "code": "const tempDir = '/tmp/uploads';\nfs.rmdirSync(tempDir);",
    "label": "insecure",
    "vulnerability_type": "Synchronous I/O (DoS)",
    "explanation": "Uses the synchronous `fs.rmdirSync`, which blocks the Node.js event loop and can lead to server unresponsiveness under concurrent load."
  },
  {
    "id": 2352,
    "code": "const tempDir = '/tmp/uploads';\nfs.promises.rmdir(tempDir);",
    "label": "secure",
    "vulnerability_type": "Synchronous I/O (DoS)",
    "explanation": "Uses the asynchronous, Promise-based `fs.promises.rmdir`, ensuring the event loop remains unblocked and the server stays responsive."
  },
  {
    "id": 2353,
    "code": "app.get('/render', (req, res) => {\n  const template = 'Hello ' + req.query.name + '!';\n  res.send(template);\n});",
    "label": "insecure",
    "vulnerability_type": "Cross-Site Scripting (XSS) - Reflected",
    "explanation": "Concatenates unescaped user input into the HTML response, allowing for reflected XSS."
  },
  {
    "id": 2354,
    "code": "app.get('/render', (req, res) => {\n  const safeName = validator.escape(req.query.name);\n  const template = `Hello ${safeName}!`;\n  res.send(template);\n});",
    "label": "secure",
    "vulnerability_type": "Cross-Site Scripting (XSS) - Reflected",
    "explanation": "Uses a dedicated library (`validator.escape`) to encode HTML entities in user input, preventing the browser from executing injected scripts."
  },
  {
    "id": 2355,
    "code": "const dbQuery = `SELECT * FROM articles WHERE id = ${req.query.id}`;",
    "label": "insecure",
    "vulnerability_type": "SQL Injection (Template Literal)",
    "explanation": "Using a JavaScript template literal to directly embed unsanitized user input into a SQL query is functionally the same as string concatenation and is vulnerable."
  },
  {
    "id": 2356,
    "code": "const dbQuery = `SELECT * FROM articles WHERE id = ?`;\ndb.query(dbQuery, [req.query.id]);",
    "label": "secure",
    "vulnerability_type": "SQL Injection (Template Literal)",
    "explanation": "Uses the template literal for the SQL command structure but still relies on parameterized query execution (`?`, `[value]`) for security."
  },
  {
    "id": 2357,
    "code": "app.use(express.static('./'));",
    "label": "insecure",
    "vulnerability_type": "Static File Exposure (Root)",
    "explanation": "Serves the entire current working directory (`./`) as static content, exposing all source code, `.git` data, and configuration files to the public."
  },
  {
    "id": 2358,
    "code": "app.use(express.static(path.join(__dirname, 'public')));",
    "label": "secure",
    "vulnerability_type": "Static File Exposure (Root)",
    "explanation": "Restricts static file serving to a dedicated, explicitly named subdirectory (`public`), preventing the exposure of the application's root directory."
  },
  {
    "id": 2359,
    "code": "if (req.query.secret === process.env.SECRET) { /* expose admin data */ }",
    "label": "insecure",
    "vulnerability_type": "API Key Exposure (URL/Header)",
    "explanation": "A pattern that encourages users to pass a sensitive secret via URL query or a header that is not constantly time-checked."
  },
  {
    "id": 2360,
    "code": "const keyBuffer = Buffer.from(req.headers['x-admin-key'] || '');\nconst expectedBuffer = Buffer.from(process.env.ADMIN_SECRET);\nif (crypto.timingSafeEqual(keyBuffer, expectedBuffer)) { /* expose admin data */ }",
    "label": "secure",
    "vulnerability_type": "API Key Exposure (URL/Header)",
    "explanation": "Enforces a secure, constant-time comparison on buffers retrieved from a less exposed location (HTTP Header), mitigating both timing and URL exposure risks."
  },
  {
    "id": 2361,
    "code": "const username = req.body.user;\nconst email = req.body.email;\nif (username && email) { /* save user */ }",
    "label": "insecure",
    "vulnerability_type": "Insufficient Validation (Input Type)",
    "explanation": "Only checks for the existence of the fields; does not validate the content format, ensuring that `username` is a string and `email` is a valid email format."
  },
  {
    "id": 2362,
    "code": "const { username, email } = req.body;\nif (validator.isAlphanumeric(username) && validator.isEmail(email)) { /* save user */ }",
    "label": "secure",
    "vulnerability_type": "Insufficient Validation (Input Type)",
    "explanation": "Uses a validation library (`validator`) to confirm that the input matches the expected type and format (e.g., alphanumeric username, valid email)."
  },
  {
    "id": 2363,
    "code": "const cmd = 'ls -R ' + req.query.dir;\nexec(cmd, (err, stdout) => res.send(stdout));",
    "label": "insecure",
    "vulnerability_type": "Command Injection (Directory Listing)",
    "explanation": "Allows the user to inject commands into the directory name, potentially executing arbitrary shell code via metacharacters."
  },
  {
    "id": 2364,
    "code": "const dir = req.query.dir.replace(/[^\\w-]/g, '');\nconst cmd = 'ls -R ' + dir;\nexec(cmd, (err, stdout) => res.send(stdout));",
    "label": "secure",
    "vulnerability_type": "Command Injection (Directory Listing)",
    "explanation": "Strictly sanitizes the directory name to allow only alphanumeric characters and hyphens, eliminating the risk of command injection."
  },
  {
    "id": 2365,
    "code": "res.header('X-Download-Options', 'noopen');\nres.send('Content');",
    "label": "insecure",
    "vulnerability_type": "Missing HSTS Header",
    "explanation": "Missing the `Strict-Transport-Security` (HSTS) header, allowing clients to connect over unencrypted HTTP, which is vulnerable to MITM attacks."
  },
  {
    "id": 2366,
    "code": "app.use(helmet.hsts({ maxAge: 31536000, includeSubDomains: true }));\nres.header('X-Download-Options', 'noopen');\nres.send('Content');",
    "label": "secure",
    "vulnerability_type": "Missing HSTS Header",
    "explanation": "Enforces HSTS, instructing the browser to only connect to the site via HTTPS for a specified duration (`maxAge`), mitigating protocol downgrade attacks."
  },
  {
    "id": 2367,
    "code": "const html = '<h1>' + req.query.title + '</h1><p>' + req.query.body + '</p>';\nres.send(html);",
    "label": "insecure",
    "vulnerability_type": "Cross-Site Scripting (Multiple Inputs)",
    "explanation": "Combines and reflects two unescaped user inputs (`title` and `body`) into the HTML output, increasing the surface area for XSS attacks."
  },
  {
    "id": 2368,
    "code": "const safeTitle = validator.escape(req.query.title);\nconst safeBody = validator.escape(req.query.body);\nconst html = `<h1>${safeTitle}</h1><p>${safeBody}</p>`;\nres.send(html);",
    "label": "secure",
    "vulnerability_type": "Cross-Site Scripting (Multiple Inputs)",
    "explanation": "Applies HTML entity escaping to all user-supplied variables before they are rendered in the final output."
  },
  {
    "id": 2369,
    "code": "const cipher = crypto.createCipher('aes128', 'key123');",
    "label": "insecure",
    "vulnerability_type": "Weak Cryptography (Depreciated API)",
    "explanation": "Uses the depreciated and unsafe `crypto.createCipher` function, which does not enforce best practices like using GCM mode and is vulnerable to weak key sizing."
  },
  {
    "id": 2370,
    "code": "const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-gcm', key, iv);",
    "label": "secure",
    "vulnerability_type": "Weak Cryptography (Depreciated API)",
    "explanation": "Uses the secure `crypto.createCipheriv` with a strong algorithm (`aes-256-gcm`), a securely generated IV, and a large key loaded from the environment."
  },
  {
    "id": 2371,
    "code": "app.use(express.json());",
    "label": "insecure",
    "vulnerability_type": "DoS (JSON Payload Limit)",
    "explanation": "The default JSON payload limit is often too high, allowing an attacker to send a huge JSON body to exhaust server resources."
  },
  {
    "id": 2372,
    "code": "app.use(express.json({ limit: '1mb' }));",
    "label": "secure",
    "vulnerability_type": "DoS (JSON Payload Limit)",
    "explanation": "Sets a specific, smaller limit (`1mb`) on the size of the JSON payload that the server will accept, mitigating DoS via large requests."
  },
  {
    "id": 2373,
    "code": "const user = JSON.parse(req.session.user);\nif (user.role === 'admin') { /* access granted */ }",
    "label": "insecure",
    "vulnerability_type": "Session Tampering (Non-Signed Session)",
    "explanation": "Storing and deserializing complex objects in a session or cookie that is not signed/encrypted allows the user to tamper with the session data (e.g., changing `user.role`)."
  },
  {
    "id": 2374,
    "code": "const user = req.session.user;\nif (user.role === 'admin') { /* access granted */ }",
    "label": "secure",
    "vulnerability_type": "Session Tampering (Non-Signed Session)",
    "explanation": "Relies on a secure, server-side session store (e.g., Redis, MongoDB) where the session data is stored and only a random, untamperable session ID is sent to the client."
  },
  {
    "id": 2375,
    "code": "if (req.query.cmd === 'restart') { process.exit(1); }",
    "label": "insecure",
    "vulnerability_type": "Denial of Service (DoS) - Uncontrolled Exit",
    "explanation": "Allows a user to shut down the server simply by supplying a command in the query string, creating an immediate DoS vulnerability."
  },
  {
    "id": 2376,
    "code": "if (req.user.role === 'superadmin' && req.query.cmd === 'restart') {\n  setTimeout(() => process.exit(1), 100);\n}",
    "label": "secure",
    "vulnerability_type": "Denial of Service (DoS) - Uncontrolled Exit",
    "explanation": "Restricts the ability to shut down the server to only authenticated super-administrators, mitigating public DoS attacks."
  },
  {
    "id": 2377,
    "code": "const sql = 'SELECT * FROM users WHERE name = \"' + req.query.name + '\" AND password = \"' + req.query.pass + '\"';",
    "label": "insecure",
    "vulnerability_type": "SQL Injection (Login Form)",
    "explanation": "Concatenates both username and password input directly into the SQL query, which is the textbook example of SQL Injection."
  },
  {
    "id": 2378,
    "code": "const sql = 'SELECT * FROM users WHERE name = ? AND password = ?';\ndb.query(sql, [req.query.name, req.query.pass]);",
    "label": "secure",
    "vulnerability_type": "SQL Injection (Login Form)",
    "explanation": "Uses parameterized queries for both the username and password fields, ensuring both inputs are treated as literal strings, not SQL code."
  },
  {
    "id": 2379,
    "code": "const html = req.query.content;\ndocument.getElementById('output').innerHTML = html;",
    "label": "insecure",
    "vulnerability_type": "DOM-based XSS (Client-Side)",
    "explanation": "Inserting user-supplied data directly into the DOM using `innerHTML` is a common source of client-side (DOM-based) XSS."
  },
  {
    "id": 2380,
    "code": "const html = req.query.content;\ndocument.getElementById('output').textContent = html;",
    "label": "secure",
    "vulnerability_type": "DOM-based XSS (Client-Side)",
    "explanation": "Uses `textContent` instead of `innerHTML`, which automatically escapes any HTML or script tags, treating the input as pure text."
  },
  {
    "id": 2381,
    "code": "res.header('Set-Cookie', 'token=abc; Expires=' + new Date(Date.now() + 900000).toUTCString());",
    "label": "insecure",
    "vulnerability_type": "Insecure Cookie Management (Manual)",
    "explanation": "Manually setting the `Set-Cookie` header is error-prone, often missing crucial security flags like `HttpOnly`, `Secure`, and `SameSite`."
  },
  {
    "id": 2382,
    "code": "res.cookie('token', 'abc', { maxAge: 900000, httpOnly: true, secure: true, sameSite: 'strict' });",
    "label": "secure",
    "vulnerability_type": "Insecure Cookie Management (Manual)",
    "explanation": "Uses a dedicated framework function (`res.cookie` in Express) that allows setting security flags explicitly and reliably."
  },
  {
    "id": 2383,
    "code": "const dir = req.query.dir;\nif (fs.existsSync(dir)) { fs.readdirSync(dir); }",
    "label": "insecure",
    "vulnerability_type": "Synchronous I/O (Directory Read)",
    "explanation": "Uses synchronous `fs.readdirSync`, which blocks the server's event loop when reading potentially large directories."
  },
  {
    "id": 2384,
    "code": "const dir = req.query.dir;\nfs.promises.readdir(dir).then(files => { /* ... */ });",
    "label": "secure",
    "vulnerability_type": "Synchronous I/O (Directory Read)",
    "explanation": "Uses the asynchronous, Promise-based `fs.promises.readdir`, ensuring the file operation does not block the main execution thread."
  },
  {
    "id": 2385,
    "code": "app.get('/fetch', async (req, res) => {\n  const data = await fetch(req.query.url);\n  res.send(data);\n});",
    "label": "insecure",
    "vulnerability_type": "Server-Side Request Forgery (SSRF) - Full URL",
    "explanation": "Allows a user to supply a full URL to be fetched by the server, enabling SSRF attacks against internal network hosts or services."
  },
  {
    "id": 2386,
    "code": "app.get('/fetch', async (req, res) => {\n  const url = new URL(req.query.url);\n  if (url.hostname.match(/(^127\\.)|(^10\\.)|(^172\\.1[6-9])|(^172\\.2[0-9])|(^172\\.3[0-1])|(^192\\.168\\.)/)) {\n    return res.status(403).send('Private IP forbidden');\n  }\n  const data = await fetch(url.toString());\n  res.send(data);\n});",
    "label": "secure",
    "vulnerability_type": "Server-Side Request Forgery (SSRF) - Full URL",
    "explanation": "Parses the URL and uses a **blacklist** (regex) to check for and explicitly block known private/internal IP ranges (e.g., 127.0.0.1, 192.168.x.x)."
  },
  {
    "id": 2387,
    "code": "const data = req.body.input;\nconst result = templateEngine.render(data);",
    "label": "insecure",
    "vulnerability_type": "Server-Side Template Injection (SSTI) - Unvalidated Content",
    "explanation": "Passing unsanitized user input to a server-side template engine can lead to remote code execution if the template language is expressive."
  },
  {
    "id": 2388,
    "code": "const data = validator.escape(req.body.input);\nconst result = templateEngine.render(data);",
    "label": "secure",
    "vulnerability_type": "Server-Side Template Injection (SSTI) - Unvalidated Content",
    "explanation": "Escapes the user input to ensure it is treated as literal text, not as template code, before rendering."
  },
  {
    "id": 2389,
    "code": "const file = req.query.log;\nexec(`cat ${file}`, (err, stdout) => res.send(stdout));",
    "label": "insecure",
    "vulnerability_type": "Command Injection (Shell Concatenation)",
    "explanation": "Concatenates a user-supplied filename into a shell command, vulnerable to injection via `&`, `|`, or $()`."
  },
  {
    "id": 2390,
    "code": "const file = path.basename(req.query.log);\nexecFile('cat', [file], (err, stdout) => res.send(stdout));",
    "label": "secure",
    "vulnerability_type": "Command Injection (Shell Concatenation)",
    "explanation": "Uses `path.basename` to clean the filename and `execFile` (which bypasses the shell), treating the filename as a safe, literal argument."
  },
  {
    "id": 2391,
    "code": "app.get('/user', (req, res) => {\n  if (req.query.admin) { req.session.isAdmin = true; }\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Authorization Bypass (Unprotected Endpoint)",
    "explanation": "A GET endpoint directly modifies a sensitive session variable (`isAdmin`) based on an unauthenticated query parameter."
  },
  {
    "id": 2392,
    "code": "app.post('/setadmin', authMiddleware, (req, res) => {\n  if (req.user.role === 'superadmin' && req.body.id) {\n    db.setAdmin(req.body.id);\n    req.session.isAdmin = true;\n  }\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Authorization Bypass (Unprotected Endpoint)",
    "explanation": "Enforces strong authentication (`authMiddleware`), uses the safer POST method, and includes a granular authorization check (`superadmin` role) before modifying privileges."
  },
  {
    "id": 2393,
    "code": "const data = JSON.parse(req.body.input);\ndb.save(data);",
    "label": "insecure",
    "vulnerability_type": "Mass Assignment / Logic Flaw",
    "explanation": "Saving an entire JSON object from the request body to the database allows attackers to inject fields or violate data integrity (Mass Assignment)."
  },
  {
    "id": 2394,
    "code": "const data = JSON.parse(req.body.input);\nconst safeData = { title: data.title, content: data.content };\ndb.save(safeData);",
    "label": "secure",
    "vulnerability_type": "Mass Assignment / Logic Flaw",
    "explanation": "Applies field whitelisting by explicitly selecting only the safe and expected fields from the input JSON before saving to the database."
  },
  {
    "id": 2395,
    "code": "res.header('Content-Security-Policy', \"default-src 'self' 'unsafe-inline';\");",
    "label": "insecure",
    "vulnerability_type": "Weak CSP Policy ('unsafe-inline')",
    "explanation": "Using `'unsafe-inline'` in the Content Security Policy (CSP) completely negates the XSS protection offered by the policy, allowing inline scripts."
  },
  {
    "id": 2396,
    "code": "res.header('Content-Security-Policy', \"default-src 'self'; script-src 'self' https://trusted.cdn; object-src 'none';\");",
    "label": "secure",
    "vulnerability_type": "Weak CSP Policy ('unsafe-inline')",
    "explanation": "Removes `'unsafe-inline'` and enforces a strict, nonce- or hash-based CSP, only allowing scripts from trusted sources and blocking embedded objects."
  },
  {
    "id": 2397,
    "code": "const salt = 'fixed-salt';\nconst hash = bcrypt.hashSync(password, salt);",
    "label": "insecure",
    "vulnerability_type": "Weak Cryptography (Fixed Salt)",
    "explanation": "Using a fixed, non-random salt defeats the purpose of salting, making the system vulnerable to pre-computation and rainbow table attacks."
  },
  {
    "id": 2398,
    "code": "const saltRounds = 12;\nconst hash = bcrypt.hashSync(password, saltRounds);",
    "label": "secure",
    "vulnerability_type": "Weak Cryptography (Fixed Salt)",
    "explanation": "Uses a cryptographically secure random salt generated internally by the library (`bcrypt`) for each hash, preventing rainbow table attacks."
  },
  {
    "id": 2399,
    "code": "app.get('/info', (req, res) => {\n  res.send('Details: ' + app.settings.secret);\n});",
    "label": "insecure",
    "vulnerability_type": "Information Leakage (App Settings)",
    "explanation": "Exposes an application-wide secret or sensitive setting via an unprotected endpoint."
  },
  {
    "id": 2400,
    "code": "app.get('/info', (req, res) => {\n  res.send('Details: Version ' + process.env.VERSION);\n});",
    "label": "secure",
    "vulnerability_type": "Information Leakage (App Settings)",
    "explanation": "Only exposes non-sensitive, public information like the application version, ensuring private settings remain hidden."
  },
  {
    "id": 2401,
    "code": "const url = new URL(req.query.path);\nif (url.protocol === 'http:') { res.redirect(url.toString()); }",
    "label": "insecure",
    "vulnerability_type": "Open Redirect (Protocol Check Bypass)",
    "explanation": "Checking only the protocol (`http:`) still allows redirects to arbitrary external sites, enabling phishing."
  },
  {
    "id": 2402,
    "code": "const url = req.query.path;\nif (url.startsWith('/') || url.startsWith('/local')) { res.redirect(url); }",
    "label": "secure",
    "vulnerability_type": "Open Redirect (Protocol Check Bypass)",
    "explanation": "Uses strict validation to ensure the path is either relative to the current host or starts with an explicitly allowed internal path."
  },
  {
    "id": 2403,
    "code": "const data = req.body.xml;\nxml2js.parseString(data, (err, result) => res.json(result));",
    "label": "insecure",
    "vulnerability_type": "XML External Entity (XXE) - Default Parser",
    "explanation": "Using a default XML parser (like `xml2js`) that doesn't disable DTD processing can lead to XXE attacks or DoS."
  },
  {
    "id": 2404,
    "code": "const data = req.body.xml;\nxml2js.parseString(data, { explicitArray: false, strict: true, resolveExternalEntities: false }, (err, result) => res.json(result));",
    "label": "secure",
    "vulnerability_type": "XML External Entity (XXE) - Default Parser",
    "explanation": "Configures the XML parser to explicitly disable features that enable XXE, such as external entity resolution (`resolveExternalEntities: false`)."
  },
  {
    "id": 2405,
    "code": "const token = jwt.sign({ user: req.user.id }, process.env.SECRET, { expiresIn: '10y' });",
    "label": "insecure",
    "vulnerability_type": "Insecure Session Management (Long Expiration)",
    "explanation": "Setting an extremely long token expiration time (`10y`) for a session token violates best practices and increases the window for token reuse or theft."
  },
  {
    "id": 2406,
    "code": "const token = jwt.sign({ user: req.user.id }, process.env.SECRET, { expiresIn: '15m' });",
    "label": "secure",
    "vulnerability_type": "Insecure Session Management (Long Expiration)",
    "explanation": "Uses a short, reasonable expiration time (`15m` to `1h`) for session tokens, forcing frequent re-authentication and minimizing the impact of token compromise."
  },
  {
    "id": 2407,
    "code": "app.get('/status', (req, res) => {\n  res.send(db.status);\n});",
    "label": "insecure",
    "vulnerability_type": "Information Leakage (Database Status)",
    "explanation": "Exposes internal database connection or status details via an unauthenticated endpoint, which could reveal connection strings, version info, or error messages."
  },
  {
    "id": 2408,
    "code": "app.get('/status', (req, res) => {\n  if (db.isConnected) {\n    res.send('Database: Connected');\n  } else {\n    res.status(503).send('Database: Offline');\n  }\n});",
    "label": "secure",
    "vulnerability_type": "Information Leakage (Database Status)",
    "explanation": "Only exposes a generic status (Connected/Offline) without providing any specific technical details, mitigating information leakage."
  },
  {
    "id": 2409,
    "code": "const { username, password } = req.body;\nconst user = await db.findOne({ username });\nif (!user) { return res.status(401).send(); }\nconst match = await bcrypt.compare(password, user.password);\nif (match) { res.send('Login Success'); } else { res.status(401).send('Invalid password'); }",
    "label": "insecure",
    "vulnerability_type": "Timing Attack (Username Enumeration)",
    "explanation": "Responds with a different HTTP status or error message when a username is not found (`!user`) versus when the password is just wrong (`!match`), allowing an attacker to enumerate valid usernames."
  },
  {
    "id": 2410,
    "code": "const { username, password } = req.body;\nconst user = await db.findOne({ username });\nconst dummyHash = await bcrypt.hash('dummy_pass', 10); // Constant time if user not found\nconst hashToCompare = user ? user.password : dummyHash;\nconst match = await bcrypt.compare(password, hashToCompare);\nif (match && user) { res.send('Login Success'); } else { res.status(401).send('Invalid credentials'); }",
    "label": "secure",
    "vulnerability_type": "Timing Attack (Username Enumeration)",
    "explanation": "Returns a generic error message (`Invalid credentials`) for all failures and performs a constant-time operation (even comparing a dummy hash) when a user is not found, preventing username enumeration."
  },
  {
    "id": 2411,
    "code": "const data = req.query.input;\nres.set('Content-Type', 'text/html').send(data);",
    "label": "insecure",
    "vulnerability_type": "Cross-Site Scripting (Reflected HTML)",
    "explanation": "Sends raw, unescaped user input back to the browser with a `text/html` content type, which will execute any injected script."
  },
  {
    "id": 2412,
    "code": "const data = req.query.input;\nres.set('Content-Type', 'text/plain').send(data);",
    "label": "secure",
    "vulnerability_type": "Cross-Site Scripting (Reflected HTML)",
    "explanation": "Sets the `Content-Type` header to `text/plain`, instructing the browser to render the content as literal text, not as executable HTML."
  },
  {
    "id": 2413,
    "code": "const filename = req.query.name;\nexec(`chmod 777 ${filename}`, (err, stdout) => res.send(stdout));",
    "label": "insecure",
    "vulnerability_type": "Command Injection (Permissions)",
    "explanation": "Allows arbitrary filenames to be passed to a shell command (`chmod`), enabling command injection and modification of sensitive file permissions."
  },
  {
    "id": 2414,
    "code": "const filename = path.join('/app/uploads', path.basename(req.query.name));\nexecFile('chmod', ['644', filename], (err, stdout) => res.send(stdout));",
    "label": "secure",
    "vulnerability_type": "Command Injection (Permissions)",
    "explanation": "Uses `execFile` (shell bypass), restricts the path, and uses a safe permission level (`644`), ensuring the operation is safe and isolated."
  },
  {
    "id": 2415,
    "code": "const template = 'Hello ' + req.query.name;\nres.render('main', { content: template });",
    "label": "insecure",
    "vulnerability_type": "Server-Side Template Injection (Unescaped Variable)",
    "explanation": "If the template engine doesn't automatically escape variables passed to it, the `name` variable can contain scripts, leading to XSS when the template is rendered."
  },
  {
    "id": 2416,
    "code": "const template = 'Hello ' + req.query.name;\nres.render('main', { content: template }, { escape: true });",
    "label": "secure",
    "vulnerability_type": "Server-Side Template Injection (Unescaped Variable)",
    "explanation": "Explicitly configures the template engine (or trusts a default-secure engine) to escape all variables passed during rendering, preventing XSS."
  },
  {
    "id": 2417,
    "code": "const key = req.body.key;\nconst value = req.body.value;\nsettings[key] = value;",
    "label": "insecure",
    "vulnerability_type": "Prototype Pollution (Object Assignment)",
    "explanation": "Directly assigning user-supplied keys and values to an object can allow an attacker to inject properties like `__proto__` to pollute the global `Object.prototype`."
  },
  {
    "id": 2418,
    "code": "const key = req.body.key;\nconst value = req.body.value;\nif (key === '__proto__' || key === 'constructor') {\n  return res.status(403).send('Forbidden key');\n}\nsettings[key] = value;",
    "label": "secure",
    "vulnerability_type": "Prototype Pollution (Object Assignment)",
    "explanation": "Explicitly blocks the use of keys related to prototype inheritance (`__proto__`, `constructor`, `prototype`), mitigating the pollution attack."
  },
  {
    "id": 2419,
    "code": "const user_id = req.query.id;\nconst query = `UPDATE logs SET status = 'read' WHERE user_id = ${user_id}`;",
    "label": "insecure",
    "vulnerability_type": "SQL Injection (UPDATE)",
    "explanation": "Allows an attacker to modify the `WHERE` clause or inject additional SQL commands into the `UPDATE` statement via the `user_id` parameter."
  },
  {
    "id": 2420,
    "code": "const user_id = req.query.id;\nconst query = `UPDATE logs SET status = 'read' WHERE user_id = ?`;\ndb.query(query, [user_id]);",
    "label": "secure",
    "vulnerability_type": "SQL Injection (UPDATE)",
    "explanation": "Uses a parameterized query for the `user_id` in the `WHERE` clause, ensuring the value is treated as a safe literal string."
  },
  {
    "id": 2421,
    "code": "const response = await fetch('http://' + req.query.host);",
    "label": "insecure",
    "vulnerability_type": "Server-Side Request Forgery (SSRF) - Unsafe Host",
    "explanation": "Concatenates user input into the hostname, allowing an attacker to specify internal network addresses (SSRF)."
  },
  {
    "id": 2422,
    "code": "const host = req.query.host;\nif (host.includes('localhost') || host.includes('127.0.0.1')) {\n  return res.status(403).send();\n}\nconst response = await fetch(`http://${host}`);",
    "label": "secure",
    "vulnerability_type": "Server-Side Request Forgery (SSRF) - Unsafe Host",
    "explanation": "Implements a **simple blacklist** check to prevent connections to the local loopback address, a basic mitigation against SSRF."
  },
  {
    "id": 2423,
    "code": "res.set('Access-Control-Allow-Origin', '*');",
    "label": "insecure",
    "vulnerability_type": "CORS Misconfiguration (Wildcard)",
    "explanation": "Using a wildcard (`*`) for `Access-Control-Allow-Origin` allows any domain to access the resource, which is a severe security risk for authenticated endpoints."
  },
  {
    "id": 2424,
    "code": "res.set('Access-Control-Allow-Origin', process.env.TRUSTED_ORIGIN);",
    "label": "secure",
    "vulnerability_type": "CORS Misconfiguration (Wildcard)",
    "explanation": "Sets the `Access-Control-Allow-Origin` header to a specific, trusted origin URL retrieved from the server configuration."
  },
  {
    "id": 2425,
    "code": "const result = (req.query.num / 0) * 10;",
    "label": "insecure",
    "vulnerability_type": "DoS (Arithmetic Exception)",
    "explanation": "Performs an operation (division by zero) that results in `Infinity`, which can lead to unexpected behavior or resource drain in downstream processing."
  },
  {
    "id": 2426,
    "code": "const num = parseFloat(req.query.num);\nif (num === 0) { return res.status(400).send('Cannot divide by zero'); }\nconst result = (req.query.denom / num) * 10;",
    "label": "secure",
    "vulnerability_type": "DoS (Arithmetic Exception)",
    "explanation": "Explicitly checks the denominator for a zero value before performing division, returning a controlled error instead of an undefined result."
  },
  {
    "id": 2427,
    "code": "const html = '<div>' + req.query.data + '</div>';\ndocument.body.innerHTML = html;",
    "label": "insecure",
    "vulnerability_type": "DOM-based XSS (Client-Side HTML)",
    "explanation": "Injecting unsanitized user input into `innerHTML` is a prime vector for client-side XSS, as the browser will execute script tags."
  },
  {
    "id": 2428,
    "code": "const html = req.query.data;\nconst safeHTML = DOMPurify.sanitize(html);\ndocument.body.innerHTML = safeHTML;",
    "label": "secure",
    "vulnerability_type": "DOM-based XSS (Client-Side HTML)",
    "explanation": "Uses a secure client-side HTML sanitization library (`DOMPurify`) to safely clean any script or malicious content from the user input before it is rendered."
  },
  {
    "id": 2429,
    "code": "const cmd = 'curl ' + req.query.target;\nexec(cmd, (err, stdout) => res.send(stdout));",
    "label": "insecure",
    "vulnerability_type": "Command Injection (Shell Curl)",
    "explanation": "Allows command injection via the target parameter, which can include shell metacharacters to execute arbitrary commands."
  },
  {
    "id": 2430,
    "code": "const target = req.query.target.replace(/[^\\w.-]/g, '');\nexecFile('curl', [target], (err, stdout) => res.send(stdout));",
    "label": "secure",
    "vulnerability_type": "Command Injection (Shell Curl)",
    "explanation": "Sanitizes the target parameter and uses `execFile` to bypass the shell, ensuring the parameter is treated as a safe literal argument."
  },
  {
    "id": 2431,
    "code": "const token = jwt.sign({ data: req.body.data }, 'weak', { algorithm: 'HS256' });",
    "label": "insecure",
    "vulnerability_type": "Weak Cryptography (Hardcoded Secret)",
    "explanation": "Uses a very short, hardcoded secret for JWT signing, making the tokens trivial to brute-force or guess."
  },
  {
    "id": 2432,
    "code": "const token = jwt.sign({ data: req.body.data }, process.env.JWT_SECRET_KEY, { algorithm: 'HS512' });",
    "label": "secure",
    "vulnerability_type": "Weak Cryptography (Hardcoded Secret)",
    "explanation": "Uses a long, secure secret from an environment variable and a stronger hashing algorithm (`HS512`) for token signing."
  },
  {
    "id": 2433,
    "code": "const filename = req.query.file;\nfs.readFileSync(filename);",
    "label": "insecure",
    "vulnerability_type": "Path Traversal (Unprotected Read)",
    "explanation": "Allows a user to read arbitrary files from the filesystem via the `filename` parameter using `../`."
  },
  {
    "id": 2434,
    "code": "const filename = path.join('/app/configs', path.basename(req.query.file));\nfs.readFileSync(filename);",
    "label": "secure",
    "vulnerability_type": "Path Traversal (Unprotected Read)",
    "explanation": "Restricts the file read operation to a specific directory and uses `path.basename` to prevent directory traversal sequences."
  },
  {
    "id": 2435,
    "code": "app.get('/debug', (req, res) => {\n  if (req.query.mode === 'verbose') {\n    console.log(JSON.stringify(process.env));\n  }\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Information Leakage (Debug)",
    "explanation": "Exposes all environment variables (including secrets) simply by setting a verbose flag in the URL, without authentication."
  },
  {
    "id": 2436,
    "code": "const safeEnv = Object.keys(process.env).filter(key => key.startsWith('PUBLIC_'));\napp.get('/debug', (req, res) => {\n  if (req.user.isAdmin && req.query.mode === 'verbose') {\n    console.log(JSON.stringify(safeEnv));\n  }\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Information Leakage (Debug)",
    "explanation": "Restricts the debug feature to administrators and filters the environment variables to only expose non-sensitive, whitelisted keys."
  },
  {
    "id": 2437,
    "code": "const user_id = req.query.user_id;\nconst query = `INSERT INTO access_log (user_id) VALUES ('${user_id}')`;",
    "label": "insecure",
    "vulnerability_type": "SQL Injection (INSERT)",
    "explanation": "Injects user input into the `INSERT` statement, allowing an attacker to modify the values or inject additional SQL commands."
  },
  {
    "id": 2438,
    "code": "const user_id = req.query.user_id;\nconst query = `INSERT INTO access_log (user_id) VALUES (?)`;\ndb.query(query, [user_id]);",
    "label": "secure",
    "vulnerability_type": "SQL Injection (INSERT)",
    "explanation": "Uses a parameterized query for the `INSERT` statement, ensuring the `user_id` is safely inserted as a literal value."
  },
  {
    "id": 2439,
    "code": "const data = req.body.data;\nconst result = Buffer.from(data, 'hex').toString();",
    "label": "insecure",
    "vulnerability_type": "DoS (Buffer Creation)",
    "explanation": "Creating a buffer from user input without validation can lead to resource exhaustion if the input string is excessively large."
  },
  {
    "id": 2440,
    "code": "const data = req.body.data;\nif (data.length > 4096) return res.status(413).send('Payload too large');\nconst result = Buffer.from(data, 'hex').toString();",
    "label": "secure",
    "vulnerability_type": "DoS (Buffer Creation)",
    "explanation": "Explicitly checks the length of the input string and rejects payloads above a predefined, safe limit, mitigating buffer-related DoS attacks."
  },
  {
    "id": 2441,
    "code": "app.get('/info', (req, res) => {\n  res.set('X-Content-Type-Options', 'no-sniff');\n  res.set('X-XSS-Protection', '1');\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Header (X-XSS-Protection)",
    "explanation": "The `X-XSS-Protection` header is outdated and sometimes less secure than relying solely on a robust Content Security Policy (CSP). Using '1' leaves a vulnerability open."
  },
  {
    "id": 2442,
    "code": "app.get('/info', (req, res) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  // Rely on CSP for XSS protection, and omit X-XSS-Protection.\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Header (X-XSS-Protection)",
    "explanation": "Omits the outdated `X-XSS-Protection` header and instead relies on modern, strict Content Security Policy (CSP) headers for XSS defense."
  },
  {
    "id": 2443,
    "code": "if (req.body.id === req.session.user_id) { /* update profile */ }",
    "label": "insecure",
    "vulnerability_type": "Insecure Direct Object Reference (IDOR) - User-Supplied ID",
    "explanation": "Compares a user-supplied ID (`req.body.id`) with the session ID. If the check fails, the vulnerable code would proceed with the wrong ID, or if the attacker controls `req.body.id`."
  },
  {
    "id": 2444,
    "code": "if (req.body.id === req.session.user_id) { /* update profile */ } else {\n  // Best practice: use req.session.user_id for update query to prevent IDOR\n  db.updateProfile(req.session.user_id, req.body);\n}",
    "label": "secure",
    "vulnerability_type": "Insecure Direct Object Reference (IDOR) - User-Supplied ID",
    "explanation": "Instead of relying on the user-supplied ID, the query to update the profile uses the trusted, server-side session ID (`req.session.user_id`) as the identifier."
  },
  {
    "id": 2445,
    "code": "const key = req.query.key;\nconst hash = sha256(key);",
    "label": "insecure",
    "vulnerability_type": "Weak Cryptography (Hashing Algorithm)",
    "explanation": "While SHA-256 is strong, using it directly for password hashing is insecure as it lacks the necessary salt and work-factor to resist offline brute-force attacks."
  },
  {
    "id": 2446,
    "code": "const key = req.query.key;\nconst hash = bcrypt.hashSync(key, 12);",
    "label": "secure",
    "vulnerability_type": "Weak Cryptography (Hashing Algorithm)",
    "explanation": "Uses a dedicated, slow, adaptive password-hashing function (like bcrypt, scrypt, or Argon2) with a high work-factor (12) to resist brute-force attacks."
  },
  {
    "id": 2447,
    "code": "app.post('/import', (req, res) => {\n  const data = req.body.data;\n  yaml.load(data);\n  res.send('Imported');\n});",
    "label": "insecure",
    "vulnerability_type": "Insecure Deserialization (YAML)",
    "explanation": "YAML deserialization often allows for remote code execution (RCE) via custom tags or constructors, making it extremely dangerous with untrusted input."
  },
  {
    "id": 2448,
    "code": "app.post('/import', (req, res) => {\n  const data = req.body.data;\n  yaml.load(data, { schema: yaml.JSON_SCHEMA });\n  res.send('Imported');\n});",
    "label": "secure",
    "vulnerability_type": "Insecure Deserialization (YAML)",
    "explanation": "Restricts the YAML parser to only use the safe JSON schema, preventing the parser from instantiating dangerous native types or custom objects that lead to RCE."
  },
  {
    "id": 2449,
    "code": "res.status(500).send('Error: ' + err.message);",
    "label": "insecure",
    "vulnerability_type": "Error Message Disclosure",
    "explanation": "Returns raw internal error messages (`err.message`) directly to the client, potentially revealing stack traces, database details, or file paths."
  },
  {
    "id": 2450,
    "code": "res.status(500).send('An unexpected error occurred. Please try again later.');",
    "label": "secure",
    "vulnerability_type": "Error Message Disclosure",
    "explanation": "Returns only a generic, non-technical error message to the client, while logging the full, sensitive error details on the server."
  },
  {
    "id": 2451,
    "code": "const user_id = req.query.id;\nconst query = 'SELECT * FROM users WHERE id = ' + user_id + ' LIMIT 1;';",
    "label": "insecure",
    "vulnerability_type": "SQL Injection (LIMIT bypass)",
    "explanation": "The user input can bypass the `LIMIT 1` clause or inject malicious commands after the ID."
  },
  {
    "id": 2452,
    "code": "const user_id = req.query.id;\nconst query = 'SELECT * FROM users WHERE id = ? LIMIT 1;';\ndb.query(query, [user_id]);",
    "label": "secure",
    "vulnerability_type": "SQL Injection (LIMIT bypass)",
    "explanation": "Uses a parameterized query to treat the ID as a safe literal value, preventing SQL injection commands."
  },
  {
    "id": 2453,
    "code": "const cmd = 'start ' + req.query.program;\nrequire('child_process').exec(cmd, () => {});",
    "label": "insecure",
    "vulnerability_type": "Command Injection (Program Name)",
    "explanation": "Allows injection into the program name executed via a shell, enabling arbitrary command execution."
  },
  {
    "id": 2454,
    "code": "const program = req.query.program.replace(/[^a-zA-Z0-9]/g, '');\nrequire('child_process').execFile('start', [program], () => {});",
    "label": "secure",
    "vulnerability_type": "Command Injection (Program Name)",
    "explanation": "Sanitizes the program name to only alphanumeric characters and uses `execFile` to bypass the shell environment."
  },
  {
    "id": 2455,
    "code": "app.get('/data', (req, res) => {\n  res.send(req.query.user + ' data');\n});",
    "label": "insecure",
    "vulnerability_type": "Cross-Site Scripting (Unescaped Variable)",
    "explanation": "Reflects the `user` query parameter without escaping, which can lead to XSS if a script is injected."
  },
  {
    "id": 2456,
    "code": "app.get('/data', (req, res) => {\n  res.send(validator.escape(req.query.user) + ' data');\n});",
    "label": "secure",
    "vulnerability_type": "Cross-Site Scripting (Unescaped Variable)",
    "explanation": "Uses a robust escaping mechanism (`validator.escape`) to neutralize any HTML or script tags in the user input."
  },
  {
    "id": 2457,
    "code": "app.get('/profile', (req, res) => {\n  const user = db.find(req.query.username);\n  res.json(user);\n});",
    "label": "insecure",
    "vulnerability_type": "Information Leakage (Full Object)",
    "explanation": "Retrieves the full user object using a query parameter and returns it entirely, potentially including internal fields like `password_hash`."
  },
  {
    "id": 2458,
    "code": "app.get('/profile', (req, res) => {\n  const user = db.find(req.query.username);\n  const safeUser = { id: user.id, username: user.username };\n  res.json(safeUser);\n});",
    "label": "secure",
    "vulnerability_type": "Information Leakage (Full Object)",
    "explanation": "Creates a filtered object (`safeUser`) containing only non-sensitive, whitelisted fields before returning the JSON response."
  },
  {
    "id": 2459,
    "code": "const url = new URL(req.query.target);\nres.redirect(url.toString());",
    "label": "insecure",
    "vulnerability_type": "Open Redirect (URL Object)",
    "explanation": "Redirects to an arbitrary, user-controlled URL, enabling phishing attacks."
  },
  {
    "id": 2460,
    "code": "const target = req.query.target;\nif (target.startsWith('/')) {\n  res.redirect(target);\n} else {\n  res.redirect('/');\n}",
    "label": "secure",
    "vulnerability_type": "Open Redirect (URL Object)",
    "explanation": "Validates that the redirect URL is a relative path (starts with `/`), ensuring the user is redirected within the same domain."
  },
  {
    "id": 2461,
    "code": "res.header('Set-Cookie', 'user=admin');",
    "label": "insecure",
    "vulnerability_type": "Missing Cookie Flags (Manual)",
    "explanation": "Manually setting a cookie header without `HttpOnly` or `Secure` flags allows client-side script access and unencrypted transmission."
  },
  {
    "id": 2462,
    "code": "res.cookie('user', 'admin', { httpOnly: true, secure: true, sameSite: 'strict' });",
    "label": "secure",
    "vulnerability_type": "Missing Cookie Flags (Manual)",
    "explanation": "Uses a secure framework function to set the cookie with all necessary flags: `HttpOnly`, `Secure`, and `SameSite: 'strict'`."
  },
  {
    "id": 2463,
    "code": "const file = req.query.log;\nfs.promises.unlink(file);",
    "label": "insecure",
    "vulnerability_type": "Path Traversal (Delete)",
    "explanation": "Allows a user to specify any filename for deletion, enabling path traversal to destroy application configuration or sensitive files."
  },
  {
    "id": 2464,
    "code": "const file = path.join('/tmp/logs', path.basename(req.query.log));\nfs.promises.unlink(file);",
    "label": "secure",
    "vulnerability_type": "Path Traversal (Delete)",
    "explanation": "Restricts the delete operation to a safe, non-critical directory (`/tmp/logs`) and uses `path.basename` to sanitize the filename."
  },
  {
    "id": 2465,
    "code": "const token = req.query.token;\nconst user = jwt.verify(token, process.env.SECRET);\nif (user.role === 'guest') { /* deny access */ }",
    "label": "insecure",
    "vulnerability_type": "JWT Misconfiguration (Unchecked Alg)",
    "explanation": "The verification does not explicitly check that the algorithm used for the token is the expected algorithm, potentially allowing an attacker to use `alg: none`."
  },
  {
    "id": 2466,
    "code": "const token = req.query.token;\nconst user = jwt.verify(token, process.env.SECRET, { algorithms: ['HS256'] });\nif (user.role === 'guest') { /* deny access */ }",
    "label": "secure",
    "vulnerability_type": "JWT Misconfiguration (Unchecked Alg)",
    "explanation": "The verification function is configured with an explicit list of allowed algorithms (`algorithms: ['HS256']`), forcing rejection of tokens using the `none` algorithm."
  },
  {
    "id": 2467,
    "code": "const ip = req.query.ip;\nconst cmd = 'ping ' + ip;",
    "label": "insecure",
    "vulnerability_type": "Command Injection (Unexecuted)",
    "explanation": "The code constructs a vulnerable command string that is later executed by another function, still representing the injection pattern."
  },
  {
    "id": 2468,
    "code": "const ip = req.query.ip;\nif (!ip.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) { return res.status(400).send(); }\nconst cmd = 'ping ' + ip;",
    "label": "secure",
    "vulnerability_type": "Command Injection (Unexecuted)",
    "explanation": "Applies a strict validation regex to ensure the input is formatted as a simple IP address, preventing the injection of shell metacharacters."
  },
  {
    "id": 2469,
    "code": "const key = req.query.key;\nconst value = req.query.value;\ndb.set(`SETTINGS_${key}`, value);",
    "label": "insecure",
    "vulnerability_type": "Insecure Key Naming (DoS)",
    "explanation": "If the key is not sanitized, an attacker can use very long keys to bloat the database key space, leading to storage or performance DoS."
  },
  {
    "id": 2470,
    "code": "const key = req.query.key.substring(0, 50).replace(/[^a-zA-Z0-9_]/g, '');\nconst value = req.query.value;\ndb.set(`SETTINGS_${key}`, value);",
    "label": "secure",
    "vulnerability_type": "Insecure Key Naming (DoS)",
    "explanation": "Enforces a strict length limit and sanitizes the key to a safe character set, preventing key-space DoS attacks."
  },
  {
    "id": 2471,
    "code": "app.post('/register', (req, res) => {\n  const user = req.body;\n  db.users.create(user);\n  res.send('ok');\n});",
    "label": "insecure",
    "vulnerability_type": "Mass Assignment (ORMs - create)",
    "explanation": "Passing the entire request body to an ORM's create function allows an attacker to set unauthorized fields (Mass Assignment)."
  },
  {
    "id": 2472,
    "code": "app.post('/register', async (req, res) => {\n  const { email, password } = req.body;\n  const hashedPassword = await bcrypt.hash(password, 10);\n  db.users.create({ email, password: hashedPassword });\n  res.send('ok');\n});",
    "label": "secure",
    "vulnerability_type": "Mass Assignment (ORMs - create)",
    "explanation": "Explicitly extracts only the required and safe fields from the request body and performs password hashing before calling the ORM's create function."
  },
  {
    "id": 2473,
    "code": "const username = req.cookies.name;\nres.send('Welcome, ' + username);",
    "label": "insecure",
    "vulnerability_type": "XSS (Reflected Cookie)",
    "explanation": "If the cookie value is not encoded, any XSS payload stored in the cookie will be reflected and executed on the page."
  },
  {
    "id": 2474,
    "code": "const username = req.cookies.name;\nres.send('Welcome, ' + validator.escape(username));",
    "label": "secure",
    "vulnerability_type": "XSS (Reflected Cookie)",
    "explanation": "Uses HTML entity escaping on the cookie value before it is reflected into the response body, mitigating XSS."
  },
  {
    "id": 2475,
    "code": "const data = req.body.json;\nconst obj = JSON.parse(data);",
    "label": "insecure",
    "vulnerability_type": "Prototype Pollution (JSON.parse)",
    "explanation": "Certain environments or custom JSON parsing setups can still be vulnerable to Prototype Pollution when using `JSON.parse` with `__proto__` as a key."
  },
  {
    "id": 2476,
    "code": "const data = req.body.json;\nconst obj = JSON.parse(data, (key, value) => {\n  if (key === '__proto__') return undefined; return value;\n});",
    "label": "secure",
    "vulnerability_type": "Prototype Pollution (JSON.parse)",
    "explanation": "Uses the optional reviver function in `JSON.parse` to explicitly filter out dangerous keys like `__proto__` during deserialization."
  },
  {
    "id": 2477,
    "code": "const key = req.query.key;\nconst value = req.query.value;\nredis.set(key, value);",
    "label": "insecure",
    "vulnerability_type": "Injection (Redis)",
    "explanation": "If the underlying Redis driver is vulnerable or the `key` is not sanitized, it can allow an attacker to inject Redis commands."
  },
  {
    "id": 2478,
    "code": "const key = req.query.key.replace(/[\\r\\n]/g, '');\nconst value = req.query.value.replace(/[\\r\\n]/g, '');\nredis.set(key, value);",
    "label": "secure",
    "vulnerability_type": "Injection (Redis)",
    "explanation": "Sanitizes the key and value by removing newline characters, which can be used in some protocols to inject subsequent commands."
  },
  {
    "id": 2479,
    "code": "const user_id = req.query.id;\nconst query = `DELETE FROM accounts WHERE user_id = ${user_id} AND active = 0`;",
    "label": "insecure",
    "vulnerability_type": "SQL Injection (Delete with Logic)",
    "explanation": "Allows the attacker to inject SQL that bypasses the `AND active = 0` logic, deleting active or unintended accounts."
  },
  {
    "id": 2480,
    "code": "const user_id = req.query.id;\nconst query = `DELETE FROM accounts WHERE user_id = ? AND active = 0`;\ndb.query(query, [user_id]);",
    "label": "secure",
    "vulnerability_type": "SQL Injection (Delete with Logic)",
    "explanation": "Uses a parameterized query, ensuring the attacker cannot inject commands or logic into the `user_id` position."
  },
  {
    "id": 2481,
    "code": "const script = req.query.code;\nrequire('vm').runInNewContext(script);",
    "label": "insecure",
    "vulnerability_type": "Code Injection (VM)",
    "explanation": "Executing arbitrary user-supplied code, even in a VM context, is extremely dangerous and can often be bypassed to gain host RCE."
  },
  {
    "id": 2482,
    "code": "const script = req.query.code;\n// Use strict sandboxing and content filtering\nconst sandbox = { result: null };\nconst safeCode = `result = ${script.replace(/[;]/g, '')}`; // Simple sanitization\nrequire('vm').runInNewContext(safeCode, sandbox, { timeout: 100 });",
    "label": "secure",
    "vulnerability_type": "Code Injection (VM)",
    "explanation": "Implements strict runtime limits (`timeout: 100`) and sandboxing, treating the `vm` module as dangerous and imposing input limits/checks."
  },
  {
    "id": 2483,
    "code": "const filename = req.query.name;\nres.sendFile(filename);",
    "label": "insecure",
    "vulnerability_type": "Path Traversal (Root)",
    "explanation": "No base directory is specified for `res.sendFile`, allowing the attacker to traverse the entire filesystem from the process root."
  },
  {
    "id": 2484,
    "code": "const filename = path.basename(req.query.name);\nres.sendFile(path.join(__dirname, 'uploads', filename));",
    "label": "secure",
    "vulnerability_type": "Path Traversal (Root)",
    "explanation": "Uses the secure `path.join` and a dedicated `__dirname` base directory, combined with `path.basename` to lock the file access."
  },
  {
    "id": 2485,
    "code": "const url = new URL(req.query.target);\nconst response = await fetch(url);",
    "label": "insecure",
    "vulnerability_type": "SSRF (Unvalidated URL)",
    "explanation": "Allows fetching of an arbitrary URL, potentially targeting internal services (SSRF)."
  },
  {
    "id": 2486,
    "code": "const target = req.query.target;\nif (target.startsWith('http://localhost') || target.startsWith('http://127.0.0.1')) {\n  return res.status(403).send();\n}\nconst response = await fetch(target);",
    "label": "secure",
    "vulnerability_type": "SSRF (Unvalidated URL)",
    "explanation": "Implements a strict block on known local loopback URLs to mitigate basic SSRF attacks."
  },
  {
    "id": 2487,
    "code": "const token = jwt.sign({ data: 'test' }, process.env.SECRET, { issuer: req.query.iss });",
    "label": "insecure",
    "vulnerability_type": "JWT Misconfiguration (Unvalidated Issuer)",
    "explanation": "Allows a user to set the token's `issuer` property, which can be misused during token verification if the verifier relies on this field."
  },
  {
    "id": 2488,
    "code": "const token = jwt.sign({ data: 'test' }, process.env.SECRET, { issuer: 'MyApp' });",
    "label": "secure",
    "vulnerability_type": "JWT Misconfiguration (Unvalidated Issuer)",
    "explanation": "The token's issuer is explicitly hardcoded to a known, safe value, ensuring the property cannot be forged by the user."
  },
  {
    "id": 2489,
    "code": "const hash = crypto.createHash('md4').update(password).digest('hex');",
    "label": "insecure",
    "vulnerability_type": "Weak Cryptography (MD4)",
    "explanation": "Uses the severely outdated and cryptographically broken MD4 hashing algorithm."
  },
  {
    "id": 2490,
    "code": "const hash = crypto.createHash('sha3-512').update(password).digest('hex');",
    "label": "secure",
    "vulnerability_type": "Weak Cryptography (MD4)",
    "explanation": "Uses a modern, cryptographically strong and large hash algorithm (SHA3-512). (Best practice for passwords is still bcrypt/scrypt/argon2)."
  },
  {
    "id": 2491,
    "code": "res.header('X-Content-Type-Options', 'no-sniff');",
    "label": "insecure",
    "vulnerability_type": "Insecure Header (nosniff casing)",
    "explanation": "The header value is misspelled (`no-sniff` instead of `nosniff`), rendering the header ineffective and allowing content sniffing."
  },
  {
    "id": 2492,
    "code": "res.header('X-Content-Type-Options', 'nosniff');",
    "label": "secure",
    "vulnerability_type": "Insecure Header (nosniff casing)",
    "explanation": "The header value is correctly set to `nosniff`, preventing the browser from guessing the content type."
  },
  {
    "id": 2493,
    "code": "app.get('/log', (req, res) => {\n  fs.appendFileSync('log.txt', req.query.msg);\n});",
    "label": "insecure",
    "vulnerability_type": "Log Injection (File)",
    "explanation": "Injects raw user input into a local log file, which can be used to inject log forging entries or control file content."
  },
  {
    "id": 2494,
    "code": "app.get('/log', (req, res) => {\n  const safeMsg = req.query.msg.replace(/[^\\w\\s\\-]/g, '');\n  fs.appendFileSync('log.txt', `[${new Date().toISOString()}] ${safeMsg}\\n`);\n});",
    "label": "secure",
    "vulnerability_type": "Log Injection (File)",
    "explanation": "Sanitizes the input to a highly restrictive character set and prefixes the log entry with a trusted timestamp, making forging difficult."
  },
  {
    "id": 2495,
    "code": "const filename = req.query.file;\nconst content = req.query.data;\nfs.writeFileSync(filename, content);",
    "label": "insecure",
    "vulnerability_type": "Path Traversal (Uncontrolled Write)",
    "explanation": "Allows writing content to any file location specified by the user's `filename` parameter."
  },
  {
    "id": 2496,
    "code": "const filename = path.join('/tmp/data', path.basename(req.query.file));\nconst content = req.query.data;\nfs.writeFileSync(filename, content);",
    "label": "secure",
    "vulnerability_type": "Path Traversal (Uncontrolled Write)",
    "explanation": "Restricts the write operation to a dedicated, safe directory and sanitizes the filename using `path.basename`."
  },
  {
    "id": 2497,
    "code": "const value = req.query.input;\nres.send(`<div onclick=\"alert('${value}')\">Click me</div>`);",
    "label": "insecure",
    "vulnerability_type": "XSS (Client-Side JS Context)",
    "explanation": "Injects unescaped user input directly into a client-side JavaScript string context (`alert('')`), allowing script injection via quote-escaping."
  },
  {
    "id": 2498,
    "code": "const value = req.query.input;\nconst escapedValue = value.replace(/[']/g, '\\'');\nres.send(`<div onclick=\"alert('${escapedValue}')\">Click me</div>`);",
    "label": "secure",
    "vulnerability_type": "XSS (Client-Side JS Context)",
    "explanation": "Escapes characters that could break out of the JavaScript string context (e.g., single quotes) to prevent XSS."
  },
  {
    "id": 2499,
    "code": "const user_id = req.query.id;\nconst query = `UPDATE users SET last_login = NOW() WHERE id = ${user_id}`;",
    "label": "insecure",
    "vulnerability_type": "SQL Injection (Numeric Update)",
    "explanation": "The numeric ID is concatenated into the SQL query, vulnerable to injection if the input is not strictly numeric."
  },
  {
    "id": 2500,
    "code": "const user_id = req.query.id;\nconst query = `UPDATE users SET last_login = NOW() WHERE id = ?`;\ndb.query(query, [user_id]);",
    "label": "secure",
    "vulnerability_type": "SQL Injection (Numeric Update)",
    "explanation": "Uses a parameterized query for the numeric ID, ensuring it is safely passed to the database without execution risk."
  },
    {
      "id": 2501,
      "code": "const username = req.query.name;\nres.send(username + ' details:');",
      "label": "insecure",
      "vulnerability_type": "Cross-Site Scripting (XSS) - Reflected",
      "explanation": "Unescaped user input is reflected directly into the HTML response, enabling an XSS payload to be executed."
    },
    {
      "id": 2502,
      "code": "const username = encodeURIComponent(req.query.name);\nres.send(username + ' details:');",
      "label": "secure",
      "vulnerability_type": "Cross-Site Scripting (XSS) - Reflected",
      "explanation": "Uses `encodeURIComponent` to escape the user input, neutralizing any HTML or script tags."
    },
    {
      "id": 2503,
      "code": "const result = db.query(`SELECT * FROM products WHERE category = '${req.query.cat}'`);",
      "label": "insecure",
      "vulnerability_type": "SQL Injection (Filter)",
      "explanation": "Concatenates the category filter value into the SQL query, allowing injection via single quotes."
    },
    {
      "id": 2504,
      "code": "const result = db.query(`SELECT * FROM products WHERE category = ?`, [req.query.cat]);",
      "label": "secure",
      "vulnerability_type": "SQL Injection (Filter)",
      "explanation": "Uses a parameterized query, ensuring the category value is treated as data, not executable SQL code."
    },
    {
      "id": 2505,
      "code": "app.get('/exec', (req, res) => {\n  exec(req.query.cmd, (err, stdout) => res.send(stdout));\n});",
      "label": "insecure",
      "vulnerability_type": "Command Injection (Arbitrary)",
      "explanation": "Passes arbitrary user input directly to `exec`, which spawns a shell and enables remote code execution."
    },
    {
      "id": 2506,
      "code": "app.get('/exec', (req, res) => {\n  res.status(403).send('Command execution is not allowed.');\n});",
      "label": "secure",
      "vulnerability_type": "Command Injection (Arbitrary)",
      "explanation": "Removes the dangerous command execution functionality entirely, the strongest possible defense."
    },
    {
      "id": 2507,
      "code": "res.set('Content-Type', 'text/html');\nres.send(req.query.data);",
      "label": "insecure",
      "vulnerability_type": "Content Spoofing / XSS",
      "explanation": "Sends raw user input with a `text/html` content type, making the application vulnerable to both XSS and content spoofing."
    },
    {
      "id": 2508,
      "code": "res.set('Content-Type', 'text/plain');\nres.send(req.query.data);",
      "label": "secure",
      "vulnerability_type": "Content Spoofing / XSS",
      "explanation": "Sets the `Content-Type` to `text/plain`, preventing the browser from parsing the reflected input as HTML or script."
    },
    {
      "id": 2509,
      "code": "const result = Buffer.from(req.query.data, 'base64').toString('utf8');",
      "label": "insecure",
      "vulnerability_type": "DoS (Buffer Allocation)",
      "explanation": "Allows a client to submit an extremely long Base64 string, causing the server to allocate a large buffer and potentially crash (DoS)."
    },
    {
      "id": 2510,
      "code": "const data = req.query.data;\nif (data.length > 1024 * 5) return res.status(413).send();\nconst result = Buffer.from(data, 'base64').toString('utf8');",
      "label": "secure",
      "vulnerability_type": "DoS (Buffer Allocation)",
      "explanation": "Implements an explicit size check on the input string to prevent large memory allocations, mitigating the DoS risk."
    },
    {
      "id": 2511,
      "code": "const user = JSON.parse(req.body.profile);\ndb.update(user);",
      "label": "insecure",
      "vulnerability_type": "Mass Assignment (Deserialization)",
      "explanation": "Deserializes an entire user profile object from the client and saves it directly, enabling the client to inject fields like `isAdmin: true`."
    },
    {
      "id": 2512,
      "code": "const { name, email } = JSON.parse(req.body.profile);\ndb.update({ id: req.user.id, name, email });",
      "label": "secure",
      "vulnerability_type": "Mass Assignment (Deserialization)",
      "explanation": "Uses explicit field whitelisting (`name`, `email`) on the deserialized object and uses the trusted session ID for the update."
    },
    {
      "id": 2513,
      "code": "app.get('/redirect', (req, res) => {\n  res.redirect(req.query.dest || '/home');\n});",
      "label": "insecure",
      "vulnerability_type": "Open Redirect (Default Path)",
      "explanation": "Redirects to an arbitrary user-supplied destination, enabling phishing attacks, even if a default is provided."
    },
    {
      "id": 2514,
      "code": "app.get('/redirect', (req, res) => {\n  const dest = req.query.dest;\n  if (dest && dest.startsWith('/')) {\n    res.redirect(dest);\n  } else {\n    res.redirect('/home');\n  }\n});",
      "label": "secure",
      "vulnerability_type": "Open Redirect (Default Path)",
      "explanation": "Validates the destination path to ensure it is a safe, relative path beginning with `/`, preventing redirects to external domains."
    },
    {
      "id": 2515,
      "code": "const key = req.query.key;\nconst iv = 'AABBCCTT';\nconst cipher = crypto.createCipheriv('aes-128-cbc', key, iv);",
      "label": "insecure",
      "vulnerability_type": "Weak Cryptography (Fixed IV)",
      "explanation": "Uses a fixed, hardcoded Initialization Vector (IV) (`'AABBCCTT'`). IVs must be unique and unpredictable to prevent certain cryptographic attacks."
    },
    {
      "id": 2516,
      "code": "const key = req.query.key;\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-gcm', key, iv);",
      "label": "secure",
      "vulnerability_type": "Weak Cryptography (Fixed IV)",
      "explanation": "Uses a cryptographically secure random IV generated for each encryption and a stronger algorithm (`aes-256-gcm`)."
    },
    {
      "id": 2517,
      "code": "const filename = req.query.name;\nexecFile('cat', [filename], (err, stdout) => res.send(stdout));",
      "label": "insecure",
      "vulnerability_type": "Path Traversal (ExecFile)",
      "explanation": "Even with `execFile`, if `filename` contains `../` sequences, it can still read unauthorized files outside the intended scope."
    },
    {
      "id": 2518,
      "code": "const filename = path.join('/app/logs', path.basename(req.query.name));\nexecFile('cat', [filename], (err, stdout) => res.send(stdout));",
      "label": "secure",
      "vulnerability_type": "Path Traversal (ExecFile)",
      "explanation": "Combines a safe base directory with `path.basename` to ensure the file read operation is restricted to the logs directory."
    },
    {
      "id": 2519,
      "code": "res.header('X-Content-Type-Options', 'no-sniff');",
      "label": "insecure",
      "vulnerability_type": "Missing Security Header (Clickjacking)",
      "explanation": "Missing the `X-Frame-Options` header, leaving the application vulnerable to clickjacking attacks."
    },
    {
      "id": 2520,
      "code": "res.header('X-Content-Type-Options', 'nosniff');\nres.header('X-Frame-Options', 'DENY');",
      "label": "secure",
      "vulnerability_type": "Missing Security Header (Clickjacking)",
      "explanation": "Adds the `X-Frame-Options: DENY` header, preventing the page from being embedded in a malicious frame."
    },
    {
      "id": 2521,
      "code": "const data = req.body.data;\nconst result = Buffer.from(data, 'base64');",
      "label": "insecure",
      "vulnerability_type": "DoS (Buffer Limit)",
      "explanation": "The buffer creation function lacks a size limit, potentially causing the server to exhaust memory when processing a large request body (DoS)."
    },
    {
      "id": 2522,
      "code": "const data = req.body.data;\nif (data.length > 1024 * 10) return res.status(413).send();\nconst result = Buffer.from(data, 'base64');",
      "label": "secure",
      "vulnerability_type": "DoS (Buffer Limit)",
      "explanation": "Enforces a strict length check on the request body data before allowing the memory-intensive buffer allocation."
    },
    {
      "id": 2523,
      "code": "const query = `SELECT ${req.query.col} FROM reports`;",
      "label": "insecure",
      "vulnerability_type": "SQL Injection (Unsafe Column)",
      "explanation": "The column name in the `SELECT` statement is concatenated from unsanitized user input, allowing injection."
    },
    {
      "id": 2524,
      "code": "const column = ['title', 'date', 'author'].includes(req.query.col) ? req.query.col : 'title';\nconst query = `SELECT ${column} FROM reports`;",
      "label": "secure",
      "vulnerability_type": "SQL Injection (Unsafe Column)",
      "explanation": "Uses a strict whitelist to validate the requested column name, ensuring only safe columns are used in the query."
    },
    {
      "id": 2525,
      "code": "app.get('/page', (req, res) => {\n  res.set('Content-Type', req.query.type);\n  res.send('Content');\n});",
      "label": "insecure",
      "vulnerability_type": "Header Injection (Content-Type)",
      "explanation": "Allows a user to control the `Content-Type` header, which can be used to bypass security controls or perform reflected XSS."
    },
    {
      "id": 2526,
      "code": "app.get('/page', (req, res) => {\n  const safeType = ['text/html', 'application/json'].includes(req.query.type) ? req.query.type : 'text/html';\n  res.set('Content-Type', safeType);\n  res.send('Content');\n});",
      "label": "secure",
      "vulnerability_type": "Header Injection (Content-Type)",
      "explanation": "Validates the user-supplied content type against a strict whitelist of safe, allowed MIME types."
    },
    {
      "id": 2527,
      "code": "const html = `Welcome ${req.query.user}`;",
      "label": "insecure",
      "vulnerability_type": "XSS (Template Literal)",
      "explanation": "Using a template literal to embed unescaped user input directly into an HTML string is vulnerable to XSS."
    },
    {
      "id": 2528,
      "code": "const safeUser = validator.escape(req.query.user);\nconst html = `Welcome ${safeUser}`;",
      "label": "secure",
      "vulnerability_type": "XSS (Template Literal)",
      "explanation": "Escapes the user-supplied variable using a sanitizer before embedding it in the template literal."
    },
    {
      "id": 2529,
      "code": "const password = req.body.pass;\nconst hash = md5(password);",
      "label": "insecure",
      "vulnerability_type": "Weak Cryptography (MD5)",
      "explanation": "Uses the cryptographically broken MD5 hash algorithm, which is highly susceptible to collision and pre-computation attacks."
    },
    {
      "id": 2530,
      "code": "const password = req.body.pass;\nconst hash = bcrypt.hashSync(password, 12);",
      "label": "secure",
      "vulnerability_type": "Weak Cryptography (MD5)",
      "explanation": "Uses a dedicated, modern, and adaptive password hashing function (bcrypt) with a high work factor."
    },
    {
      "id": 2531,
      "code": "app.get('/report', (req, res) => {\n  res.download('/tmp/reports/' + req.query.id + '.pdf');\n});",
      "label": "insecure",
      "vulnerability_type": "Path Traversal (Download Fixed Extension)",
      "explanation": "Although the extension is fixed, `req.query.id` can still contain `../` sequences to traverse the file system."
    },
    {
      "id": 2532,
      "code": "app.get('/report', (req, res) => {\n  const fileID = path.basename(req.query.id);\n  res.download(path.join('/tmp/reports/', fileID + '.pdf'));\n});",
      "label": "secure",
      "vulnerability_type": "Path Traversal (Download Fixed Extension)",
      "explanation": "Uses `path.basename` to sanitize the user-supplied file ID, preventing directory traversal."
    },
    {
      "id": 2533,
      "code": "const key = req.query.key;\nconst query = `SELECT value FROM settings WHERE key = '${key}'`;",
      "label": "insecure",
      "vulnerability_type": "SQL Injection (Simple Filter)",
      "explanation": "Simple string concatenation of user input into a SQL query string allows attackers to inject malicious code."
    },
    {
      "id": 2534,
      "code": "const key = req.query.key;\nconst query = `SELECT value FROM settings WHERE key = ?`;\ndb.query(query, [key]);",
      "label": "secure",
      "vulnerability_type": "SQL Injection (Simple Filter)",
      "explanation": "Uses a parameterized query for the filter key, ensuring the input is safely handled by the database driver."
    },
    {
      "id": 2535,
      "code": "app.use(express.static('./assets'));",
      "label": "insecure",
      "vulnerability_type": "Static File Exposure (Directory Traversal)",
      "explanation": "Serving static files without explicit configuration allows for path traversal if the web server handles URLs poorly."
    },
    {
      "id": 2536,
      "code": "app.use(express.static(path.join(__dirname, 'assets'), { dotfiles: 'ignore' }));",
      "label": "secure",
      "vulnerability_type": "Static File Exposure (Directory Traversal)",
      "explanation": "Uses `path.join` for safe directory construction and includes options to ignore hidden files (`dotfiles: 'ignore'`), minimizing exposure."
    },
    {
      "id": 2537,
      "code": "const token = jwt.sign({ user: req.user.id }, process.env.SECRET, { noTimestamp: true });",
      "label": "insecure",
      "vulnerability_type": "JWT Misconfiguration (Missing Timestamp)",
      "explanation": "Omitting the timestamp (`iat`) and expiration (`exp`) fields prevents the server from validating the age of the token, allowing indefinite reuse."
    },
    {
      "id": 2538,
      "code": "const token = jwt.sign({ user: req.user.id }, process.env.SECRET, { expiresIn: '30m' });",
      "label": "secure",
      "vulnerability_type": "JWT Misconfiguration (Missing Timestamp)",
      "explanation": "Explicitly sets a short expiration time (`expiresIn: '30m'`), ensuring the token's validity window is limited."
    },
    {
      "id": 2539,
      "code": "app.use((req, res, next) => {\n  if (req.header('referer').includes('badsite.com')) {\n    return res.status(403).send('Blocked');\n  }\n  next();\n});",
      "label": "insecure",
      "vulnerability_type": "Security Bypass (Header Blacklist)",
      "explanation": "Relying on a blacklist check against the `Referer` header is easily bypassed by simply omitting the header."
    },
    {
      "id": 2540,
      "code": "app.use((req, res, next) => {\n  if (req.method === 'POST') {\n    // Use a robust defense like CSRF token check for state-changing requests\n  }\n  next();\n});",
      "label": "secure",
      "vulnerability_type": "Security Bypass (Header Blacklist)",
      "explanation": "Relies on robust security mechanisms like CSRF tokens for state-changing requests, rather than easily spoofed headers."
    },
    {
      "id": 2541,
      "code": "const user = JSON.parse(req.body.data);\nif (user.role === 'admin') { /* grant access */ }",
      "label": "insecure",
      "vulnerability_type": "Authorization Bypass (Client-Side Role)",
      "explanation": "The authorization decision is based entirely on a role property supplied by the client in the request body, allowing easy bypass."
    },
    {
      "id": 2542,
      "code": "const user = db.getById(req.session.userId);\nif (user.role === 'admin') { /* grant access */ }",
      "label": "secure",
      "vulnerability_type": "Authorization Bypass (Client-Side Role)",
      "explanation": "The authorization decision is based on a trusted role property retrieved from the secure session or database, ignoring client input."
    },
    {
      "id": 2543,
      "code": "const value = req.query.val;\ndocument.getElementById('status').innerText += value;",
      "label": "insecure",
      "vulnerability_type": "XSS (Client-Side InnerText)",
      "explanation": "While `innerText` is generally safe, combining it with potentially unsafe APIs or if the parent context is an event handler, it can still lead to XSS."
    },
    {
      "id": 2544,
      "code": "const value = req.query.val;\ndocument.getElementById('status').textContent += value;",
      "label": "secure",
      "vulnerability_type": "XSS (Client-Side InnerText)",
      "explanation": "Uses the safest DOM method, `textContent`, which guarantees the input is treated as literal text and is never parsed as HTML."
    },
    {
      "id": 2545,
      "code": "const user = req.params.user;\nconst query = `SELECT * FROM ${user}_logs`;",
      "label": "insecure",
      "vulnerability_type": "SQL Injection (Table Name)",
      "explanation": "The table name is dynamically constructed from unsanitized user input, allowing injection to query other tables."
    },
    {
      "id": 2546,
      "code": "const user = req.params.user.replace(/[^a-zA-Z0-9_]/g, '');\nconst query = `SELECT * FROM ${user}_logs`;",
      "label": "secure",
      "vulnerability_type": "SQL Injection (Table Name)",
      "explanation": "Sanitizes the table name input to allow only alphanumeric characters and underscores, preventing injection of malicious commands."
    },
    {
      "id": 2547,
      "code": "const key = req.query.key;\ndb.delete(key);",
      "label": "insecure",
      "vulnerability_type": "Insecure Direct Object Reference (IDOR) - Delete",
      "explanation": "Allows a user to specify any key for deletion without an authorization check against the current user's privileges."
    },
    {
      "id": 2548,
      "code": "const key = req.query.key;\ndb.delete(req.user.id + '_' + key);",
      "label": "secure",
      "vulnerability_type": "Insecure Direct Object Reference (IDOR) - Delete",
      "explanation": "Prefixes the user-supplied key with a trusted, authenticated user ID, scoping the deletion operation to only the current user's resources."
    },
    {
      "id": 2549,
      "code": "app.get('/api/v3', (req, res) => {\n  res.set('Content-Security-Policy', \"default-src 'self'\");\n  res.send('API');\n});",
      "label": "insecure",
      "vulnerability_type": "Missing Security Header (Referrer Policy)",
      "explanation": "Missing the `Referrer-Policy` header, which can leak sensitive URL information to external sites."
    },
    {
      "id": 2550,
      "code": "app.get('/api/v3', (req, res) => {\n  res.set('Content-Security-Policy', \"default-src 'self'\");\n  res.set('Referrer-Policy', 'same-origin');\n  res.send('API');\n});",
      "label": "secure",
      "vulnerability_type": "Missing Security Header (Referrer Policy)",
      "explanation": "Sets the `Referrer-Policy` to `same-origin` (or similar), restricting when the full URL is sent as a referrer, preventing sensitive data leakage."
    },
    {
      "id": 2551,
      "code": "const data = req.body.input;\nconst output = JSON.parse(data);",
      "label": "insecure",
      "vulnerability_type": "DoS (JSON Nesting)",
      "explanation": "Accepts arbitrarily deep JSON nesting, which can lead to a stack overflow or resource exhaustion during parsing (DoS)."
    },
    {
      "id": 2552,
      "code": "const data = req.body.input;\n// Use a library or custom logic to enforce max nesting depth.\nconst output = JSON.parse(data);",
      "label": "secure",
      "vulnerability_type": "DoS (JSON Nesting)",
      "explanation": "The secure approach involves using a JSON parser configured with a depth limit, preventing highly nested malicious payloads."
    },
    {
      "id": 2553,
      "code": "const user_id = req.query.id;\nif (user_id < 100) { db.query(`SELECT * FROM users WHERE id = ${user_id}`); }",
      "label": "insecure",
      "vulnerability_type": "SQL Injection (Insufficient Limit)",
      "explanation": "The check `user_id < 100` is a poor attempt at validation; the input is still concatenated and vulnerable to injection via logic like `' OR '1'='1`."
    },
    {
      "id": 2554,
      "code": "const user_id = parseInt(req.query.id, 10);\nif (user_id < 100 && user_id > 0) { db.query(`SELECT * FROM users WHERE id = ?`, [user_id]); }",
      "label": "secure",
      "vulnerability_type": "SQL Injection (Insufficient Limit)",
      "explanation": "Combines a type check (`parseInt`) with strong parameterization, eliminating the risk of SQL injection, regardless of the numeric value."
    },
    {
      "id": 2555,
      "code": "const redirectUrl = req.query.next;\nres.redirect(redirectUrl);",
      "label": "insecure",
      "vulnerability_type": "Open Redirect (Simple)",
      "explanation": "Directly redirects the user to a URL provided in the `next` parameter, enabling phishing."
    },
    {
      "id": 2556,
      "code": "const redirectUrl = req.query.next;\nif (redirectUrl && (new URL(redirectUrl).hostname === req.hostname)) {\n  res.redirect(redirectUrl);\n} else {\n  res.redirect('/');\n}",
      "label": "secure",
      "vulnerability_type": "Open Redirect (Simple)",
      "explanation": "Parses the URL and explicitly checks that the hostname matches the current application's hostname before redirecting."
    },
    {
      "id": 2557,
      "code": "app.get('/log', (req, res) => {\n  console.log('User Input: ' + req.query.data);\n  res.send('Logged');\n});",
      "label": "insecure",
      "vulnerability_type": "Log Injection (Console)",
      "explanation": "Printing raw user input to the console or logs can lead to log forging if the input contains newline characters."
    },
    {
      "id": 2558,
      "code": "app.get('/log', (req, res) => {\n  const safeData = req.query.data.replace(/[\\r\\n]/g, '\\\\n');\n  console.log(`User Input: ${safeData}`);\n  res.send('Logged');\n});",
      "label": "secure",
      "vulnerability_type": "Log Injection (Console)",
      "explanation": "Sanitizes the input by escaping or removing newline characters (`\\r`, `\\n`), preventing log entry manipulation."
    },
    {
      "id": 2559,
      "code": "const password = req.body.pass;\nconst hash = sha512(password);",
      "label": "insecure",
      "vulnerability_type": "Weak Cryptography (Missing Salt/Work Factor)",
      "explanation": "Using a fast, non-adaptive hash function (like SHA-512) for password storage is insecure because it lacks a random salt and work factor, making it vulnerable to GPU cracking."
    },
    {
      "id": 2560,
      "code": "const password = req.body.pass;\nconst hash = scryptSync(password, process.env.SALT, 64, { N: 16384 });",
      "label": "secure",
      "vulnerability_type": "Weak Cryptography (Missing Salt/Work Factor)",
      "explanation": "Uses a computationally expensive, modern, and adaptive function (like Scrypt or Argon2) with a high cost factor (`N`) and a unique salt for secure password hashing."
    },
    {
      "id": 2561,
      "code": "app.get('/view/:file', (req, res) => {\n  res.sendFile(req.params.file);\n});",
      "label": "insecure",
      "vulnerability_type": "Path Traversal (No Base Directory)",
      "explanation": "Sending a file based on an arbitrary path parameter without restricting the directory allows access to any file on the system (Root Traversal)."
    },
    {
      "id": 2562,
      "code": "app.get('/view/:file', (req, res) => {\n  const file = path.basename(req.params.file);\n  const fullPath = path.join(__dirname, 'views', file);\n  res.sendFile(fullPath);\n});",
      "label": "secure",
      "vulnerability_type": "Path Traversal (No Base Directory)",
      "explanation": "Enforces a strict base directory (`views`) using `path.join` and sanitizes the input with `path.basename`."
    },
    {
      "id": 2563,
      "code": "const user = req.body.user;\nconst query = `INSERT INTO users (username) VALUES ('${user}')`;",
      "label": "insecure",
      "vulnerability_type": "SQL Injection (INSERT String)",
      "explanation": "Concatenates user input into an INSERT query, which can be exploited to inject additional values or commands."
    },
    {
      "id": 2564,
      "code": "const user = req.body.user;\nconst query = `INSERT INTO users (username) VALUES (?)`;\ndb.query(query, [user]);",
      "label": "secure",
      "vulnerability_type": "SQL Injection (INSERT String)",
      "explanation": "Uses a parameterized query, ensuring the username is safely inserted as a literal string value."
    },
    {
      "id": 2565,
      "code": "app.get('/status', (req, res) => {\n  if (req.query.user === 'testuser') { res.send(process.env); }\n});",
      "label": "insecure",
      "vulnerability_type": "Information Leakage (Weak Check)",
      "explanation": "Exposes all environment variables based on a simple, hardcoded, unauthenticated check (`user === 'testuser'`)."
    },
    {
      "id": 2566,
      "code": "app.get('/status', authMiddleware, (req, res) => {\n  if (req.user.role === 'dev') {\n    res.send({ BUILD_VERSION: process.env.BUILD_VERSION });\n  }\n});",
      "label": "secure",
      "vulnerability_type": "Information Leakage (Weak Check)",
      "explanation": "Requires full authentication/authorization and exposes only a single, non-sensitive environment variable (`BUILD_VERSION`)."
    },
    {
      "id": 2567,
      "code": "app.post('/update', (req, res) => {\n  if (req.body.role) { db.updateRole(req.user.id, req.body.role); }\n  db.updateProfile(req.user.id, req.body);\n});",
      "label": "insecure",
      "vulnerability_type": "Mass Assignment (Conditional Logic)",
      "explanation": "The check `if (req.body.role)` is applied only to the `role` field; `db.updateProfile` still allows Mass Assignment of other sensitive fields."
    },
    {
      "id": 2568,
      "code": "app.post('/update', (req, res) => {\n  if (req.body.role && req.user.isAdmin) { db.updateRole(req.user.id, req.body.role); }\n  const safeBody = { name: req.body.name, email: req.body.email };\n  db.updateProfile(req.user.id, safeBody);\n});",
      "label": "secure",
      "vulnerability_type": "Mass Assignment (Conditional Logic)",
      "explanation": "Separates the sensitive role update logic with an authorization check and uses explicit whitelisting for the general profile update fields."
    },
    {
      "id": 2569,
      "code": "const password = req.body.pass;\nconst hash = crypto.pbkdf2Sync(password, 'fixed', 1000, 64, 'sha512');",
      "label": "insecure",
      "vulnerability_type": "Weak Cryptography (Fixed PBKDF2 Salt)",
      "explanation": "Uses a fixed, hardcoded salt (`'fixed'`) for PBKDF2, making the hash vulnerable to pre-computation attacks."
    },
    {
      "id": 2570,
      "code": "const password = req.body.pass;\nconst salt = crypto.randomBytes(16).toString('hex');\nconst hash = crypto.pbkdf2Sync(password, salt, 310000, 64, 'sha512');",
      "label": "secure",
      "vulnerability_type": "Weak Cryptography (Fixed PBKDF2 Salt)",
      "explanation": "Uses a cryptographically random salt, a higher iteration count (`310000`), and a strong algorithm, following current PBKDF2 best practices."
    },
    {
      "id": 2571,
      "code": "const date = new Date(req.query.date);\nif (date > new Date()) { /* invalid future date */ }",
      "label": "insecure",
      "vulnerability_type": "Date Parsing DoS",
      "explanation": "Passing arbitrary, complex strings to the `Date()` constructor can result in high CPU usage and denial of service."
    },
    {
      "id": 2572,
      "code": "const date = moment(req.query.date, 'YYYY-MM-DD', true);\nif (!date.isValid()) { return res.status(400).send(); }\nif (date > moment()) { /* invalid future date */ }",
      "label": "secure",
      "vulnerability_type": "Date Parsing DoS",
      "explanation": "Uses a dedicated library (e.g., Moment.js, Date-fns) for strict format parsing, which is faster and safer against ambiguous/complex date strings."
    },
    {
      "id": 2573,
      "code": "const input = req.query.data;\nconst result = 'Your input: ' + input;",
      "label": "insecure",
      "vulnerability_type": "Cross-Site Scripting (XSS) - Reflected",
      "explanation": "Directly concatenates unescaped user input into the response, vulnerable to XSS."
    },
    {
      "id": 2574,
      "code": "const input = req.query.data;\nconst result = 'Your input: ' + validator.escape(input);",
      "label": "secure",
      "vulnerability_type": "Cross-Site Scripting (XSS) - Reflected",
      "explanation": "Uses a dedicated sanitization function (`validator.escape`) to neutralize any HTML tags or script elements."
    },
    {
      "id": 2575,
      "code": "const sql = `SELECT * FROM ${req.query.table}`;",
      "label": "insecure",
      "vulnerability_type": "SQL Injection (Unsafe Table Name)",
      "explanation": "Allows the user to specify the table name, leading to injection or unauthorized access to other tables."
    },
    {
      "id": 2576,
      "code": "const table = ['users', 'products', 'orders'].includes(req.query.table) ? req.query.table : 'products';\nconst sql = `SELECT * FROM ${table}`;",
      "label": "secure",
      "vulnerability_type": "SQL Injection (Unsafe Table Name)",
      "explanation": "The table name is strictly validated against a hardcoded whitelist of allowed table names."
    },
    {
      "id": 2577,
      "code": "app.get('/api', (req, res) => {\n  res.set('X-Content-Type-Options', 'no-sniff');\n  res.send('data');\n});",
      "label": "insecure",
      "vulnerability_type": "Misspelled Security Header",
      "explanation": "The header value is misspelled (`no-sniff` instead of `nosniff`), rendering the `X-Content-Type-Options` header ineffective."
    },
    {
      "id": 2578,
      "code": "app.get('/api', (req, res) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.send('data');\n});",
      "label": "secure",
      "vulnerability_type": "Misspelled Security Header",
      "explanation": "The header value is correctly spelled as `nosniff`, ensuring the browser adheres to the content-type declared by the server."
    },
    {
      "id": 2579,
      "code": "const dir = req.query.dir;\nexec(`tar -czvf /tmp/archive.tar.gz ${dir}`, (err, stdout) => res.send(stdout));",
      "label": "insecure",
      "vulnerability_type": "Command Injection (Shell Concatenation)",
      "explanation": "Concatenates unvalidated user input (`dir`) into a shell command, allowing the attacker to inject commands via shell metacharacters."
    },
    {
      "id": 2580,
      "code": "const dir = req.query.dir;\nconst safeDir = dir.replace(/[^\\w\\-./]/g, '');\nexecFile('tar', ['-czvf', '/tmp/archive.tar.gz', safeDir], (err, stdout) => res.send(stdout));",
      "label": "secure",
      "vulnerability_type": "Command Injection (Shell Concatenation)",
      "explanation": "Sanitizes the input and uses `execFile` (bypasses shell) to execute the command with the directory name as a safe, literal argument."
    },
    {
      "id": 2581,
      "code": "if (req.query.user_id === '0') { db.delete(req.query.user_id); }",
      "label": "insecure",
      "vulnerability_type": "Weak Comparison (String vs Number)",
      "explanation": "A pattern that often leads to type juggling/coercion vulnerabilities if not careful (e.g., '0' == 0 is true)."
    },
    {
      "id": 2582,
      "code": "const userId = parseInt(req.query.user_id, 10);\nif (userId === 0) { db.delete(userId); }",
      "label": "secure",
      "vulnerability_type": "Weak Comparison (String vs Number)",
      "explanation": "Explicitly converts the input to an integer (`parseInt`) and uses strict equality (`===`), eliminating type coercion risks."
    },
    {
      "id": 2583,
      "code": "const file = req.query.path;\nconst content = fs.readFileSync(file, 'utf8');",
      "label": "insecure",
      "vulnerability_type": "Path Traversal (No Path Sanitization)",
      "explanation": "Allows reading of arbitrary files via directory traversal sequences in the `path` parameter."
    },
    {
      "id": 2584,
      "code": "const file = path.normalize(req.query.path);\nif (!file.startsWith('/app/data')) return res.status(403).send();\nconst content = fs.readFileSync(file, 'utf8');",
      "label": "secure",
      "vulnerability_type": "Path Traversal (No Path Sanitization)",
      "explanation": "Normalizes the path and then enforces a boundary check (`startsWith('/app/data')`) to ensure the file is within an approved directory."
    },
    {
      "id": 2585,
      "code": "const payload = '{\"id\": 1, \"user\": \"' + req.query.name + '\"}';\nconst token = jwt.sign(payload, process.env.SECRET);",
      "label": "insecure",
      "vulnerability_type": "JWT Misconfiguration (String Payload)",
      "explanation": "The payload is constructed as a JSON string, then signed. JWT libraries expect an object, and passing a string can lead to unexpected verification logic."
    },
    {
      "id": 2586,
      "code": "const payload = { id: 1, user: req.query.name };\nconst token = jwt.sign(payload, process.env.SECRET);",
      "label": "secure",
      "vulnerability_type": "JWT Misconfiguration (String Payload)",
      "explanation": "The payload is constructed as a proper JavaScript object, which is the expected type for the JWT signing function."
    },
    {
      "id": 2587,
      "code": "app.get('/api', (req, res) => {\n  res.set('Content-Type', 'text/html');\n  res.send(`<h1>${req.query.title}</h1>`);\n});",
      "label": "insecure",
      "vulnerability_type": "Cross-Site Scripting (Reflected H1)",
      "explanation": "Reflecting the user-supplied `title` into an HTML tag without escaping allows XSS."
    },
    {
      "id": 2588,
      "code": "app.get('/api', (req, res) => {\n  res.set('Content-Type', 'text/html');\n  res.send(`<h1>${validator.escape(req.query.title)}</h1>`);\n});",
      "label": "secure",
      "vulnerability_type": "Cross-Site Scripting (Reflected H1)",
      "explanation": "Uses HTML entity escaping on the title input before it's embedded in the HTML response."
    },
    {
      "id": 2589,
      "code": "const input = req.query.data;\nconst result = eval(input);",
      "label": "insecure",
      "vulnerability_type": "Code Injection (Eval)",
      "explanation": "Executes arbitrary, unvalidated code received from the user, leading to immediate remote code execution."
    },
    {
      "id": 2590,
      "code": "const input = req.query.data;\n// Functionality removed\nres.status(403).send('Code execution forbidden');",
      "label": "secure",
      "vulnerability_type": "Code Injection (Eval)",
      "explanation": "Removes the dangerous `eval()` function, eliminating the code injection vulnerability."
    },
    {
      "id": 2591,
      "code": "const sql = 'SELECT * FROM users WHERE status = 1' + req.query.filter;",
      "label": "insecure",
      "vulnerability_type": "SQL Injection (Appended Filter)",
      "explanation": "Appends an entire user-supplied filter string to the end of the query, allowing complex injection of `UNION SELECT` or logic bypasses."
    },
    {
      "id": 2592,
      "code": "let sql = 'SELECT * FROM users WHERE status = 1';\nconst filter = req.query.filter;\nif (['active', 'guest'].includes(filter)) {\n  sql += ` AND role = '${filter}'`;\n}\ndb.query(sql);",
      "label": "secure",
      "vulnerability_type": "SQL Injection (Appended Filter)",
      "explanation": "The appended filter logic is built using a strict whitelist of safe, known string values, mitigating injection."
    },
    {
      "id": 2593,
      "code": "const username = req.body.username;\nif (username.length > 0) { /* login */ }",
      "label": "insecure",
      "vulnerability_type": "Insufficient Validation (Length Check Only)",
      "explanation": "A length check alone is insufficient; it allows dangerous characters, scripts, or very long inputs that can still crash downstream systems."
    },
    {
      "id": 2594,
      "code": "const username = req.body.username;\nif (validator.isAlphanumeric(username) && username.length > 5) { /* login */ }",
      "label": "secure",
      "vulnerability_type": "Insufficient Validation (Length Check Only)",
      "explanation": "Combines a length check with strict character set validation (`isAlphanumeric`), ensuring the input is safe and meets minimum complexity requirements."
    },
    {
      "id": 2595,
      "code": "app.get('/img', (req, res) => {\n  res.sendFile(req.query.path);\n});",
      "label": "insecure",
      "vulnerability_type": "Path Traversal (Arbitrary Path)",
      "explanation": "Allows a user to request any file on the system via the `path` query parameter (File System Traversal)."
    },
    {
      "id": 2596,
      "code": "app.get('/img', (req, res) => {\n  const filename = path.basename(req.query.path);\n  res.sendFile(path.join(__dirname, 'images', filename));\n});",
      "label": "secure",
      "vulnerability_type": "Path Traversal (Arbitrary Path)",
      "explanation": "The file request is restricted to the `images` subdirectory, and the filename is sanitized using `path.basename`."
    },
    {
      "id": 2597,
      "code": "const key = req.query.key;\nconst value = req.query.val;\nredis.hset('data', key, value);",
      "label": "insecure",
      "vulnerability_type": "Injection (Redis - No Sanitization)",
      "explanation": "If the Redis driver is vulnerable or the data contains command injection sequences, the key/value insertion is insecure."
    },
    {
      "id": 2598,
      "code": "const key = req.query.key.replace(/[\\r\\n]/g, '');\nconst value = req.query.val;\nredis.hset('data', key, value);",
      "label": "secure",
      "vulnerability_type": "Injection (Redis - No Sanitization)",
      "explanation": "The key is sanitized to remove newline characters, which are a common injection vector in line-based protocols like Redis."
    },
    {
      "id": 2599,
      "code": "res.status(404).send('Page not found: ' + req.url);",
      "label": "insecure",
      "vulnerability_type": "Information Leakage (URL Reflection)",
      "explanation": "Reflecting the full requested URL in an error message can reveal sensitive query parameters or internal path structures."
    },
    {
      "id": 2600,
      "code": "res.status(404).send('Page not found. Reference ID: ' + Math.random().toString(36).substring(7));",
      "label": "secure",
      "vulnerability_type": "Information Leakage (URL Reflection)",
      "explanation": "Replaces the reflected URL with a generic error message and a unique, non-sensitive reference ID for internal logging."
    },
      {
        "id": 2601,
        "code": "const data = req.body.input;\nconst output = new Function(data);",
        "label": "insecure",
        "vulnerability_type": "Code Injection (new Function)",
        "explanation": "The `new Function()` constructor executes arbitrary JavaScript code passed as a string, leading to remote code execution."
      },
      {
        "id": 2602,
        "code": "const data = req.body.input;\n// Custom input processing that avoids code execution\nconst output = data.toUpperCase();",
        "label": "secure",
        "vulnerability_type": "Code Injection (new Function)",
        "explanation": "Avoids all dangerous execution primitives like `new Function()`, relying only on safe string manipulation methods."
      },
      {
        "id": 2603,
        "code": "const sql = `SELECT * FROM items WHERE price < ${req.query.max}`;",
        "label": "insecure",
        "vulnerability_type": "SQL Injection (Numeric Price)",
        "explanation": "Concatenates a user-supplied numeric value directly into the SQL query, which can be exploited by passing logic instead of a number."
      },
      {
        "id": 2604,
        "code": "const maxPrice = parseFloat(req.query.max);\nif (isNaN(maxPrice)) return res.status(400).send();\nconst sql = `SELECT * FROM items WHERE price < ?`;\ndb.query(sql, [maxPrice]);",
        "label": "secure",
        "vulnerability_type": "SQL Injection (Numeric Price)",
        "explanation": "Validates the input as a floating-point number and uses parameterized queries for safe inclusion in the SQL."
      },
      {
        "id": 2605,
        "code": "const content = req.query.msg;\nres.send(`<script>var msg = '${content}';</script>`);",
        "label": "insecure",
        "vulnerability_type": "XSS (Client-Side JS Context)",
        "explanation": "Injects unescaped user input into a client-side JavaScript string, allowing the attacker to break out of the string context with a single quote."
      },
      {
        "id": 2606,
        "code": "const content = req.query.msg;\nconst safeContent = JSON.stringify(content);\nres.send(`<script>var msg = ${safeContent};</script>`);",
        "label": "secure",
        "vulnerability_type": "XSS (Client-Side JS Context)",
        "explanation": "Uses `JSON.stringify` to safely encode the string for use within a JavaScript context, escaping quotes and backslashes correctly."
      },
      {
        "id": 2607,
        "code": "const password = req.body.pass;\nconst hash = await argon2.hash(password);",
        "label": "insecure",
        "vulnerability_type": "Weak Cryptography (Missing Argon2 Options)",
        "explanation": "Using Argon2 without explicitly setting parameters (memory, threads, iterations) relies on potentially weak library defaults."
      },
      {
        "id": 2608,
        "code": "const password = req.body.pass;\nconst hash = await argon2.hash(password, { type: argon2.argon2id, memoryCost: 65536, timeCost: 4, parallelism: 1 });",
        "label": "secure",
        "vulnerability_type": "Weak Cryptography (Missing Argon2 Options)",
        "explanation": "Explicitly configures Argon2 with recommended, high-cost, memory-hard parameters (`argon2id`, high `memoryCost`) for maximum security."
      },
      {
        "id": 2609,
        "code": "app.use(helmet.frameguard({ action: 'sameorigin' }));",
        "label": "insecure",
        "vulnerability_type": "Missing Security Header (HSTS)",
        "explanation": "Missing the `Strict-Transport-Security` (HSTS) header, which is critical for enforcing HTTPS connections after the first visit."
      },
      {
        "id": 2610,
        "code": "app.use(helmet.frameguard({ action: 'sameorigin' }));\napp.use(helmet.hsts({ maxAge: 31536000, includeSubDomains: true, preload: true }));",
        "label": "secure",
        "vulnerability_type": "Missing Security Header (HSTS)",
        "explanation": "Adds the HSTS header with a long `maxAge` and `preload` flag, instructing browsers to strictly enforce HTTPS."
      },
      {
        "id": 2611,
        "code": "const file = req.query.name;\nexec(`rm ${file}`, (err, stdout) => res.send(stdout));",
        "label": "insecure",
        "vulnerability_type": "Command Injection (Delete File)",
        "explanation": "Allows arbitrary file deletion via shell command injection, as the user input is unsanitized."
      },
      {
        "id": 2612,
        "code": "const file = path.join('/tmp/files', path.basename(req.query.name));\nexecFile('rm', [file], (err, stdout) => res.send(stdout));",
        "label": "secure",
        "vulnerability_type": "Command Injection (Delete File)",
        "explanation": "Restricts the file path to a safe directory and uses `execFile` to prevent shell metacharacter injection."
      },
      {
        "id": 2613,
        "code": "const user = db.findOne({ name: req.query.name });\nif (user) { res.json(user); }",
        "label": "insecure",
        "vulnerability_type": "Information Leakage (Full User Object)",
        "explanation": "Retrieves and exposes the entire user object (including potential sensitive fields) based only on a username lookup."
      },
      {
        "id": 2614,
        "code": "const user = db.findOne({ name: req.query.name });\nif (user) { res.json({ id: user.id, name: user.name, public_bio: user.public_bio }); }",
        "label": "secure",
        "vulnerability_type": "Information Leakage (Full User Object)",
        "explanation": "Uses whitelisting to expose only public-facing fields of the user object."
      },
      {
        "id": 2615,
        "code": "const data = req.body.xml;\nconst result = libxmljs.parseXml(data);",
        "label": "insecure",
        "vulnerability_type": "XML External Entity (XXE) - LibXMLjs",
        "explanation": "The default configuration of many XML parsers allows external entity resolution, enabling XXE attacks."
      },
      {
        "id": 2616,
        "code": "const data = req.body.xml;\nconst result = libxmljs.parseXml(data, { noent: true, noblanks: true });",
        "label": "secure",
        "vulnerability_type": "XML External Entity (XXE) - LibXMLjs",
        "explanation": "Configures the parser to disable external entity loading (`noent: true`), mitigating XXE attacks."
      },
      {
        "id": 2617,
        "code": "app.get('/search', (req, res) => {\n  const results = db.search(req.query.q);\n  res.json(results);\n});",
        "label": "insecure",
        "vulnerability_type": "Insecure Search Logic (DoS)",
        "explanation": "A simple search query without limits or indexing hints can lead to severe performance degradation and Denial of Service."
      },
      {
        "id": 2618,
        "code": "app.get('/search', (req, res) => {\n  const query = req.query.q.substring(0, 50);\n  const results = db.search(query, { limit: 20, timeout: 500 });\n  res.json(results);\n});",
        "label": "secure",
        "vulnerability_type": "Insecure Search Logic (DoS)",
        "explanation": "Implements strict limits on the query length and database execution time, preventing search-related resource exhaustion."
      },
      {
        "id": 2619,
        "code": "res.set('Content-Security-Policy', `default-src 'self' ${req.query.cdn}`);",
        "label": "insecure",
        "vulnerability_type": "CSP Injection",
        "explanation": "Allows a user to inject an arbitrary domain into the Content Security Policy, which can be used to bypass CSP and load malicious scripts from external sources."
      },
      {
        "id": 2620,
        "code": "const cdn = ['https://trusted.cdn.com', 'https://safe.cdn.net'].includes(req.query.cdn) ? req.query.cdn : '';\nres.set('Content-Security-Policy', `default-src 'self'; script-src 'self' ${cdn};`);",
        "label": "secure",
        "vulnerability_type": "CSP Injection",
        "explanation": "Validates the user-supplied CDN URL against a strict whitelist before including it in the Content Security Policy."
      },
      {
        "id": 2621,
        "code": "const token = req.query.jwt;\nconst user = jwt.decode(token);",
        "label": "insecure",
        "vulnerability_type": "JWT Misuse (Unverified Decode)",
        "explanation": "Uses `jwt.decode` instead of `jwt.verify` to read a token. Decoding does not check the signature, allowing an attacker to read data from a forged token."
      },
      {
        "id": 2622,
        "code": "const token = req.query.jwt;\nconst user = jwt.verify(token, process.env.SECRET);",
        "label": "secure",
        "vulnerability_type": "JWT Misuse (Unverified Decode)",
        "explanation": "Uses `jwt.verify`, which checks the token's signature, expiration, and integrity before returning the payload."
      },
      {
        "id": 2623,
        "code": "const data = req.query.data;\ndocument.body.outerHTML += data;",
        "label": "insecure",
        "vulnerability_type": "DOM-based XSS (OuterHTML)",
        "explanation": "Setting `outerHTML` with unsanitized input is a critical XSS vulnerability, allowing the attacker to replace the entire document body."
      },
      {
        "id": 2624,
        "code": "const data = req.query.data;\ndocument.body.append(document.createTextNode(data));",
        "label": "secure",
        "vulnerability_type": "DOM-based XSS (OuterHTML)",
        "explanation": "Creates a text node from the user input and appends it to the DOM, ensuring the input is treated as text and never as HTML."
      },
      {
        "id": 2625,
        "code": "const ip = req.query.ip;\nconst query = `INSERT INTO logs (ip) VALUES ('${ip}')`;",
        "label": "insecure",
        "vulnerability_type": "SQL Injection (IP Address)",
        "explanation": "Treating an IP address as a string to be concatenated into an SQL query allows injection if the input is not strictly validated."
      },
      {
        "id": 2626,
        "code": "const ip = req.query.ip;\nif (!validator.isIP(ip)) return res.status(400).send();\nconst query = `INSERT INTO logs (ip) VALUES (?)`;\ndb.query(query, [ip]);",
        "label": "secure",
        "vulnerability_type": "SQL Injection (IP Address)",
        "explanation": "Validates the input using a robust IP address checker and uses parameterized queries for safe insertion."
      },
      {
        "id": 2627,
        "code": "const content = req.query.c;\\nexec(`node -e \\\"${content}\\\"`, (err, stdout) => res.send(stdout));",
        "label": "insecure",
        "vulnerability_type": "Command Injection (Node Eval)",
        "explanation": "Passes user input into a shell command that executes the string as a Node.js script, leading to RCE."
      },
      {
        "id": 2628,
        "code": "const content = req.query.c;\n// Command execution disallowed\nres.status(403).send('Script execution forbidden');",
        "label": "secure",
        "vulnerability_type": "Command Injection (Node Eval)",
        "explanation": "Removes the dangerous shell execution functionality entirely."
      },
      {
        "id": 2629,
        "code": "res.cookie('token', token, { maxAge: 3600000 });",
        "label": "insecure",
        "vulnerability_type": "Missing Cookie Flags (Security)",
        "explanation": "Missing the `httpOnly`, `secure`, and `sameSite` flags, making the cookie vulnerable to XSS theft and CSRF attacks."
      },
      {
        "id": 2630,
        "code": "res.cookie('token', token, { maxAge: 3600000, httpOnly: true, secure: true, sameSite: 'strict' });",
        "label": "secure",
        "vulnerability_type": "Missing Cookie Flags (Security)",
        "explanation": "Includes all essential security flags for a session cookie: `httpOnly`, `secure`, and `sameSite: 'strict'`."
      },
      {
        "id": 2631,
        "code": "const dir = req.query.dir;\nfs.readdirSync(dir);",
        "label": "insecure",
        "vulnerability_type": "Path Traversal (Read Directory)",
        "explanation": "Allows a user to specify any directory path to read, which can lead to information disclosure or server blocking (DoS)."
      },
      {
        "id": 2632,
        "code": "const dir = path.join(__dirname, 'reports', path.basename(req.query.dir));\nfs.readdirSync(dir);",
        "label": "secure",
        "vulnerability_type": "Path Traversal (Read Directory)",
        "explanation": "Restricts directory reading to a safe, controlled base path using `__dirname` and `path.basename`."
      },
      {
        "id": 2633,
        "code": "const cipher = crypto.createDecipher('aes-128-ecb', 'fixedkey');",
        "label": "insecure",
        "vulnerability_type": "Weak Cryptography (AES-ECB)",
        "explanation": "Uses the insecure AES-ECB (Electronic Codebook) mode, which leaks pattern information about the plaintext due to deterministic encryption."
      },
      {
        "id": 2634,
        "code": "const cipher = crypto.createDecipheriv('aes-256-gcm', key, iv);",
        "label": "secure",
        "vulnerability_type": "Weak Cryptography (AES-ECB)",
        "explanation": "Uses the strong, modern AES-GCM (Galois/Counter Mode), which is recommended for authenticated encryption."
      },
      {
        "id": 2635,
        "code": "app.get('/api/data', (req, res) => {\n  res.set('Access-Control-Allow-Methods', 'GET, POST');\n  res.set('Access-Control-Allow-Headers', req.headers['access-control-request-headers']);\n  res.send('data');\n});",
        "label": "insecure",
        "vulnerability_type": "CORS Misconfiguration (Reflected Headers)",
        "explanation": "Reflects the client's requested headers directly into the `Access-Control-Allow-Headers` response, potentially allowing arbitrary headers to be passed, leading to security issues."
      },
      {
        "id": 2636,
        "code": "app.get('/api/data', (req, res) => {\n  res.set('Access-Control-Allow-Methods', 'GET, POST');\n  res.set('Access-Control-Allow-Headers', 'Content-Type, X-CSRF-Token');\n  res.send('data');\n});",
        "label": "secure",
        "vulnerability_type": "CORS Misconfiguration (Reflected Headers)",
        "explanation": "Uses a strict whitelist to explicitly define all allowed request headers, preventing reflection."
      },
      {
        "id": 2637,
        "code": "const result = db.query(`SELECT * FROM users WHERE active = ${req.query.status}`);",
        "label": "insecure",
        "vulnerability_type": "SQL Injection (Boolean Filter)",
        "explanation": "Concatenates a user-supplied boolean or numeric status directly, allowing injection or logic bypass."
      },
      {
        "id": 2638,
        "code": "const status = parseInt(req.query.status, 10);\nif (status !== 0 && status !== 1) return res.status(400).send();\nconst result = db.query(`SELECT * FROM users WHERE active = ?`, [status]);",
        "label": "secure",
        "vulnerability_type": "SQL Injection (Boolean Filter)",
        "explanation": "Validates the input to ensure it is a safe integer (0 or 1) and uses a parameterized query."
      },
      {
        "id": 2639,
        "code": "const data = req.query.d;\nconst result = btoa(data);",
        "label": "insecure",
        "vulnerability_type": "Weak Encoding (btoa)",
        "explanation": "Using client-side functions like `btoa()` or `atob()` on the server can lead to unexpected behavior with different character encodings and is generally a code smell."
      },
      {
        "id": 2640,
        "code": "const data = req.query.d;\nconst result = Buffer.from(data).toString('base64');",
        "label": "secure",
        "vulnerability_type": "Weak Encoding (btoa)",
        "explanation": "Uses the native Node.js `Buffer` API for all Base64 encoding/decoding, which provides consistent and safe handling of binary data."
      },
      {
        "id": 2641,
        "code": "const xml = req.body.data;\nconst result = DOMParser.parseFromString(xml, 'text/xml');",
        "label": "insecure",
        "vulnerability_type": "XML External Entity (XXE) - Standard Parser",
        "explanation": "The standard DOMParser might be vulnerable to XXE depending on the environment and how it's executed, especially when dealing with untrusted XML."
      },
      {
        "id": 2642,
        "code": "const xml = req.body.data;\n// Use a dedicated, secure XML library configured to disable external entities.\nconst result = safeXmlParser.parse(xml, { resolveEntities: false });",
        "label": "secure",
        "vulnerability_type": "XML External Entity (XXE) - Standard Parser",
        "explanation": "The secure approach is to use a library that explicitly disables entity resolution or to sanitize the XML before parsing."
      },
      {
        "id": 2643,
        "code": "app.post('/update', (req, res) => {\n  db.update(req.body);\n  res.send('ok');\n});",
        "label": "insecure",
        "vulnerability_type": "Mass Assignment (Update)",
        "explanation": "Passes the entire request body to the database update function, allowing attackers to modify fields they shouldn't (e.g., `role`, `salary`)."
      },
      {
        "id": 2644,
        "code": "app.post('/update', (req, res) => {\n  const safeData = { name: req.body.name, address: req.body.address };\n  db.update(safeData);\n  res.send('ok');\n});",
        "label": "secure",
        "vulnerability_type": "Mass Assignment (Update)",
        "explanation": "Uses whitelisting to explicitly select and update only the safe, permitted fields from the request body."
      },
      {
        "id": 2645,
        "code": "if (req.query.mode === 'debug') { console.log('DEBUG MODE ON'); }",
        "label": "insecure",
        "vulnerability_type": "Authorization Bypass (Unprotected Mode)",
        "explanation": "A simple query parameter enables a potentially privileged mode without any authentication or authorization check."
      },
      {
        "id": 2646,
        "code": "if (process.env.NODE_ENV !== 'production' && req.user.role === 'dev') {\n  if (req.query.mode === 'debug') { console.log('DEBUG MODE ON'); }\n}",
        "label": "secure",
        "vulnerability_type": "Authorization Bypass (Unprotected Mode)",
        "explanation": "The privileged mode is guarded by an environment check (`NODE_ENV`) and an authorization check (`req.user.role`)."
      },
      {
        "id": 2647,
        "code": "app.get('/file', (req, res) => {\n  fs.readFile(req.query.path, (err, data) => res.send(data));\n});",
        "label": "insecure",
        "vulnerability_type": "Path Traversal (Read Arbitrary)",
        "explanation": "Allows a user to read any file on the system via the `path` query parameter (File System Traversal)."
      },
      {
        "id": 2648,
        "code": "app.get('/file', (req, res) => {\n  const file = path.normalize(req.query.path);\n  if (file.includes('..')) return res.status(403).send();\n  fs.readFile(path.join(__dirname, 'uploads', file), (err, data) => res.send(data));\n});",
        "label": "secure",
        "vulnerability_type": "Path Traversal (Read Arbitrary)",
        "explanation": "Normalizes the path, implements a simple blacklist check (`includes('..')`), and restricts access to a non-critical subdirectory."
      },
      {
        "id": 2649,
        "code": "const username = req.body.user;\nconst password = req.body.pass;\nif (db.login(username, password)) { req.session.auth = true; }",
        "label": "insecure",
        "vulnerability_type": "Session Fixation (No Regeneration)",
        "explanation": "Does not regenerate the session ID after a successful login, leaving the session open to fixation attacks."
      },
      {
        "id": 2650,
        "code": "const username = req.body.user;\nconst password = req.body.pass;\nif (db.login(username, password)) {\n  req.session.regenerate(() => { req.session.auth = true; });\n}",
        "label": "secure",
        "vulnerability_type": "Session Fixation (No Regeneration)",
        "explanation": "Uses `req.session.regenerate()` immediately after authentication to issue a new session ID, mitigating fixation."
      },
      {
        "id": 2651,
        "code": "const data = req.query.url;\nres.send(`<a href=\"${data}\">Link</a>`);",
        "label": "insecure",
        "vulnerability_type": "XSS (HTML Attribute URL)",
        "explanation": "Injects an unescaped user-supplied URL into an HTML attribute, allowing XSS via protocols like `javascript:..."
      },
      {
        "id": 2652,
        "code": "const data = req.query.url;\nconst safeUrl = validator.isURL(data, { protocols: ['http', 'https'] }) ? data : '#';\nres.send(`<a href=\"${safeUrl}\">Link</a>`);",
        "label": "secure",
        "vulnerability_type": "XSS (HTML Attribute URL)",
        "explanation": "Uses a validation library to ensure the URL uses only safe protocols (`http`, `https`) before inserting it into the `href` attribute."
      },
      {
        "id": 2653,
        "code": "const user_id = req.query.id;\nconst query = `SELECT * FROM data WHERE user_id = ${user_id} AND active = 1`;",
        "label": "insecure",
        "vulnerability_type": "SQL Injection (Numeric ID Filter)",
        "explanation": "Concatenates the numeric ID, allowing an attacker to inject SQL via non-numeric input."
      },
      {
        "id": 2654,
        "code": "const user_id = parseInt(req.query.id, 10);\nif (isNaN(user_id)) return res.status(400).send();\nconst query = `SELECT * FROM data WHERE user_id = ? AND active = 1`;\ndb.query(query, [user_id]);",
        "label": "secure",
        "vulnerability_type": "SQL Injection (Numeric ID Filter)",
        "explanation": "Enforces type casting to integer and uses a parameterized query for the ID."
      },
      {
        "id": 2655,
        "code": "const cmd = 'start ' + req.query.program;\nrequire('child_process').exec(cmd);",
        "label": "insecure",
        "vulnerability_type": "Command Injection (Program Start)",
        "explanation": "Allows injection into the program name via shell metacharacters."
      },
      {
        "id": 2656,
        "code": "const program = req.query.program.replace(/[^\\w\\s]/g, '');\nrequire('child_process').execFile('start', [program]);",
        "label": "secure",
        "vulnerability_type": "Command Injection (Program Start)",
        "explanation": "Sanitizes the program name to a safe character set and uses `execFile` to bypass the shell."
      },
      {
        "id": 2657,
        "code": "res.set('Access-Control-Allow-Origin', req.headers.origin);",
        "label": "insecure",
        "vulnerability_type": "CORS Misconfiguration (Reflected Wildcard)",
        "explanation": "Reflects the origin header without validation, effectively allowing any domain to access authenticated resources if `credentials` are permitted."
      },
      {
        "id": 2658,
        "code": "const allowedOrigin = ['https://app.com', 'https://api.com'];\nconst origin = req.headers.origin;\nif (allowedOrigin.includes(origin)) {\n  res.set('Access-Control-Allow-Origin', origin);\n}",
        "label": "secure",
        "vulnerability_type": "CORS Misconfiguration (Reflected Wildcard)",
        "explanation": "Implements a strict whitelist check against a set of known, safe origins before reflecting the header."
      },
      {
        "id": 2659,
        "code": "const password = req.body.pass;\nconst salt = req.body.salt;\nconst hash = await bcrypt.hash(password, salt);",
        "label": "insecure",
        "vulnerability_type": "Weak Cryptography (Client-Side Salt)",
        "explanation": "Allows the client to supply the salt, defeating the purpose of server-side salting and enabling easier dictionary attacks."
      },
      {
        "id": 2660,
        "code": "const password = req.body.pass;\nconst hash = await bcrypt.hash(password, 10);",
        "label": "secure",
        "vulnerability_type": "Weak Cryptography (Client-Side Salt)",
        "explanation": "Uses the recommended bcrypt functionality where the salt is generated securely and randomly on the server."
      },
      {
        "id": 2661,
        "code": "app.get('/logs', (req, res) => {\n  const user = req.query.user;\n  if (user === 'admin') { res.send(db.connectionInfo); }\n  res.send('ok');\n});",
        "label": "insecure",
        "vulnerability_type": "Information Leakage (Weak Authentication)",
        "explanation": "A simple query parameter bypasses authentication to expose sensitive database connection details."
      },
      {
        "id": 2662,
        "code": "app.get('/logs', authMiddleware, (req, res) => {\n  if (req.user.role === 'admin') { res.send('ok'); }\n  res.status(403).send();\n});",
        "label": "secure",
        "vulnerability_type": "Information Leakage (Weak Authentication)",
        "explanation": "Enforces strong authentication and authorization via middleware and avoids exposing any sensitive information even to authorized users on a public endpoint."
      },
      {
        "id": 2663,
        "code": "const user = JSON.parse(req.body.data);\nif (user.active) { /* proceed */ }",
        "label": "insecure",
        "vulnerability_type": "Logic Bypass (Insecure Deserialization)",
        "explanation": "A pattern that can be vulnerable to logic bypass if the JSON parser allows malicious properties to be injected."
      },
      {
        "id": 2664,
        "code": "const user = JSON.parse(req.body.data, (key, value) => {\n  if (key === 'constructor') return undefined; return value;\n});\nif (user.active) { /* proceed */ }",
        "label": "secure",
        "vulnerability_type": "Logic Bypass (Insecure Deserialization)",
        "explanation": "Uses the JSON `reviver` function to prevent the deserialization of dangerous property names like `constructor`."
      },
      {
        "id": 2665,
        "code": "const value = req.query.v;\nconst result = 'Value is ' + value.toUpperCase();",
        "label": "insecure",
        "vulnerability_type": "Cross-Site Scripting (Reflected - Case Change)",
        "explanation": "Changing the case of the input doesn't prevent XSS; an attacker can still use case-insensitive HTML/JS attributes to inject scripts."
      },
      {
        "id": 2666,
        "code": "const value = req.query.v;\nconst result = 'Value is ' + validator.escape(value.toUpperCase());",
        "label": "secure",
        "vulnerability_type": "Cross-Site Scripting (Reflected - Case Change)",
        "explanation": "Applies HTML escaping *after* any necessary processing (like case change) to ensure the final output is safe."
      },
      {
        "id": 2667,
        "code": "const data = req.body.yaml;\nyaml.load(data);",
        "label": "insecure",
        "vulnerability_type": "Insecure Deserialization (YAML - Uncontrolled)",
        "explanation": "Loading arbitrary YAML data from the client is a critical vulnerability often leading to RCE."
      },
      {
        "id": 2668,
        "code": "const data = req.body.yaml;\n// Use a dedicated safe loader that only allows safe types.\nyaml.safeLoad(data);",
        "label": "secure",
        "vulnerability_type": "Insecure Deserialization (YAML - Uncontrolled)",
        "explanation": "Uses the `yaml.safeLoad` function, which is designed to handle untrusted input by only allowing non-executing primitive types."
      },
      {
        "id": 2669,
        "code": "app.get('/status', (req, res) => {\n  res.set('X-Content-Type-Options', 'no-sniff');\n  res.send('ok');\n});",
        "label": "insecure",
        "vulnerability_type": "Header Injection (Mispelled Header Value)",
        "explanation": "The value `no-sniff` is misspelled and will be ignored by browsers."
      },
      {
        "id": 2670,
        "code": "app.get('/status', (req, res) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.send('ok');\n});",
        "label": "secure",
        "vulnerability_type": "Header Injection (Mispelled Header Value)",
        "explanation": "Corrects the header value to `nosniff`, ensuring the browser's content sniffing is disabled."
      },
      {
        "id": 2671,
        "code": "const user_id = req.query.id;\nconst query = `DELETE FROM tokens WHERE user_id = ${user_id} AND active = 1`;",
        "label": "insecure",
        "vulnerability_type": "SQL Injection (Numeric Delete)",
        "explanation": "Concatenates the numeric ID, allowing an attacker to inject logic (e.g., `' OR '1'='1`) to bypass the `AND active = 1` clause."
      },
      {
        "id": 2672,
        "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `DELETE FROM tokens WHERE user_id = ? AND active = 1`;\ndb.query(query, [user_id]);",
        "label": "secure",
        "vulnerability_type": "SQL Injection (Numeric Delete)",
        "explanation": "Enforces type safety and uses a parameterized query for the `user_id`."
      },
      {
        "id": 2673,
        "code": "const token = jwt.sign({ data: 'internal' }, 'small');",
        "label": "insecure",
        "vulnerability_type": "Weak Cryptography (Short Secret)",
        "explanation": "Uses a very short, easily guessed secret (`'small'`) for JWT signing, making brute-forcing trivial."
      },
      {
        "id": 2674,
        "code": "const token = jwt.sign({ data: 'internal' }, process.env.LONG_SECRET, { algorithm: 'HS512' });",
        "label": "secure",
        "vulnerability_type": "Weak Cryptography (Short Secret)",
        "explanation": "Uses a long, cryptographically strong secret from the environment and a robust hashing algorithm (`HS512`)."
      },
      {
        "id": 2675,
        "code": "app.get('/download', (req, res) => {\n  res.download(req.query.file);\n});",
        "label": "insecure",
        "vulnerability_type": "Path Traversal (Uncontrolled Download)",
        "explanation": "Allows a client to specify any path for download, enabling path traversal to sensitive files."
      },
      {
        "id": 2676,
        "code": "app.get('/download', (req, res) => {\n  const filename = path.basename(req.query.file);\n  res.download(path.join(__dirname, 'public/downloads', filename));\n});",
        "label": "secure",
        "vulnerability_type": "Path Traversal (Uncontrolled Download)",
        "explanation": "Restricts the download path to a public, non-critical directory and sanitizes the filename with `path.basename`."
      },
      {
        "id": 2677,
        "code": "app.get('/page', (req, res) => {\n  res.send(req.query.content);\n});",
        "label": "insecure",
        "vulnerability_type": "Cross-Site Scripting (Simple Reflected)",
        "explanation": "Reflects unescaped content directly to the client, allowing XSS."
      },
      {
        "id": 2678,
        "code": "app.get('/page', (req, res) => {\n  res.send(validator.escape(req.query.content));\n});",
        "label": "secure",
        "vulnerability_type": "Cross-Site Scripting (Simple Reflected)",
        "explanation": "Uses HTML entity escaping on the reflected output."
      },
      {
        "id": 2679,
        "code": "const user = req.params.user;\nconst cmd = `echo 'Hello' >> /var/log/${user}.log`;\nexec(cmd);",
        "label": "insecure",
        "vulnerability_type": "Command Injection (Log Name)",
        "explanation": "Concatenates user input into a command used to create a log file, enabling injection."
      },
      {
        "id": 2680,
        "code": "const user = req.params.user.replace(/[^a-zA-Z0-9]/g, '');\nconst cmd = `echo 'Hello' >> /var/log/${user}.log`;\nexec(cmd);",
        "label": "secure",
        "vulnerability_type": "Command Injection (Log Name)",
        "explanation": "Sanitizes the log file name to allow only safe, alphanumeric characters."
      },
      {
        "id": 2681,
        "code": "app.use(helmet.contentSecurityPolicy());",
        "label": "insecure",
        "vulnerability_type": "Weak CSP (Default)",
        "explanation": "The default helmet CSP is often too permissive or requires manual configuration to provide meaningful XSS defense."
      },
      {
        "id": 2682,
        "code": "app.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\", \"'nonce-ABC'\"], // Nonce enforced\n    objectSrc: [\"'none'\"],\n  },\n}));",
        "label": "secure",
        "vulnerability_type": "Weak CSP (Default)",
        "explanation": "Uses a highly restrictive CSP with explicit directives, including `objectSrc: 'none'` and nonces for scripts."
      },
      {
        "id": 2683,
        "code": "const user_id = req.query.id;\ndb.query(`SELECT * FROM ${user_id}_data`);",
        "label": "insecure",
        "vulnerability_type": "SQL Injection (Dynamic Table/User Data)",
        "explanation": "Allows the user to manipulate the table prefix, enabling access to other users' tables or injecting commands."
      },
      {
        "id": 2684,
        "code": "const user_id = req.query.id;\nif (req.user.id !== user_id) return res.status(403).send();\ndb.query(`SELECT * FROM ${req.user.id}_data`);",
        "label": "secure",
        "vulnerability_type": "SQL Injection (Dynamic Table/User Data)",
        "explanation": "Enforces an IDOR check and only uses the authenticated user's ID for the dynamic table name."
      },
      {
        "id": 2685,
        "code": "const password = req.body.pass;\nconst hash = sha384(password + 'salt');",
        "label": "insecure",
        "vulnerability_type": "Weak Cryptography (Concatenated Salt)",
        "explanation": "Concatenating a salt to a password before hashing is weak; the hash function should handle salting correctly (e.g., PBKDF2, bcrypt)."
      },
      {
        "id": 2686,
        "code": "const password = req.body.pass;\nconst salt = crypto.randomBytes(16).toString('hex');\nconst hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512');",
        "label": "secure",
        "vulnerability_type": "Weak Cryptography (Concatenated Salt)",
        "explanation": "Uses the industry-standard PBKDF2 function for key derivation, ensuring proper, randomized salting and a high work factor."
      },
      {
        "id": 2687,
        "code": "res.status(200).send(db.connectionString);",
        "label": "insecure",
        "vulnerability_type": "Information Leakage (Connection String)",
        "explanation": "Exposes the full database connection string, including passwords and hostnames, via an API response."
      },
      {
        "id": 2688,
        "code": "res.status(200).send('Database connection is active.');",
        "label": "secure",
        "vulnerability_type": "Information Leakage (Connection String)",
        "explanation": "The API response is limited to a non-sensitive status message."
      },
      {
        "id": 2689,
        "code": "const html = '<div>' + req.query.data + '</div>';\nconst pdf = pdfGenerator.generate(html);",
        "label": "insecure",
        "vulnerability_type": "Injection (PDF HTML)",
        "explanation": "If the PDF generator uses a browser engine, unescaped HTML can lead to XSS or local file access during PDF creation."
      },
      {
        "id": 2690,
        "code": "const html = '<div>' + sanitizeHtml(req.query.data) + '</div>';\nconst pdf = pdfGenerator.generate(html);",
        "label": "secure",
        "vulnerability_type": "Injection (PDF HTML)",
        "explanation": "Sanitizes the user-supplied HTML using a dedicated library (`sanitizeHtml`) before feeding it to the PDF generation engine."
      },
      {
        "id": 2691,
        "code": "const url = req.query.link;\nexec(`wget ${url}`, (err, stdout) => res.send(stdout));",
        "label": "insecure",
        "vulnerability_type": "Command Injection / SSRF (wget)",
        "explanation": "Allows both command injection (via shell metacharacters in `link`) and Server-Side Request Forgery (SSRF) via the `wget` utility."
      },
      {
        "id": 2692,
        "code": "const link = req.query.link;\nconst safeLink = validator.isURL(link) ? link : null;\nif (safeLink) {\n  // Use a controlled network library instead of a shell command\n  fetch(safeLink).then(response => res.send(response));\n}",
        "label": "secure",
        "vulnerability_type": "Command Injection / SSRF (wget)",
        "explanation": "Replaces the dangerous `exec(wget)` with a safe, native network request (`fetch`), mitigating command injection entirely and allowing better control over network targets (SSRF). (Full SSRF mitigation would require hostname validation.)"
      },
      {
        "id": 2693,
        "code": "const data = req.body.input;\nres.send(data);",
        "label": "insecure",
        "vulnerability_type": "Cross-Site Scripting (Reflected Body)",
        "explanation": "Reflecting the raw request body data without escaping, allowing XSS."
      },
      {
        "id": 2694,
        "code": "const data = req.body.input;\nres.send(validator.escape(data));",
        "label": "secure",
        "vulnerability_type": "Cross-Site Scripting (Reflected Body)",
        "explanation": "Uses HTML escaping on the raw reflected body content."
      },
      {
        "id": 2695,
        "code": "app.get('/api/users/:id', async (req, res) => {\n  const user = await db.getUser(req.params.id);\n  // No check to see if user exists\n  res.json(user);\n});",
        "label": "insecure",
        "vulnerability_type": "IDOR (Missing Existence Check)",
        "explanation": "If the user object is null, the code may crash or expose internal errors. Crucially, it returns sensitive information without checking if the *requesting* user is authorized to view the *target* user."
      },
      {
        "id": 2696,
        "code": "app.get('/api/users/:id', async (req, res) => {\n  const user = await db.getUser(req.params.id);\n  if (!user || req.params.id !== req.user.id) {\n    return res.status(403).send('Forbidden');\n  }\n  res.json(user);\n});",
        "label": "secure",
        "vulnerability_type": "IDOR (Missing Existence Check)",
        "explanation": "Implements a strict check to ensure the resource exists and that the authenticated user ID matches the requested resource ID (IDOR prevention)."
      },
      {
        "id": 2697,
        "code": "const data = req.query.msg;\nres.send(`<input value=\"${data}\">`);",
        "label": "insecure",
        "vulnerability_type": "XSS (HTML Attribute Context)",
        "explanation": "Unescaped input inside an HTML attribute allows an attacker to break out of the quotes and inject script (e.g., `\" onmouseover=\"alert(1)`)."
      },
      {
        "id": 2698,
        "code": "const data = req.query.msg;\nconst safeData = data.replace(/\"/g, '&quot;');\nres.send(`<input value=\"${safeData}\">`);",
        "label": "secure",
        "vulnerability_type": "XSS (HTML Attribute Context)",
        "explanation": "Escapes characters that can break the attribute's quotes, ensuring the input is treated as a literal value within the attribute."
      },
      {
        "id": 2699,
        "code": "const salt = 'a_fixed_salt';\nconst hash = crypto.createHmac('sha256', salt).update(password).digest('hex');",
        "label": "insecure",
        "vulnerability_type": "Weak Cryptography (Fixed HMAC Salt)",
        "explanation": "Using a fixed, hardcoded salt/key for HMAC defeats the purpose of key separation and allows dictionary attacks on all users simultaneously."
      },
      {
        "id": 2700,
        "code": "const key = process.env.HMAC_KEY;\nconst hash = crypto.createHmac('sha512', key).update(password).digest('hex');",
        "label": "secure",
        "vulnerability_type": "Weak Cryptography (Fixed HMAC Salt)",
        "explanation": "Uses a strong, environment-based key and a modern, high-bit HMAC algorithm (SHA512) for secure keyed hashing."
      },
        {
          "id": 2701,
          "code": "const username = req.query.user;\nconst password = req.query.pass;\nconst query = `SELECT * FROM users WHERE user = '${username}' AND pass = '${password}'`;",
          "label": "insecure",
          "vulnerability_type": "SQL Injection (Login Credentials)",
          "explanation": "Directly concatenates both username and password into the SQL query, making it vulnerable to injection via quote escaping."
        },
        {
          "id": 2702,
          "code": "const username = req.query.user;\nconst password = req.query.pass;\nconst query = `SELECT * FROM users WHERE user = ? AND pass = ?`;\ndb.query(query, [username, password]);",
          "label": "secure",
          "vulnerability_type": "SQL Injection (Login Credentials)",
          "explanation": "Uses parameterized queries for both credentials, ensuring they are treated as literal data, not executable SQL."
        },
        {
          "id": 2703,
          "code": "app.get('/log', (req, res) => {\n  fs.appendFileSync('server.log', req.query.message);\n  res.send('Logged');\n});",
          "label": "insecure",
          "vulnerability_type": "Log Injection (Arbitrary Input)",
          "explanation": "Injects unvalidated user input into a log file, allowing an attacker to inject newline characters to forge log entries or break formatting."
        },
        {
          "id": 2704,
          "code": "app.get('/log', (req, res) => {\n  const safeMessage = req.query.message.replace(/[\\r\\n\\u000a\\u000d]/g, '_');\n  fs.appendFileSync('server.log', safeMessage + '\\n');\n  res.send('Logged');\n});",
          "label": "secure",
          "vulnerability_type": "Log Injection (Arbitrary Input)",
          "explanation": "Sanitizes the input by replacing all newline and carriage return characters, preventing log forging."
        },
        {
          "id": 2705,
          "code": "const token = req.query.jwt;\nconst payload = jwt.decode(token);",
          "label": "insecure",
          "vulnerability_type": "JWT Misuse (Unverified Data)",
          "explanation": "Uses `jwt.decode` to extract the payload without verifying the signature, allowing an attacker to modify the token content before submitting it."
        },
        {
          "id": 2706,
          "code": "const token = req.query.jwt;\nconst payload = jwt.verify(token, process.env.JWT_SECRET);\nif (payload) { /* safe to use */ }",
          "label": "secure",
          "vulnerability_type": "JWT Misuse (Unverified Data)",
          "explanation": "Uses `jwt.verify` to ensure the token's signature and expiration are valid before trusting and using its payload data."
        },
        {
          "id": 2707,
          "code": "const file = req.query.file;\nres.sendFile('/var/www/data/' + file);",
          "label": "insecure",
          "vulnerability_type": "Path Traversal (Base Dir)",
          "explanation": "The file name is concatenated, allowing traversal attacks like `../etc/passwd` to read sensitive files."
        },
        {
          "id": 2708,
          "code": "const file = path.basename(req.query.file);\nres.sendFile(path.join('/var/www/data/', file));",
          "label": "secure",
          "vulnerability_type": "Path Traversal (Base Dir)",
          "explanation": "Uses `path.basename` to extract only the filename, stripping any directory components, and `path.join` for safe path construction."
        },
        {
          "id": 2709,
          "code": "const data = req.body.data;\nconst result = Buffer.from(data).toString();",
          "label": "insecure",
          "vulnerability_type": "DoS (Unchecked Buffer Size)",
          "explanation": "Creating a buffer from an arbitrary-sized input string can lead to resource exhaustion and server crash (DoS)."
        },
        {
          "id": 2710,
          "code": "const data = req.body.data;\nif (data.length > 50000) return res.status(413).send('Payload too large');\nconst result = Buffer.from(data).toString();",
          "label": "secure",
          "vulnerability_type": "DoS (Unchecked Buffer Size)",
          "explanation": "Implements an explicit length check on the input string before the potentially memory-intensive buffer creation."
        },
        {
          "id": 2711,
          "code": "app.post('/update', (req, res) => {\n  db.update(req.user.id, req.body);\n  res.send('Updated');\n});",
          "label": "insecure",
          "vulnerability_type": "Mass Assignment (Update Full Body)",
          "explanation": "Passes the entire request body to the update function, allowing attackers to modify unintended fields like `role` or `isAdmin`."
        },
        {
          "id": 2712,
          "code": "app.post('/update', (req, res) => {\n  const safeFields = { name: req.body.name, bio: req.body.bio };\n  db.update(req.user.id, safeFields);\n  res.send('Updated');\n});",
          "label": "secure",
          "vulnerability_type": "Mass Assignment (Update Full Body)",
          "explanation": "Uses explicit field whitelisting (`safeFields`) to ensure only safe, non-sensitive data can be updated by the client."
        },
        {
          "id": 2713,
          "code": "res.set('X-Frame-Options', 'ALLOW-FROM ' + req.query.domain);",
          "label": "insecure",
          "vulnerability_type": "Clickjacking (Reflected Domain)",
          "explanation": "Reflecting an arbitrary domain into `ALLOW-FROM` effectively disables clickjacking protection for the attacker's site."
        },
        {
          "id": 2714,
          "code": "const domain = req.query.domain;\nconst safeDomain = ['https://trusted.com', 'https://another.com'].includes(domain) ? domain : null;\nif (safeDomain) {\n  res.set('X-Frame-Options', 'ALLOW-FROM ' + safeDomain);\n} else {\n  res.set('X-Frame-Options', 'DENY');\n}",
          "label": "secure",
          "vulnerability_type": "Clickjacking (Reflected Domain)",
          "explanation": "Validates the domain against a strict whitelist; if the domain is not trusted, the header defaults to `DENY`."
        },
        {
          "id": 2715,
          "code": "const token = jwt.sign({ data: 'internal' }, 'small-secret', { expiresIn: '10h' });",
          "label": "insecure",
          "vulnerability_type": "Weak Cryptography (Guessable Secret)",
          "explanation": "Uses a small, easily guessed secret, making the JWT trivial to forge or crack."
        },
        {
          "id": 2716,
          "code": "const token = jwt.sign({ data: 'internal' }, process.env.JWT_KEY, { algorithm: 'HS512', expiresIn: '10m' });",
          "label": "secure",
          "vulnerability_type": "Weak Cryptography (Guessable Secret)",
          "explanation": "Uses a strong secret from an environment variable and a stronger algorithm (`HS512`) with a short expiration time."
        },
        {
          "id": 2717,
          "code": "const xml = req.body.data;\nconst result = xmlParser.parse(xml);",
          "label": "insecure",
          "vulnerability_type": "XML External Entity (XXE) - Default Parser",
          "explanation": "Parsing untrusted XML with a default parser may allow external entity resolution, leading to XXE attacks or DoS."
        },
        {
          "id": 2718,
          "code": "const xml = req.body.data;\nconst result = xmlParser.parse(xml, { disableEntities: true, maxEntityDepth: 5 });",
          "label": "secure",
          "vulnerability_type": "XML External Entity (XXE) - Default Parser",
          "explanation": "The XML parser is explicitly configured to disable external entities and limit entity recursion depth, mitigating XXE."
        },
        {
          "id": 2719,
          "code": "app.get('/search', (req, res) => {\n  res.send('Results for: ' + req.query.q);\n});",
          "label": "insecure",
          "vulnerability_type": "Cross-Site Scripting (Reflected Parameter)",
          "explanation": "Unescaped reflection of a query parameter into the HTML output is a direct XSS vector."
        },
        {
          "id": 2720,
          "code": "app.get('/search', (req, res) => {\n  res.send('Results for: ' + validator.escape(req.query.q));\n});",
          "label": "secure",
          "vulnerability_type": "Cross-Site Scripting (Reflected Parameter)",
          "explanation": "Uses HTML entity escaping on the reflected user input, neutralizing any injected script tags."
        },
        {
          "id": 2721,
          "code": "const password = req.body.pass;\nconst hash = sha256(password);",
          "label": "insecure",
          "vulnerability_type": "Weak Cryptography (SHA-256 for Password)",
          "explanation": "Using a fast, non-adaptive hash function (SHA-256) for passwords lacks the required salt and work factor to resist GPU cracking."
        },
        {
          "id": 2722,
          "code": "const password = req.body.pass;\nconst hash = await bcrypt.hash(password, 12);",
          "label": "secure",
          "vulnerability_type": "Weak Cryptography (SHA-256 for Password)",
          "explanation": "Uses the slow, adaptive bcrypt algorithm with a high work factor (12), which is designed for secure password storage."
        },
        {
          "id": 2723,
          "code": "const url = req.query.url;\nres.redirect(url);",
          "label": "insecure",
          "vulnerability_type": "Open Redirect (Simple)",
          "explanation": "Redirects to an arbitrary, user-controlled URL, enabling phishing attacks."
        },
        {
          "id": 2724,
          "code": "const url = req.query.url;\nif (url.startsWith('/') || url.startsWith(req.hostname)) {\n  res.redirect(url);\n} else {\n  res.redirect('/');\n}",
          "label": "secure",
          "vulnerability_type": "Open Redirect (Simple)",
          "explanation": "Validates the URL to ensure it is a relative path or matches the current, trusted hostname, preventing external redirects."
        },
        {
          "id": 2725,
          "code": "const user_id = req.query.id;\nconst query = `DELETE FROM data WHERE user_id = ${user_id}`;",
          "label": "insecure",
          "vulnerability_type": "SQL Injection (Numeric Delete)",
          "explanation": "Concatenates the numeric ID into the DELETE query, allowing logic injection to delete unauthorized records."
        },
        {
          "id": 2726,
          "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `DELETE FROM data WHERE user_id = ?`;\ndb.query(query, [user_id]);",
          "label": "secure",
          "vulnerability_type": "SQL Injection (Numeric Delete)",
          "explanation": "Uses `parseInt` to enforce numeric type and a parameterized query for safe execution."
        },
        {
          "id": 2727,
          "code": "const cmd = 'ls ' + req.query.folder;\nrequire('child_process').exec(cmd, (err, stdout) => res.send(stdout));",
          "label": "insecure",
          "vulnerability_type": "Command Injection (Shell)",
          "explanation": "Concatenates user input into a shell command, enabling execution of arbitrary commands."
        },
        {
          "id": 2728,
          "code": "const folder = req.query.folder.replace(/[^\\w\\-.]/g, '');\nrequire('child_process').execFile('ls', [folder], (err, stdout) => res.send(stdout));",
          "label": "secure",
          "vulnerability_type": "Command Injection (Shell)",
          "explanation": "Sanitizes the input to a safe character set and uses the safer `execFile` function (shell bypass)."
        },
        {
          "id": 2729,
          "code": "app.get('/info', (req, res) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.send('Public API');\n});",
          "label": "insecure",
          "vulnerability_type": "CORS Misconfiguration (Wildcard)",
          "explanation": "Using the wildcard (`*`) for `Access-Control-Allow-Origin` is overly permissive and can be dangerous if the endpoint ever serves authenticated data."
        },
        {
          "id": 2730,
          "code": "app.get('/info', (req, res) => {\n  res.set('Access-Control-Allow-Origin', 'https://trusted.client.com');\n  res.send('Public API');\n});",
          "label": "secure",
          "vulnerability_type": "CORS Misconfiguration (Wildcard)",
          "explanation": "Explicitly sets the allowed origin to a single, trusted domain, enforcing the Same-Origin Policy (SOP) for all other domains."
        },
        {
          "id": 2731,
          "code": "const data = req.body.input;\nres.send(`<div id=\"output\">${data}</div>`);",
          "label": "insecure",
          "vulnerability_type": "Cross-Site Scripting (Reflected HTML)",
          "explanation": "Reflects raw user input into an HTML tag, allowing XSS."
        },
        {
          "id": 2732,
          "code": "const data = req.body.input;\nres.send(`<div id=\"output\">${validator.escape(data)}</div>`);",
          "label": "secure",
          "vulnerability_type": "Cross-Site Scripting (Reflected HTML)",
          "explanation": "Applies HTML entity escaping to the user input before embedding it in the HTML template."
        },
        {
          "id": 2733,
          "code": "const filename = req.query.name;\nexec(`cat ${filename} | grep -v 'secret'`, (err, stdout) => res.send(stdout));",
          "label": "insecure",
          "vulnerability_type": "Command Injection (Pipeline)",
          "explanation": "Allows injection into the `cat` command, potentially breaking the pipeline (`|`) to execute new commands."
        },
        {
          "id": 2734,
          "code": "const filename = path.basename(req.query.name);\nconst filepath = path.join('/app/logs', filename);\nexecFile('grep', ['-v', 'secret', filepath], (err, stdout) => res.send(stdout));",
          "label": "secure",
          "vulnerability_type": "Command Injection (Pipeline)",
          "explanation": "Uses `execFile` with separate arguments to bypass the shell and sanitizes the filename, preventing pipeline injection."
        },
        {
          "id": 2735,
          "code": "res.set('Content-Security-Policy', `script-src 'self' ${req.query.host}`);",
          "label": "insecure",
          "vulnerability_type": "CSP Injection (Script-Src)",
          "explanation": "Allows a user to inject an arbitrary domain into the `script-src` directive, bypassing CSP and loading malicious scripts."
        },
        {
          "id": 2736,
          "code": "const host = req.query.host;\nconst safeHost = host.match(/^(https:\\/\\/trusted\\.com)$/) ? host : \"'self'\";\nres.set('Content-Security-Policy', `script-src 'self' ${safeHost}`);",
          "label": "secure",
          "vulnerability_type": "CSP Injection (Script-Src)",
          "explanation": "Validates the user-supplied host against a strict, secure regex whitelist before including it in the CSP header."
        },
        {
          "id": 2737,
          "code": "const password = req.body.pass;\nconst salt = req.body.salt;\nconst hash = crypto.createHmac('sha256', salt).update(password).digest('hex');",
          "label": "insecure",
          "vulnerability_type": "Weak Cryptography (Client-Side HMAC Salt)",
          "explanation": "The salt is supplied by the client, which allows an attacker to control the HMAC key, defeating its purpose."
        },
        {
          "id": 2738,
          "code": "const password = req.body.pass;\nconst key = process.env.HMAC_SERVER_KEY;\nconst hash = crypto.createHmac('sha512', key).update(password).digest('hex');",
          "label": "secure",
          "vulnerability_type": "Weak Cryptography (Client-Side HMAC Salt)",
          "explanation": "Uses a secure, server-side key (from environment variables) for the HMAC and a stronger algorithm (`sha512`)."
        },
        {
          "id": 2739,
          "code": "const user_id = req.query.id;\nconst query = `UPDATE users SET status = 1 WHERE id = ${user_id}`;",
          "label": "insecure",
          "vulnerability_type": "SQL Injection (Numeric ID Update)",
          "explanation": "Concatenates the ID into the SQL UPDATE query, allowing injection."
        },
        {
          "id": 2740,
          "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `UPDATE users SET status = 1 WHERE id = ?`;\ndb.query(query, [user_id]);",
          "label": "secure",
          "vulnerability_type": "SQL Injection (Numeric ID Update)",
          "explanation": "Uses `parseInt` and a parameterized query to safely handle the ID value."
        },
        {
          "id": 2741,
          "code": "const data = req.query.content;\ndocument.getElementById('output').style.width = data;",
          "label": "insecure",
          "vulnerability_type": "XSS (Client-Side CSS Injection)",
          "explanation": "Injects unescaped user input into a CSS property, which can be exploited to execute script via `url('javascript:...')`."
        },
        {
          "id": 2742,
          "code": "const data = req.query.content;\n// Whitelist for safe CSS values (e.g., numbers followed by 'px')\nconst safeData = data.match(/^\\d{1,3}px$/) ? data : '100px';\ndocument.getElementById('output').style.width = safeData;",
          "label": "secure",
          "vulnerability_type": "XSS (Client-Side CSS Injection)",
          "explanation": "Uses a regular expression to strictly validate the CSS input against a safe, restrictive pattern before injection."
        },
        {
          "id": 2743,
          "code": "const file = req.query.file;\nfs.promises.stat(file);",
          "label": "insecure",
          "vulnerability_type": "Path Traversal (File Stat)",
          "explanation": "The `stat` operation can be used to check for the existence and properties of arbitrary files on the system via traversal."
        },
        {
          "id": 2744,
          "code": "const file = path.join(process.cwd(), 'uploads', path.basename(req.query.file));\nfs.promises.stat(file);",
          "label": "secure",
          "vulnerability_type": "Path Traversal (File Stat)",
          "explanation": "Restricts the file path to a known, safe directory by joining it with `process.cwd()` and sanitizing the filename."
        },
        {
          "id": 2745,
          "code": "app.get('/data', (req, res) => {\n  res.set('Cache-Control', 'private');\n  res.send('Sensitive data');\n});",
          "label": "insecure",
          "vulnerability_type": "Insecure Caching (Private)",
          "explanation": "The `private` cache-control directive allows the user's browser to cache sensitive data, which can lead to data leakage on shared computers."
        },
        {
          "id": 2746,
          "code": "app.get('/data', (req, res) => {\n  res.set('Cache-Control', 'no-store, no-cache, must-revalidate, private');\n  res.send('Sensitive data');\n});",
          "label": "secure",
          "vulnerability_type": "Insecure Caching (Private)",
          "explanation": "Uses `no-store` to explicitly forbid all caching of the sensitive response by any party (browser, proxy, etc.)."
        },
        {
          "id": 2747,
          "code": "const data = req.query.msg;\nres.send(`<iframe src=\"${data}\"></iframe>`);",
          "label": "insecure",
          "vulnerability_type": "XSS (HTML Frame Source)",
          "explanation": "Injects an arbitrary URL into an `iframe`'s `src` attribute, allowing XSS via `javascript:` scheme or a malicious external page."
        },
        {
          "id": 2748,
          "code": "const data = req.query.msg;\nconst safeUrl = validator.isURL(data, { protocols: ['https'] }) ? data : '#';\nres.send(`<iframe src=\"${safeUrl}\"></iframe>`);",
          "label": "secure",
          "vulnerability_type": "XSS (HTML Frame Source)",
          "explanation": "Validates the URL to ensure it uses only the secure `https` protocol before injection, mitigating `javascript:` XSS."
        },
        {
          "id": 2749,
          "code": "const password = req.body.pass;\nconst hash = await scrypt(password, 'static-salt', 64, { N: 16384 });",
          "label": "insecure",
          "vulnerability_type": "Weak Cryptography (Static Scrypt Salt)",
          "explanation": "Uses a static, hardcoded salt for Scrypt, defeating the purpose of per-hash salting and increasing cracking efficiency."
        },
        {
          "id": 2750,
          "code": "const password = req.body.pass;\nconst salt = crypto.randomBytes(16).toString('hex');\nconst hash = await scrypt(password, salt, 64, { N: 16384 });",
          "label": "secure",
          "vulnerability_type": "Weak Cryptography (Static Scrypt Salt)",
          "explanation": "Generates a cryptographically secure, random salt for each hash operation, as required by modern key derivation functions."
        },
        {
          "id": 2751,
          "code": "const user_id = req.query.id;\nconst query = `SELECT * FROM audits WHERE user_id = ${user_id} ORDER BY time DESC`;",
          "label": "insecure",
          "vulnerability_type": "SQL Injection (Filter ID)",
          "explanation": "Concatenates the numeric ID into the query, allowing injection."
        },
        {
          "id": 2752,
          "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `SELECT * FROM audits WHERE user_id = ? ORDER BY time DESC`;\ndb.query(query, [user_id]);",
          "label": "secure",
          "vulnerability_type": "SQL Injection (Filter ID)",
          "explanation": "Uses `parseInt` and a parameterized query for the ID parameter."
        },
        {
          "id": 2753,
          "code": "app.get('/api', (req, res) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  res.send('Data');\n});",
          "label": "insecure",
          "vulnerability_type": "CORS Misconfiguration (Wildcard + Credentials)",
          "explanation": "Setting both `Allow-Origin: *` AND `Allow-Credentials: true` is a major security flaw, as it grants full access to any site to perform authenticated requests."
        },
        {
          "id": 2754,
          "code": "app.get('/api', (req, res) => {\n  res.set('Access-Control-Allow-Origin', 'https://trusted.client.com');\n  res.set('Access-Control-Allow-Credentials', 'true');\n  res.send('Data');\n});",
          "label": "secure",
          "vulnerability_type": "CORS Misconfiguration (Wildcard + Credentials)",
          "explanation": "The wildcard is replaced with a specific, trusted origin, making the use of `Allow-Credentials: true` safe."
        },
        {
          "id": 2755,
          "code": "const code = req.body.data;\nvm.runInContext(code, sandbox);",
          "label": "insecure",
          "vulnerability_type": "Code Injection (VM Context)",
          "explanation": "Executing arbitrary user code, even in a sandboxed VM context, is inherently dangerous due to frequent sandbox escape vulnerabilities."
        },
        {
          "id": 2756,
          "code": "const code = req.body.data;\nres.status(403).send('Code execution forbidden.');",
          "label": "secure",
          "vulnerability_type": "Code Injection (VM Context)",
          "explanation": "Removes the dangerous code execution functionality entirely."
        },
        {
          "id": 2757,
          "code": "const data = req.query.input;\nres.send(`<a href='${data}'>Click</a>`);",
          "label": "insecure",
          "vulnerability_type": "XSS (Single-Quote Attribute)",
          "explanation": "Injecting unescaped input into a single-quoted HTML attribute allows script injection via single-quote escaping."
        },
        {
          "id": 2758,
          "code": "const data = req.query.input;\nconst safeData = data.replace(/'/g, '&#39;');\nres.send(`<a href='${safeData}'>Click</a>`);",
          "label": "secure",
          "vulnerability_type": "XSS (Single-Quote Attribute)",
          "explanation": "Escapes the single quote character, neutralizing the ability to break out of the attribute value."
        },
        {
          "id": 2759,
          "code": "const password = req.body.pass;\nconst hash = await bcrypt.hash(password, 8);",
          "label": "insecure",
          "vulnerability_type": "Weak Cryptography (Low Work Factor)",
          "explanation": "Uses a low work factor (8) for bcrypt, which is insufficient to resist modern, large-scale offline brute-force attacks."
        },
        {
          "id": 2760,
          "code": "const password = req.body.pass;\nconst hash = await bcrypt.hash(password, 12);",
          "label": "secure",
          "vulnerability_type": "Weak Cryptography (Low Work Factor)",
          "explanation": "Uses the current industry-recommended work factor (12 or higher) for bcrypt, ensuring resistance to brute-force attacks."
        },
        {
          "id": 2761,
          "code": "app.get('/download', (req, res) => {\n  const filename = req.query.name;\n  res.download(filename);\n});",
          "label": "insecure",
          "vulnerability_type": "Path Traversal (No Path Context)",
          "explanation": "Allows downloading of any file on the system, as the path parameter is used without any base directory context."
        },
        {
          "id": 2762,
          "code": "app.get('/download', (req, res) => {\n  const filename = path.basename(req.query.name);\n  const folder = path.join(process.cwd(), 'downloads');\n  res.download(path.join(folder, filename));\n});",
          "label": "secure",
          "vulnerability_type": "Path Traversal (No Path Context)",
          "explanation": "Explicitly restricts the download to a safe directory (`downloads`) and sanitizes the filename with `path.basename`."
        },
        {
          "id": 2763,
          "code": "const data = req.body.user;\nconst user = JSON.parse(data);\nif (user.role === 'guest') { /* proceed */ }",
          "label": "insecure",
          "vulnerability_type": "Insecure Deserialization (Role Check)",
          "explanation": "Authorization relies on a role property extracted from client-supplied JSON, allowing an attacker to inject a false role."
        },
        {
          "id": 2764,
          "code": "const data = req.body.user;\nconst user = JSON.parse(data);\nif (req.user.role === 'guest') { /* proceed */ }",
          "label": "secure",
          "vulnerability_type": "Insecure Deserialization (Role Check)",
          "explanation": "The authorization decision is based only on the role from the secure, server-side session (`req.user.role`), ignoring the client input."
        },
        {
          "id": 2765,
          "code": "const query = `SELECT * FROM articles WHERE title LIKE '%${req.query.term}%'`;",
          "label": "insecure",
          "vulnerability_type": "SQL Injection (LIKE Clause)",
          "explanation": "The wildcard filter (`%`) is concatenated, allowing injection via single quotes, which can break the query."
        },
        {
          "id": 2766,
          "code": "const term = '%' + req.query.term + '%';\nconst query = `SELECT * FROM articles WHERE title LIKE ?`;\ndb.query(query, [term]);",
          "label": "secure",
          "vulnerability_type": "SQL Injection (LIKE Clause)",
          "explanation": "The filter term (including wildcards) is built and then passed safely as a single parameter to the prepared statement."
        },
        {
          "id": 2767,
          "code": "app.use(express.static('./'));",
          "label": "insecure",
          "vulnerability_type": "Static File Exposure (Root)",
          "explanation": "Serving the current working directory (`./`) as static content exposes all source code, environment files, and configuration."
        },
        {
          "id": 2768,
          "code": "app.use(express.static(path.join(__dirname, 'public'), { dotfiles: 'ignore' }));",
          "label": "secure",
          "vulnerability_type": "Static File Exposure (Root)",
          "explanation": "Restricts serving to a dedicated `public` folder, uses `path.join` for safety, and ignores hidden files."
        },
        {
          "id": 2769,
          "code": "const data = req.query.input;\nres.send(`<a href=\"javascript:${data}\">Click</a>`);",
          "label": "insecure",
          "vulnerability_type": "XSS (Direct JS Injection)",
          "explanation": "The input is directly embedded into a `javascript:` URL, allowing immediate execution of arbitrary script."
        },
        {
          "id": 2770,
          "code": "const data = req.query.input;\n// If dynamic JS is absolutely required, the input must be heavily whitelisted/tokenized\nres.send(`<a href=\"#\">Click</a>`);",
          "label": "secure",
          "vulnerability_type": "XSS (Direct JS Injection)",
          "explanation": "The dangerous functionality is removed, and the link defaults to a safe hash (`#`)."
        },
        {
          "id": 2771,
          "code": "const username = req.body.user;\nconst password = req.body.pass;\nif (username && password) { /* auth */ }",
          "label": "insecure",
          "vulnerability_type": "Insufficient Validation (Existence Only)",
          "explanation": "Only checks for existence; does not validate the type, length, or character set of the credentials."
        },
        {
          "id": 2772,
          "code": "const username = req.body.user;\nconst password = req.body.pass;\nif (validator.isLength(username, { min: 4, max: 20 }) && validator.isLength(password, { min: 8 })) { /* auth */ }",
          "label": "secure",
          "vulnerability_type": "Insufficient Validation (Existence Only)",
          "explanation": "Enforces explicit length constraints on both fields, improving data quality and security."
        },
        {
          "id": 2773,
          "code": "const key = req.query.key;\nconst iv = req.query.iv;\nconst cipher = crypto.createCipheriv('aes-128-cbc', key, iv);",
          "label": "insecure",
          "vulnerability_type": "Weak Cryptography (Client IV/Key)",
          "explanation": "Allows the client to supply the encryption key and IV, rendering the encryption useless, as the attacker knows the key."
        },
        {
          "id": 2774,
          "code": "const key = process.env.ENC_KEY;\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-gcm', key, iv);",
          "label": "secure",
          "vulnerability_type": "Weak Cryptography (Client IV/Key)",
          "explanation": "Uses a server-side key and a securely random, server-generated IV for strong encryption."
        },
        {
          "id": 2775,
          "code": "app.get('/file', (req, res) => {\n  fs.promises.unlink(req.query.path);\n  res.send('Deleted');\n});",
          "label": "insecure",
          "vulnerability_type": "Path Traversal (Arbitrary Delete)",
          "explanation": "Allows the user to specify any file path for deletion, enabling the deletion of sensitive system files."
        },
        {
          "id": 2776,
          "code": "app.get('/file', (req, res) => {\n  const filename = path.basename(req.query.path);\n  const fullPath = path.join('/tmp/session', req.user.id.toString(), filename);\n  fs.promises.unlink(fullPath);\n  res.send('Deleted');\n});",
          "label": "secure",
          "vulnerability_type": "Path Traversal (Arbitrary Delete)",
          "explanation": "Restricts deletion to a user-scoped temporary directory and sanitizes the filename with `path.basename`."
        },
        {
          "id": 2777,
          "code": "const url = new URL(req.query.link);\nconst response = await fetch(url.toString());",
          "label": "insecure",
          "vulnerability_type": "SSRF (Full URL Fetch)",
          "explanation": "Allows the server to fetch an arbitrary URL, including internal network addresses, leading to SSRF."
        },
        {
          "id": 2778,
          "code": "const url = req.query.link;\nif (!url.startsWith('https://external-api.com')) return res.status(403).send();\nconst response = await fetch(url);",
          "label": "secure",
          "vulnerability_type": "SSRF (Full URL Fetch)",
          "explanation": "Uses a strong **whitelist** to ensure the URL matches an explicitly allowed external domain before the request is made."
        },
        {
          "id": 2779,
          "code": "res.header('X-Content-Type-Options', 'no-sniff');",
          "label": "insecure",
          "vulnerability_type": "Misspelled Header Value",
          "explanation": "The value `no-sniff` is misspelled and will be ignored by browsers."
        },
        {
          "id": 2780,
          "code": "res.header('X-Content-Type-Options', 'nosniff');",
          "label": "secure",
          "vulnerability_type": "Misspelled Header Value",
          "explanation": "The header value is correctly set to `nosniff`, ensuring the browser disables content type guessing."
        },
        {
          "id": 2781,
          "code": "const sql = `SELECT * FROM data WHERE user = '${req.query.user}' AND status = ${req.query.status}`;",
          "label": "insecure",
          "vulnerability_type": "SQL Injection (Mixed Types)",
          "explanation": "Concatenates both string (`user`) and numeric (`status`) input, vulnerable to injection in both positions."
        },
        {
          "id": 2782,
          "code": "const status = parseInt(req.query.status, 10);\nconst sql = `SELECT * FROM data WHERE user = ? AND status = ?`;\ndb.query(sql, [req.query.user, status]);",
          "label": "secure",
          "vulnerability_type": "SQL Injection (Mixed Types)",
          "explanation": "The `status` is cast to an integer, and both values are passed safely as parameters."
        },
        {
          "id": 2783,
          "code": "app.get('/data', (req, res) => {\n  res.json({ date: new Date() });\n});",
          "label": "insecure",
          "vulnerability_type": "Timing Attack (Time Leakage)",
          "explanation": "Exposing the server's precise timestamp in API responses can aid attackers in correlating events for timing attacks."
        },
        {
          "id": 2784,
          "code": "app.get('/data', (req, res) => {\n  res.json({ date: Date.now() }); // Use a simpler UNIX timestamp or generic time\n});",
          "label": "secure",
          "vulnerability_type": "Timing Attack (Time Leakage)",
          "explanation": "Uses a more generic timestamp format (milliseconds since epoch) or obfuscates time for high-security environments."
        },
        {
          "id": 2785,
          "code": "const data = req.query.input;\nres.send(`<div style='background:url(${data})'></div>`);",
          "label": "insecure",
          "vulnerability_type": "XSS (CSS URL Injection)",
          "explanation": "Injects unescaped input into a CSS URL context, allowing XSS via `data:image/svg+xml` or `javascript:` protocols."
        },
        {
          "id": 2786,
          "code": "const data = req.query.input;\nconst safeData = validator.isURL(data, { protocols: ['https'] }) ? data : '';\nres.send(`<div style='background:url(\"${safeData}\")'></div>`);",
          "label": "secure",
          "vulnerability_type": "XSS (CSS URL Injection)",
          "explanation": "Validates the input to ensure it is a safe URL with a trusted protocol, preventing script injection."
        },
        {
          "id": 2787,
          "code": "const cmd = 'ping ' + req.query.ip;\nexec(cmd, { shell: true }, (err, stdout) => res.send(stdout));",
          "label": "insecure",
          "vulnerability_type": "Command Injection (Explicit Shell)",
          "explanation": "Explicitly enabling the shell (`shell: true`) on an unsanitized command string increases the risk of injection."
        },
        {
          "id": 2788,
          "code": "const ip = req.query.ip.replace(/[^\\d.]/g, '');\nexecFile('ping', [ip], (err, stdout) => res.send(stdout));",
          "label": "secure",
          "vulnerability_type": "Command Injection (Explicit Shell)",
          "explanation": "Bypasses the shell entirely with `execFile` and sanitizes the input to strictly numeric and dot characters."
        },
        {
          "id": 2789,
          "code": "app.get('/info', (req, res) => {\n  res.set('X-XSS-Protection', '0');\n  res.send('API');\n});",
          "label": "insecure",
          "vulnerability_type": "Missing Security Header (Disabled XSS Filter)",
          "explanation": "The `X-XSS-Protection` header is explicitly disabled (`0`), turning off the browser's built-in XSS filter."
        },
        {
          "id": 2790,
          "code": "app.get('/info', (req, res) => {\n  res.set('X-XSS-Protection', '1; mode=block');\n  res.send('API');\n});",
          "label": "secure",
          "vulnerability_type": "Missing Security Header (Disabled XSS Filter)",
          "explanation": "The header is set to `1; mode=block`, enabling the browser's XSS filter and instructing it to block page rendering on detection."
        },
        {
          "id": 2791,
          "code": "const user = req.body.user;\nconst email = req.body.email;\nif (user && email) { /* update */ }",
          "label": "insecure",
          "vulnerability_type": "Insufficient Validation (Email/User Format)",
          "explanation": "Lacks validation to ensure the email is a valid format and the username meets character/length requirements."
        },
        {
          "id": 2792,
          "code": "const user = req.body.user;\nconst email = req.body.email;\nif (validator.isAlphanumeric(user) && validator.isEmail(email)) { /* update */ }",
          "label": "secure",
          "vulnerability_type": "Insufficient Validation (Email/User Format)",
          "explanation": "Uses a validation library to strictly check that the username is alphanumeric and the email is in a valid format."
        },
        {
          "id": 2793,
          "code": "const user_id = req.query.id;\nconst query = `UPDATE user_preferences SET theme = 'dark' WHERE user_id = ${user_id}`;",
          "label": "insecure",
          "vulnerability_type": "SQL Injection (Numeric ID Update)",
          "explanation": "The user ID is concatenated, allowing logic injection into the `WHERE` clause."
        },
        {
          "id": 2794,
          "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `UPDATE user_preferences SET theme = 'dark' WHERE user_id = ?`;\ndb.query(query, [user_id]);",
          "label": "secure",
          "vulnerability_type": "SQL Injection (Numeric ID Update)",
          "explanation": "The numeric ID is cast and passed via a parameterized query for safe execution."
        },
        {
          "id": 2795,
          "code": "const data = req.query.input;\nres.set('X-My-Header', data);\nres.send('ok');",
          "label": "insecure",
          "vulnerability_type": "HTTP Response Splitting (Header Injection)",
          "explanation": "Injects unvalidated user input into a custom HTTP header, allowing an attacker to inject newline characters (`\\r\\n`) and add new headers."
        },
        {
          "id": 2796,
          "code": "const data = req.query.input;\nconst safeData = data.replace(/[\\r\\n]/g, '');\nres.set('X-My-Header', safeData);\nres.send('ok');",
          "label": "secure",
          "vulnerability_type": "HTTP Response Splitting (Header Injection)",
          "explanation": "Sanitizes the input by removing all newline characters (`\\r` and `\\n`), preventing response splitting."
        },
        {
          "id": 2797,
          "code": "const data = req.body.config;\nconst settings = JSON.parse(data);\nsettings.admin = true;",
          "label": "insecure",
          "vulnerability_type": "Insecure Deserialization (Object Manipulation)",
          "explanation": "A pattern that can lead to logic flaws if the user can inject prototype-polluting or malicious properties during deserialization."
        },
        {
          "id": 2798,
          "code": "const data = req.body.config;\nconst settings = safeJsonParse(data);\nif (settings && settings.admin) {\n  // Authorization check here, settings cannot be manipulated by client\n}",
          "label": "secure",
          "vulnerability_type": "Insecure Deserialization (Object Manipulation)",
          "explanation": "Uses a function (`safeJsonParse`) that prevents prototype pollution and ensures object integrity before usage."
        },
        {
          "id": 2799,
          "code": "app.get('/search', (req, res) => {\n  const result = db.search(`term = '${req.query.q}'`);\n  res.send(result);\n});",
          "label": "insecure",
          "vulnerability_type": "SQL Injection (Search Term)",
          "explanation": "Concatenates the search term into the query, making it vulnerable to injection."
        },
        {
          "id": 2800,
          "code": "app.get('/search', (req, res) => {\n  const result = db.search(`term = ?`, [req.query.q]);\n  res.send(result);\n});",
          "label": "secure",
          "vulnerability_type": "SQL Injection (Search Term)",
          "explanation": "Uses a parameterized query, ensuring the search term is safely handled as a literal value."
        },
          {
            "id": 2801,
            "code": "app.get('/search', (req, res) => {\n  const results = db.query(`SELECT * FROM products WHERE name LIKE '%${req.query.q}%'`);\n  res.json(results);\n});",
            "label": "insecure",
            "vulnerability_type": "SQL Injection (LIKE Pattern)",
            "explanation": "Concatenates the search term, including wildcards, directly into the SQL query, allowing injection."
          },
          {
            "id": 2802,
            "code": "app.get('/search', (req, res) => {\n  const searchTerm = '%' + req.query.q + '%';\n  const results = db.query(`SELECT * FROM products WHERE name LIKE ?`, [searchTerm]);\n  res.json(results);\n});",
            "label": "secure",
            "vulnerability_type": "SQL Injection (LIKE Pattern)",
            "explanation": "Constructs the full search pattern on the server and passes it as a safe parameter to the prepared statement."
          },
          {
            "id": 2803,
            "code": "const key = req.query.key;\nconst iv = req.query.iv;\nconst decrypted = crypto.createDecipheriv('aes-128-cbc', key, iv);",
            "label": "insecure",
            "vulnerability_type": "Weak Cryptography (Client-Supplied Key/IV)",
            "explanation": "Allows the client to supply the secret key and IV, which defeats the security of the encryption, as the attacker controls the decryption parameters."
          },
          {
            "id": 2804,
            "code": "const key = process.env.ENCRYPTION_KEY;\nconst iv = req.query.iv;\nconst decrypted = crypto.createDecipheriv('aes-256-gcm', key, iv);",
            "label": "secure",
            "vulnerability_type": "Weak Cryptography (Client-Supplied Key/IV)",
            "explanation": "Uses a server-side key (from a secure environment variable) and a strong algorithm (`aes-256-gcm`); the IV may still be sent but the key remains secret."
          },
          {
            "id": 2805,
            "code": "app.post('/upload', (req, res) => {\n  const filename = req.files.upload.name;\n  if (!filename.includes('.png')) {\n    return res.status(400).send('Only PNG allowed');\n  }\n  fs.renameSync(req.files.upload.path, '/uploads/' + filename);\n});",
            "label": "insecure",
            "vulnerability_type": "Unrestricted File Upload (Blacklist Check)",
            "explanation": "A file type blacklist/substring check (`includes('.png')`) is easily bypassed (e.g., `image.php.png` or `image%00.png`)."
          },
          {
            "id": 2806,
            "code": "app.post('/upload', (req, res) => {\n  if (req.files.upload.mimetype !== 'image/png') {\n    return res.status(400).send('Only PNG allowed');\n  }\n  const newFilename = uuid.v4() + '.png';\n  fs.renameSync(req.files.upload.path, path.join('/uploads/', newFilename));\n});",
            "label": "secure",
            "vulnerability_type": "Unrestricted File Upload (Blacklist Check)",
            "explanation": "Validates the file based on the secure MIME type, generates a cryptographically random filename, and explicitly forces a safe extension, mitigating injection."
          },
          {
            "id": 2807,
            "code": "res.header('Set-Cookie', 'user=admin; secure');",
            "label": "insecure",
            "vulnerability_type": "Missing Cookie Flags (HttpOnly)",
            "explanation": "The cookie lacks the `HttpOnly` flag, making it accessible to client-side scripts, which is a common XSS payload target."
          },
          {
            "id": 2808,
            "code": "res.cookie('user', 'admin', { secure: true, httpOnly: true, sameSite: 'strict' });",
            "label": "secure",
            "vulnerability_type": "Missing Cookie Flags (HttpOnly)",
            "explanation": "Uses the appropriate framework function to set all necessary security flags (`secure`, `httpOnly`, `sameSite`)."
          },
          {
            "id": 2809,
            "code": "const data = req.body.xml;\nconst dom = new DOMParser().parseFromString(data, 'text/xml');",
            "label": "insecure",
            "vulnerability_type": "XML External Entity (XXE) - Frontend Parser",
            "explanation": "While this code might run on the server using Node's `xmldom`, parsing untrusted XML can still lead to XXE if entity resolution is enabled."
          },
          {
            "id": 2810,
            "code": "const data = req.body.xml;\n// Use a secure parser that disables external entity resolution by default\nconst dom = safeParser.parse(data);",
            "label": "secure",
            "vulnerability_type": "XML External Entity (XXE) - Frontend Parser",
            "explanation": "Uses a known-safe XML parser or explicitly configures the parser to block external entity resolution."
          },
          {
            "id": 2811,
            "code": "const dir = req.query.dir;\nexec(`cd ${dir} && ls`, (err, stdout) => res.send(stdout));",
            "label": "insecure",
            "vulnerability_type": "Command Injection (Directory Change)",
            "explanation": "Injecting input into a directory path executed via shell allows directory traversal and command injection via metacharacters (e.g., `;/usr/bin/id`)."
          },
          {
            "id": 2812,
            "code": "const dir = req.query.dir;\nconst safeDir = dir.replace(/[^\\w\\-./]/g, '');\n// Change to using execFile or a library to list directory content safely",
            "label": "secure",
            "vulnerability_type": "Command Injection (Directory Change)",
            "explanation": "The command execution is avoided. Instead, a pure Node.js function like `fs.promises.readdir(path.join(BASE_DIR, safeDir))` should be used."
          },
          {
            "id": 2813,
            "code": "const user_id = req.query.id;\nconst query = `SELECT * FROM users WHERE id = ${user_id}`;",
            "label": "insecure",
            "vulnerability_type": "SQL Injection (Numeric ID)",
            "explanation": "Concatenates the numeric ID, allowing injection via logic or non-numeric input."
          },
          {
            "id": 2814,
            "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `SELECT * FROM users WHERE id = ?`;\ndb.query(query, [user_id]);",
            "label": "secure",
            "vulnerability_type": "SQL Injection (Numeric ID)",
            "explanation": "Uses `parseInt` to validate the type and a parameterized query for safe execution."
          },
          {
            "id": 2815,
            "code": "const data = req.query.input;\nres.send(`<img src=\"/img.png\" title=\"${data}\">`);",
            "label": "insecure",
            "vulnerability_type": "XSS (HTML Attribute Context)",
            "explanation": "Injects unescaped input into an HTML attribute, allowing an attacker to escape the attribute with double quotes and inject script."
          },
          {
            "id": 2816,
            "code": "const data = req.query.input;\nconst safeData = data.replace(/\"/g, '&quot;');\nres.send(`<img src=\"/img.png\" title=\"${safeData}\">`);",
            "label": "secure",
            "vulnerability_type": "XSS (HTML Attribute Context)",
            "explanation": "Escapes the double quote character, preventing the attacker from breaking out of the HTML attribute value."
          },
          {
            "id": 2817,
            "code": "const password = req.body.pass;\nconst hash = sha384(password);",
            "label": "insecure",
            "vulnerability_type": "Weak Cryptography (Fast Hashing)",
            "explanation": "Using a fast hash like SHA-384 for password storage is insecure as it lacks the necessary work factor (slowness) to resist brute-force attacks."
          },
          {
            "id": 2818,
            "code": "const password = req.body.pass;\nconst hash = await argon2.hash(password, { type: argon2.argon2id });",
            "label": "secure",
            "vulnerability_type": "Weak Cryptography (Fast Hashing)",
            "explanation": "Uses a dedicated, memory-hard, adaptive key derivation function (`argon2id`) suitable for secure password storage."
          },
          {
            "id": 2819,
            "code": "if (req.query.dev) { console.log('Dev mode activated'); }",
            "label": "insecure",
            "vulnerability_type": "Authorization Bypass (Unprotected Feature)",
            "explanation": "Allows unauthenticated users to activate a 'dev' mode simply via a query parameter, potentially revealing sensitive debug information."
          },
          {
            "id": 2820,
            "code": "if (process.env.NODE_ENV !== 'production' && req.user.role === 'dev') {\n  if (req.query.dev) { console.log('Dev mode activated'); }\n}",
            "label": "secure",
            "vulnerability_type": "Authorization Bypass (Unprotected Feature)",
            "explanation": "The feature is locked to the non-production environment AND requires an authenticated, privileged user role to activate."
          },
          {
            "id": 2821,
            "code": "const payload = { url: req.query.url };\nconst token = jwt.sign(payload, process.env.SECRET, { algorithm: 'HS256' });",
            "label": "insecure",
            "vulnerability_type": "JWT Misconfiguration (Unvalidated URL Payload)",
            "explanation": "Allows a potentially malicious URL to be embedded in the JWT payload, which could be misused if a client later redirects to this URL (Open Redirect)."
          },
          {
            "id": 2822,
            "code": "const url = req.query.url;\nif (!validator.isURL(url, { protocols: ['https'] })) return res.status(400).send();\nconst payload = { url: url };\nconst token = jwt.sign(payload, process.env.SECRET, { algorithm: 'HS256' });",
            "label": "secure",
            "vulnerability_type": "JWT Misconfiguration (Unvalidated URL Payload)",
            "explanation": "The URL is strictly validated using a library to enforce safe protocols (`https`) before being included in the signed token."
          },
          {
            "id": 2823,
            "code": "const filename = req.query.name;\nres.download(path.join('/tmp', filename));",
            "label": "insecure",
            "vulnerability_type": "Path Traversal (Download - Fixed Base)",
            "explanation": "Concatenates the filename to the fixed base path `/tmp`, but the filename itself can still contain `../` sequences for traversal."
          },
          {
            "id": 2824,
            "code": "const filename = path.basename(req.query.name);\nres.download(path.join('/tmp', filename));",
            "label": "secure",
            "vulnerability_type": "Path Traversal (Download - Fixed Base)",
            "explanation": "Uses `path.basename` to sanitize the filename, ensuring only the file portion is used and preventing directory traversal."
          },
          {
            "id": 2825,
            "code": "app.get('/search', (req, res) => {\n  const term = req.query.q;\n  res.send(`Search term: ${term}`);\n});",
            "label": "insecure",
            "vulnerability_type": "Cross-Site Scripting (Reflected Parameter)",
            "explanation": "Uses a template literal to embed unescaped user input directly into the HTML response, allowing XSS."
          },
          {
            "id": 2826,
            "code": "app.get('/search', (req, res) => {\n  const term = validator.escape(req.query.q);\n  res.send(`Search term: ${term}`);\n});",
            "label": "secure",
            "vulnerability_type": "Cross-Site Scripting (Reflected Parameter)",
            "explanation": "Applies HTML entity escaping to the user-supplied search term before embedding it in the template literal."
          },
          {
            "id": 2827,
            "code": "const password = req.body.pass;\nconst hash = md5(password + 'static');",
            "label": "insecure",
            "vulnerability_type": "Weak Cryptography (MD5 + Static Salt)",
            "explanation": "Uses the broken MD5 algorithm combined with a static salt, which offers minimal resistance to rainbow tables."
          },
          {
            "id": 2828,
            "code": "const password = req.body.pass;\nconst hash = bcrypt.hashSync(password, 12);",
            "label": "secure",
            "vulnerability_type": "Weak Cryptography (MD5 + Static Salt)",
            "explanation": "Uses the secure, adaptive bcrypt algorithm with a high work factor and built-in random salting."
          },
          {
            "id": 2829,
            "code": "const sql = `SELECT * FROM logs WHERE user_id = ${req.query.id} AND time > '${req.query.time}'`;",
            "label": "insecure",
            "vulnerability_type": "SQL Injection (Multiple Unsafe Fields)",
            "explanation": "Concatenates two separate user inputs (numeric ID and date string) into the SQL query, increasing the attack surface."
          },
          {
            "id": 2830,
            "code": "const time = req.query.time;\nconst id = parseInt(req.query.id, 10);\nconst sql = `SELECT * FROM logs WHERE user_id = ? AND time > ?`;\ndb.query(sql, [id, time]);",
            "label": "secure",
            "vulnerability_type": "SQL Injection (Multiple Unsafe Fields)",
            "explanation": "Both values are passed as separate parameters to a prepared statement, ensuring safe database interaction."
          },
          {
            "id": 2831,
            "code": "app.get('/view', (req, res) => {\n  fs.readFile(req.query.file, (err, data) => res.send(data));\n});",
            "label": "insecure",
            "vulnerability_type": "Path Traversal (Arbitrary Read)",
            "explanation": "Allows the user to read any file on the system via the `file` parameter without path sanitization."
          },
          {
            "id": 2832,
            "code": "app.get('/view', (req, res) => {\n  const file = path.normalize(req.query.file);\n  if (file.includes('..')) return res.status(403).send();\n  fs.readFile(path.join('/app/data', file), (err, data) => res.send(data));\n});",
            "label": "secure",
            "vulnerability_type": "Path Traversal (Arbitrary Read)",
            "explanation": "Normalizes the path, checks for traversal sequences, and restricts reading to a safe, controlled directory."
          },
          {
            "id": 2833,
            "code": "const user = req.body.data;\nconst result = eval(`var obj = ${user}`);",
            "label": "insecure",
            "vulnerability_type": "Code Injection (Eval Expression)",
            "explanation": "Executes user input as a JavaScript expression inside an `eval()` call, leading to remote code execution."
          },
          {
            "id": 2834,
            "code": "const user = req.body.data;\n// Replaced with safe JSON parsing or validation\nconst result = JSON.parse(user);",
            "label": "secure",
            "vulnerability_type": "Code Injection (Eval Expression)",
            "explanation": "The dangerous `eval()` function is replaced with safe JSON parsing, which only handles data structures."
          },
          {
            "id": 2835,
            "code": "res.header('Access-Control-Allow-Origin', req.headers.host);",
            "label": "insecure",
            "vulnerability_type": "CORS Misconfiguration (Reflected Host)",
            "explanation": "Reflects the unvalidated `Host` header into the CORS origin, which can be easily spoofed by an attacker to bypass SOP."
          },
          {
            "id": 2836,
            "code": "res.header('Access-Control-Allow-Origin', process.env.TRUSTED_HOST);",
            "label": "secure",
            "vulnerability_type": "CORS Misconfiguration (Reflected Host)",
            "explanation": "Uses a trusted, fixed origin retrieved from an environment variable for the CORS policy."
          },
          {
            "id": 2837,
            "code": "const html = `<div>User: ${req.query.name}</div>`;\nres.send(html);",
            "label": "insecure",
            "vulnerability_type": "Cross-Site Scripting (Template Literal)",
            "explanation": "Embeds raw, unescaped user input into an HTML template literal, allowing XSS."
          },
          {
            "id": 2838,
            "code": "const safeName = validator.escape(req.query.name);\nconst html = `<div>User: ${safeName}</div>`;\nres.send(html);",
            "label": "secure",
            "vulnerability_type": "Cross-Site Scripting (Template Literal)",
            "explanation": "Escapes the user input before embedding it in the template literal."
          },
          {
            "id": 2839,
            "code": "const cmd = 'curl ' + req.query.url;\nexec(cmd, (err, stdout) => res.send(stdout));",
            "label": "insecure",
            "vulnerability_type": "Command Injection (Unvalidated URL)",
            "explanation": "The URL input is concatenated into a shell command (`curl`), enabling command injection via shell metacharacters."
          },
          {
            "id": 2840,
            "code": "const url = req.query.url;\nif (!validator.isURL(url)) return res.status(400).send();\nexecFile('curl', [url], (err, stdout) => res.send(stdout));",
            "label": "secure",
            "vulnerability_type": "Command Injection (Unvalidated URL)",
            "explanation": "Validates the URL format and uses `execFile` (shell bypass) to run the command, treating the URL as a safe, literal argument."
          },
          {
            "id": 2841,
            "code": "const user_id = req.query.id;\nconst query = `DELETE FROM sessions WHERE user_id = ${user_id} AND active = 1`;",
            "label": "insecure",
            "vulnerability_type": "SQL Injection (Numeric Delete)",
            "explanation": "Concatenates the numeric ID into the DELETE query, allowing logic injection to bypass the `active = 1` condition."
          },
          {
            "id": 2842,
            "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `DELETE FROM sessions WHERE user_id = ? AND active = 1`;\ndb.query(query, [user_id]);",
            "label": "secure",
            "vulnerability_type": "SQL Injection (Numeric Delete)",
            "explanation": "The ID is validated as an integer and passed via a parameterized query, preventing injection."
          },
          {
            "id": 2843,
            "code": "const password = req.body.pass;\nconst hash = pbkdf2Sync(password, 'fixed-salt', 1000, 32, 'sha256');",
            "label": "insecure",
            "vulnerability_type": "Weak Cryptography (Low Iteration Count)",
            "explanation": "Uses a very low iteration count (1000) for PBKDF2, which is easily brute-forced with modern hardware."
          },
          {
            "id": 2844,
            "code": "const password = req.body.pass;\nconst salt = crypto.randomBytes(16).toString('hex');\nconst hash = pbkdf2Sync(password, salt, 310000, 64, 'sha512');",
            "label": "secure",
            "vulnerability_type": "Weak Cryptography (Low Iteration Count)",
            "explanation": "Uses a high, recommended iteration count (310000), a random salt, and a larger key size (64 bytes) with SHA-512."
          },
          {
            "id": 2845,
            "code": "const file = req.query.name;\nres.sendFile(file);",
            "label": "insecure",
            "vulnerability_type": "Path Traversal (Root Directory)",
            "explanation": "No base directory is specified, allowing the user to request any file path accessible by the process."
          },
          {
            "id": 2846,
            "code": "const file = path.basename(req.query.name);\nres.sendFile(path.join(__dirname, 'reports', file));",
            "label": "secure",
            "vulnerability_type": "Path Traversal (Root Directory)",
            "explanation": "Restricts the file access to a safe subdirectory (`reports`) using `__dirname` and sanitizes the filename with `path.basename`."
          },
          {
            "id": 2847,
            "code": "if (req.query.user_id === req.session.user_id) { /* view data */ }",
            "label": "insecure",
            "vulnerability_type": "Weak Comparison (IDOR)",
            "explanation": "A pattern that encourages reliance on client-supplied IDs, where the authorization check should ideally happen higher up in the data access layer."
          },
          {
            "id": 2848,
            "code": "if (req.query.user_id === req.session.user_id) { /* view data */ } else {\n  return res.status(403).send('Forbidden');\n}",
            "label": "secure",
            "vulnerability_type": "Weak Comparison (IDOR)",
            "explanation": "While the comparison is technically correct, the secure fix ensures that unauthorized access is explicitly denied with a proper HTTP status code."
          },
          {
            "id": 2849,
            "code": "const data = req.query.input;\nres.send(`<div onmouseover='alert(\"${data}\")'>Hover</div>`);",
            "label": "insecure",
            "vulnerability_type": "XSS (Client-Side JS Context - Double Quote)",
            "explanation": "Injects unescaped user input into a JavaScript string context inside an event handler, allowing injection via double-quote escaping."
          },
          {
            "id": 2850,
            "code": "const data = req.query.input;\nconst safeData = data.replace(/\"/g, '\\\"');\nres.send(`<div onmouseover='alert(\"${safeData}\")'>Hover</div>`);",
            "label": "secure",
            "vulnerability_type": "XSS (Client-Side JS Context - Double Quote)",
            "explanation": "Escapes the double quote character, preventing the attacker from prematurely closing the JavaScript string."
          },
          {
            "id": 2851,
            "code": "const user = req.query.username;\nconst query = `UPDATE users SET last_seen = NOW() WHERE username = '${user}'`;",
            "label": "insecure",
            "vulnerability_type": "SQL Injection (Username String)",
            "explanation": "Concatenates the username string into the SQL query, allowing injection via a malicious username."
          },
          {
            "id": 2852,
            "code": "const user = req.query.username;\nconst query = `UPDATE users SET last_seen = NOW() WHERE username = ?`;\ndb.query(query, [user]);",
            "label": "secure",
            "vulnerability_type": "SQL Injection (Username String)",
            "explanation": "Uses a parameterized query for the username, ensuring safe execution."
          },
          {
            "id": 2853,
            "code": "app.get('/api', (req, res) => {\n  res.set('X-Content-Type-Options', 'no-sniff');\n  res.send('data');\n});",
            "label": "insecure",
            "vulnerability_type": "Misspelled Header Value",
            "explanation": "The value `no-sniff` is misspelled, rendering the header ineffective."
          },
          {
            "id": 2854,
            "code": "app.get('/api', (req, res) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.send('data');\n});",
            "label": "secure",
            "vulnerability_type": "Misspelled Header Value",
            "explanation": "The header value is correctly spelled as `nosniff`."
          },
          {
            "id": 2855,
            "code": "const data = req.body.input;\nconst result = JSON.parse(data);",
            "label": "insecure",
            "vulnerability_type": "DoS (JSON Nesting)",
            "explanation": "Accepts arbitrarily deep JSON nesting, which can lead to a stack overflow or resource exhaustion during parsing (DoS)."
          },
          {
            "id": 2856,
            "code": "const data = req.body.input;\n// Use a parser with depth limits or a schema validator\nconst result = limitedJsonParse(data, { maxDepth: 5 });",
            "label": "secure",
            "vulnerability_type": "DoS (JSON Nesting)",
            "explanation": "Uses a JSON parser configured with a maximum depth limit to prevent malicious, deeply nested payloads."
          },
          {
            "id": 2857,
            "code": "res.header('Set-Cookie', 'session=abc; Path=/');",
            "label": "insecure",
            "vulnerability_type": "Missing Cookie Flags (Manual)",
            "explanation": "Manually setting the cookie header without `HttpOnly` and `Secure` flags is insecure."
          },
          {
            "id": 2858,
            "code": "res.cookie('session', 'abc', { httpOnly: true, secure: true, sameSite: 'strict' });",
            "label": "secure",
            "vulnerability_type": "Missing Cookie Flags (Manual)",
            "explanation": "Uses the appropriate framework function to set all necessary security flags."
          },
          {
            "id": 2859,
            "code": "const username = req.query.user;\nres.send(`User: ${username}`);",
            "label": "insecure",
            "vulnerability_type": "Cross-Site Scripting (Reflected Parameter)",
            "explanation": "Reflects unescaped user input into the HTML response."
          },
          {
            "id": 2860,
            "code": "const username = validator.escape(req.query.user);\nres.send(`User: ${username}`);",
            "label": "secure",
            "vulnerability_type": "Cross-Site Scripting (Reflected Parameter)",
            "explanation": "Uses HTML entity escaping on the user input."
          },
          {
            "id": 2861,
            "code": "const file = req.query.file;\nexecFile('cat', [file], (err, stdout) => res.send(stdout));",
            "label": "insecure",
            "vulnerability_type": "Path Traversal (ExecFile Argument)",
            "explanation": "The filename argument can still contain `../` sequences, allowing arbitrary file reading."
          },
          {
            "id": 2862,
            "code": "const file = path.join('/var/reports', path.basename(req.query.file));\nexecFile('cat', [file], (err, stdout) => res.send(stdout));",
            "label": "secure",
            "vulnerability_type": "Path Traversal (ExecFile Argument)",
            "explanation": "The file path is restricted to a safe directory and the filename is sanitized with `path.basename`."
          },
          {
            "id": 2863,
            "code": "const user_id = req.query.id;\nconst query = `UPDATE users SET name = 'New Name' WHERE id = ${user_id}`;",
            "label": "insecure",
            "vulnerability_type": "SQL Injection (Numeric Update)",
            "explanation": "Concatenates the numeric ID, allowing logic injection to modify unintended records."
          },
          {
            "id": 2864,
            "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `UPDATE users SET name = 'New Name' WHERE id = ?`;\ndb.query(query, [user_id]);",
            "label": "secure",
            "vulnerability_type": "SQL Injection (Numeric Update)",
            "explanation": "The ID is validated and passed via a parameterized query."
          },
          {
            "id": 2865,
            "code": "const data = req.query.url;\nres.send(`<img src='${data}'>`);",
            "label": "insecure",
            "vulnerability_type": "XSS (Image Source Single Quote)",
            "explanation": "Injects unescaped URL into a single-quoted attribute, allowing XSS via `javascript:` or quote escaping."
          },
          {
            "id": 2866,
            "code": "const data = req.query.url;\nconst safeData = validator.isURL(data) ? data : '#';\nres.send(`<img src='${safeData}'>`);",
            "label": "secure",
            "vulnerability_type": "XSS (Image Source Single Quote)",
            "explanation": "Validates the URL using `validator.isURL` to ensure it is a safe format before embedding it."
          },
          {
            "id": 2867,
            "code": "const password = req.body.pass;\nconst hash = await scrypt(password, 'fixed', 1000, 32);",
            "label": "insecure",
            "vulnerability_type": "Weak Cryptography (Fixed Salt/Low Iteration)",
            "explanation": "Uses a fixed salt and an insufficient iteration count for Scrypt, making it easy to crack."
          },
          {
            "id": 2868,
            "code": "const password = req.body.pass;\nconst salt = crypto.randomBytes(16).toString('hex');\nconst hash = await scrypt(password, salt, 310000, 64);",
            "label": "secure",
            "vulnerability_type": "Weak Cryptography (Fixed Salt/Low Iteration)",
            "explanation": "Uses a random salt, a high iteration count, and a larger key size for secure Scrypt hashing."
          },
          {
            "id": 2869,
            "code": "const html = '<h1>' + req.query.title + '</h1>';\nres.send(html);",
            "label": "insecure",
            "vulnerability_type": "Cross-Site Scripting (HTML Header)",
            "explanation": "Concatenates unescaped user input into an HTML header tag."
          },
          {
            "id": 2870,
            "code": "const safeTitle = validator.escape(req.query.title);\nconst html = `<h1>${safeTitle}</h1>`;\nres.send(html);",
            "label": "secure",
            "vulnerability_type": "Cross-Site Scripting (HTML Header)",
            "explanation": "Applies HTML escaping to the user input before embedding it in the HTML tag."
          },
          {
            "id": 2871,
            "code": "const key = req.query.key;\nconst query = `SELECT * FROM settings WHERE key = '${key}'`;",
            "label": "insecure",
            "vulnerability_type": "SQL Injection (Settings Key)",
            "explanation": "Concatenates the key string into the SQL query, allowing injection."
          },
          {
            "id": 2872,
            "code": "const key = req.query.key;\nconst query = `SELECT * FROM settings WHERE key = ?`;\ndb.query(query, [key]);",
            "label": "secure",
            "vulnerability_type": "SQL Injection (Settings Key)",
            "explanation": "Uses a parameterized query for the settings key."
          },
          {
            "id": 2873,
            "code": "app.get('/log', (req, res) => {\n  fs.appendFileSync('audit.log', req.query.user + ':' + req.query.action);\n});",
            "label": "insecure",
            "vulnerability_type": "Log Injection (Multiple Fields)",
            "explanation": "Concatenates multiple unvalidated user inputs into a log file, vulnerable to log forging."
          },
          {
            "id": 2874,
            "code": "app.get('/log', (req, res) => {\n  const safeUser = req.query.user.replace(/[\\r\\n]/g, '_');\n  const safeAction = req.query.action.replace(/[\\r\\n]/g, '_');\n  fs.appendFileSync('audit.log', `${safeUser}:${safeAction}\\n`);\n});",
            "label": "secure",
            "vulnerability_type": "Log Injection (Multiple Fields)",
            "explanation": "Sanitizes both user and action inputs by removing newline characters before writing to the log."
          },
          {
            "id": 2875,
            "code": "const data = req.body.input;\nconst result = serialize(data);",
            "label": "insecure",
            "vulnerability_type": "Insecure Deserialization (General)",
            "explanation": "Using general serialization methods (like PHP's `serialize`/unserialize equivalent in JS) on untrusted data can lead to Object Injection and RCE."
          },
          {
            "id": 2876,
            "code": "const data = req.body.input;\n// Use a safe, data-only serialization format like JSON\nconst result = JSON.stringify(data);",
            "label": "secure",
            "vulnerability_type": "Insecure Deserialization (General)",
            "explanation": "Uses the inherently safer JSON format, which cannot serialize executable functions or classes."
          },
          {
            "id": 2877,
            "code": "app.post('/profile', (req, res) => {\n  db.update({ id: req.body.id, ...req.body });\n  res.send('ok');\n});",
            "label": "insecure",
            "vulnerability_type": "Mass Assignment (Spread Operator)",
            "explanation": "Uses the spread operator (`...req.body`) to pass all fields from the body directly to the update function, enabling Mass Assignment."
          },
          {
            "id": 2878,
            "code": "app.post('/profile', (req, res) => {\n  const { name, email } = req.body;\n  db.update({ id: req.session.user_id, name, email });\n  res.send('ok');\n});",
            "label": "secure",
            "vulnerability_type": "Mass Assignment (Spread Operator)",
            "explanation": "Uses destructuring to explicitly whitelist fields and uses the trusted session ID for the update identity."
          },
          {
            "id": 2879,
            "code": "const url = req.query.target;\nres.redirect(url);",
            "label": "insecure",
            "vulnerability_type": "Open Redirect (Simple)",
            "explanation": "Redirects to an arbitrary, user-controlled URL, enabling phishing attacks."
          },
          {
            "id": 2880,
            "code": "const target = req.query.target;\nif (target.startsWith('/')) {\n  res.redirect(target);\n} else {\n  res.redirect('/');\n}",
            "label": "secure",
            "vulnerability_type": "Open Redirect (Simple)",
            "explanation": "The target URL is validated to ensure it starts with a `/`, restricting the redirect to relative, internal paths."
          },
          {
            "id": 2881,
            "code": "const data = req.query.input;\nres.send(`<a href=\"${data}\">Link</a>`);",
            "label": "insecure",
            "vulnerability_type": "XSS (URL Attribute Injection)",
            "explanation": "Injects unescaped input into an `href` attribute, allowing XSS via `javascript:` scheme."
          },
          {
            "id": 2882,
            "code": "const data = req.query.input;\nconst safeData = validator.isURL(data, { protocols: ['http', 'https'] }) ? data : '#';\nres.send(`<a href=\"${safeData}\">Link</a>`);",
            "label": "secure",
            "vulnerability_type": "XSS (URL Attribute Injection)",
            "explanation": "The URL is validated to ensure it uses only safe protocols (`http`, `https`) before injection."
          },
          {
            "id": 2883,
            "code": "const user_id = req.query.id;\nconst query = `SELECT * FROM users WHERE id = ${user_id} AND role = 'guest'`;",
            "label": "insecure",
            "vulnerability_type": "SQL Injection (Numeric ID + Logic)",
            "explanation": "Concatenates the numeric ID, allowing logic injection to bypass the `role = 'guest'` filter."
          },
          {
            "id": 2884,
            "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `SELECT * FROM users WHERE id = ? AND role = 'guest'`;\ndb.query(query, [user_id]);",
            "label": "secure",
            "vulnerability_type": "SQL Injection (Numeric ID + Logic)",
            "explanation": "The numeric ID is cast and passed safely via a parameterized query."
          },
          {
            "id": 2885,
            "code": "const user = req.params.user;\nconst cmd = `echo 'login successful' >> ${user}.log`;\nexec(cmd);",
            "label": "insecure",
            "vulnerability_type": "Command Injection (Log File Name)",
            "explanation": "Injects input into the log file name executed via shell, enabling command injection or file path manipulation."
          },
          {
            "id": 2886,
            "code": "const user = req.params.user.replace(/[^a-zA-Z0-9]/g, '');\nconst filename = path.join('/var/logs', user + '.log');\nfs.appendFile(filename, 'login successful\\n', () => {});",
            "label": "secure",
            "vulnerability_type": "Command Injection (Log File Name)",
            "explanation": "Avoids shell execution entirely by using the native Node.js `fs.appendFile` and sanitizes the username for the filename."
          },
          {
            "id": 2887,
            "code": "res.set('Content-Type', 'text/plain').send(req.query.err);\nres.end();",
            "label": "insecure",
            "vulnerability_type": "Error Message Disclosure (Reflected)",
            "explanation": "Reflects a user-supplied error message, which could be exploited to trick users into believing a fake error message is legitimate."
          },
          {
            "id": 2888,
            "code": "const refId = Math.random().toString(36).substring(2, 8);\nres.status(500).send(`Error occurred (Ref ID: ${refId})`);",
            "label": "secure",
            "vulnerability_type": "Error Message Disclosure (Reflected)",
            "explanation": "Replaces the reflected message with a generic error and a randomized reference ID for internal tracking, avoiding spoofing."
          },
          {
            "id": 2889,
            "code": "const password = req.body.pass;\nconst hash = sha512(password + process.env.STATIC_SALT);",
            "label": "insecure",
            "vulnerability_type": "Weak Cryptography (Static Salt)",
            "explanation": "Using a single, static salt (even from an environment variable) for all users makes the password database susceptible to a single, expensive pre-computation attack."
          },
          {
            "id": 2890,
            "code": "const password = req.body.pass;\nconst salt = crypto.randomBytes(16).toString('hex');\nconst hash = pbkdf2Sync(password, salt, 310000, 64, 'sha512');",
            "label": "secure",
            "vulnerability_type": "Weak Cryptography (Static Salt)",
            "explanation": "Uses a unique, cryptographically random salt generated for each password, ensuring per-user protection against cracking."
          },
          {
            "id": 2891,
            "code": "app.get('/admin', (req, res) => {\n  if (req.session.role === 'admin') {\n    res.render('admin');\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});",
            "label": "insecure",
            "vulnerability_type": "Broken Access Control (Direct Role Check)",
            "explanation": "The check relies entirely on a session variable, which could be vulnerable if session cookies are not properly protected (e.g., if set without `httpOnly`)."
          },
          {
            "id": 2892,
            "code": "const isAdmin = (req, res, next) => {\n  if (req.isAuthenticated() && req.user.role === 'admin') {\n    return next();\n  }\n  res.status(403).send('Forbidden');\n};\napp.get('/admin', isAdmin, (req, res) => {\n  res.render('admin');\n});",
            "label": "secure",
            "vulnerability_type": "Broken Access Control (Direct Role Check)",
            "explanation": "Access control is enforced via dedicated middleware that confirms both authentication (`isAuthenticated`) and authorization (`req.user.role`)."
          },
          {
            "id": 2893,
            "code": "const data = req.query.input;\nres.send(`<div style=\"width: ${data}\"></div>`);",
            "label": "insecure",
            "vulnerability_type": "XSS (CSS Value Injection)",
            "explanation": "Injects unescaped user input into a CSS property value, allowing injection of malicious URLs via `url(...)`."
          },
          {
            "id": 2894,
            "code": "const data = req.query.input;\nconst safeData = data.match(/^\\d{1,4}(px|%|em)$/) ? data : '100px';\nres.send(`<div style=\"width: ${safeData}\"></div>`);",
            "label": "secure",
            "vulnerability_type": "XSS (CSS Value Injection)",
            "explanation": "Uses a strict whitelist regex to ensure the input is a safe CSS measurement unit and value."
          },
          {
            "id": 2895,
            "code": "const file = req.query.file;\nfs.promises.stat(file);",
            "label": "insecure",
            "vulnerability_type": "Path Traversal (Stat Check)",
            "explanation": "Allows the attacker to check for the existence and permissions of arbitrary files on the system via traversal."
          },
          {
            "id": 2896,
            "code": "const file = path.join('/safe/dir', path.basename(req.query.file));\nfs.promises.stat(file);",
            "label": "secure",
            "vulnerability_type": "Path Traversal (Stat Check)",
            "explanation": "Restricts the file path to a safe directory and sanitizes the filename using `path.basename`."
          },
          {
            "id": 2897,
            "code": "const payload = req.query.payload;\nconst result = JSON.parse(payload);",
            "label": "insecure",
            "vulnerability_type": "DoS (JSON Parsing)",
            "explanation": "Parsing an arbitrary, large JSON payload can consume excessive memory and CPU, leading to DoS."
          },
          {
            "id": 2898,
            "code": "const payload = req.query.payload;\nif (payload.length > 10240) return res.status(413).send();\nconst result = JSON.parse(payload);",
            "label": "secure",
            "vulnerability_type": "DoS (JSON Parsing)",
            "explanation": "Implements an explicit length check on the payload string before attempting the parsing operation."
          },
          {
            "id": 2899,
            "code": "res.header('X-Download-Options', 'noopen');",
            "label": "insecure",
            "vulnerability_type": "Missing Security Headers (Multiple)",
            "explanation": "Missing several critical headers like HSTS, CSP, and `X-Frame-Options`."
          },
          {
            "id": 2900,
            "code": "app.use(helmet.frameguard({ action: 'deny' }));\napp.use(helmet.hsts({ maxAge: 31536000 }));\nres.header('X-Download-Options', 'noopen');",
            "label": "secure",
            "vulnerability_type": "Missing Security Headers (Multiple)",
            "explanation": "Uses the `helmet` middleware to enforce multiple security headers, including clickjacking prevention and HSTS."
          },
            {
              "id": 2901,
              "code": "const query = `SELECT * FROM audits WHERE time > '${req.query.date}'`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (Date/Time)",
              "explanation": "Concatenates a user-supplied date string into the SQL query, allowing injection via quotes."
            },
            {
              "id": 2902,
              "code": "const date = req.query.date;\nconst query = `SELECT * FROM audits WHERE time > ?`;\ndb.query(query, [date]);",
              "label": "secure",
              "vulnerability_type": "SQL Injection (Date/Time)",
              "explanation": "Uses a parameterized query, passing the date string safely as a literal value."
            },
            {
              "id": 2903,
              "code": "const password = req.body.pass;\nconst hash = sha1(password);",
              "label": "insecure",
              "vulnerability_type": "Weak Cryptography (SHA-1)",
              "explanation": "Uses the cryptographically weak and deprecated SHA-1 hashing algorithm for password storage."
            },
            {
              "id": 2904,
              "code": "const password = req.body.pass;\nconst hash = bcrypt.hashSync(password, 12);",
              "label": "secure",
              "vulnerability_type": "Weak Cryptography (SHA-1)",
              "explanation": "Uses the secure, adaptive bcrypt algorithm with a high work factor (12) and random salting."
            },
            {
              "id": 2905,
              "code": "app.get('/exec', (req, res) => {\n  exec(`node -v && echo ${req.query.msg}`, (err, stdout) => res.send(stdout));\n});",
              "label": "insecure",
              "vulnerability_type": "Command Injection (Concatenated Echo)",
              "explanation": "Injects unvalidated user input into a shell command, allowing the attacker to inject metacharacters like `$()` or backticks."
            },
            {
              "id": 2906,
              "code": "app.get('/exec', (req, res) => {\n  const safeMsg = req.query.msg.replace(/[^a-zA-Z0-9\\s]/g, '');\n  exec(`node -v && echo ${safeMsg}`, (err, stdout) => res.send(stdout));\n});",
              "label": "secure",
              "vulnerability_type": "Command Injection (Concatenated Echo)",
              "explanation": "Sanitizes the input string to allow only safe characters, preventing the injection of executable shell commands."
            },
            {
              "id": 2907,
              "code": "const username = req.query.user;\nres.send(`<input type=text value='${username}'>`);",
              "label": "insecure",
              "vulnerability_type": "XSS (HTML Attribute Single Quote)",
              "explanation": "Injects unescaped user input into a single-quoted HTML attribute, allowing XSS via single-quote escape."
            },
            {
              "id": 2908,
              "code": "const username = req.query.user;\nconst safeUsername = username.replace(/'/g, '&#39;');\nres.send(`<input type=text value='${safeUsername}'>`);",
              "label": "secure",
              "vulnerability_type": "XSS (HTML Attribute Single Quote)",
              "explanation": "Escapes the single quote character in the user input, ensuring the input is treated as a literal value within the attribute."
            },
            {
              "id": 2909,
              "code": "const filename = req.query.file;\nres.sendFile(filename);",
              "label": "insecure",
              "vulnerability_type": "Path Traversal (No Base Directory)",
              "explanation": "Allows the user to request any file path accessible to the Node.js process."
            },
            {
              "id": 2910,
              "code": "const filename = path.basename(req.query.file);\nres.sendFile(path.join(process.cwd(), 'assets', filename));",
              "label": "secure",
              "vulnerability_type": "Path Traversal (No Base Directory)",
              "explanation": "Restricts the file access to a safe subdirectory (`assets`) using `path.join` and sanitizes the filename with `path.basename`."
            },
            {
              "id": 2911,
              "code": "const data = req.body.data;\nconst result = JSON.parse(data);",
              "label": "insecure",
              "vulnerability_type": "Prototype Pollution (JSON.parse)",
              "explanation": "Certain custom JSON parsing environments can be vulnerable to Prototype Pollution if not properly safeguarded against keys like `__proto__`."
            },
            {
              "id": 2912,
              "code": "const data = req.body.data;\nconst result = JSON.parse(data, (key, value) => {\n  if (['__proto__', 'constructor', 'prototype'].includes(key)) return undefined; return value;\n});",
              "label": "secure",
              "vulnerability_type": "Prototype Pollution (JSON.parse)",
              "explanation": "Uses the JSON `reviver` function to explicitly filter out dangerous property names during parsing, mitigating pollution."
            },
            {
              "id": 2913,
              "code": "const key = req.query.key;\nconst query = `SELECT * FROM cache WHERE key = '${key}'`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (String Key)",
              "explanation": "Concatenates the key string directly into the SQL query, allowing injection."
            },
            {
              "id": 2914,
              "code": "const key = req.query.key;\nconst query = `SELECT * FROM cache WHERE key = ?`;\ndb.query(query, [key]);",
              "label": "secure",
              "vulnerability_type": "SQL Injection (String Key)",
              "explanation": "Uses a parameterized query for the cache key, ensuring safe execution."
            },
            {
              "id": 2915,
              "code": "app.get('/api', (req, res) => {\n  res.set('Access-Control-Allow-Origin', req.headers.origin);\n  res.send('Data');\n});",
              "label": "insecure",
              "vulnerability_type": "CORS Misconfiguration (Reflected Origin)",
              "explanation": "Reflects an arbitrary client-supplied `Origin` header into the CORS policy, allowing any domain to bypass SOP."
            },
            {
              "id": 2916,
              "code": "const allowedOrigins = [process.env.APP_URL];\napp.get('/api', (req, res) => {\n  const origin = req.headers.origin;\n  if (allowedOrigins.includes(origin)) {\n    res.set('Access-Control-Allow-Origin', origin);\n  }\n  res.send('Data');\n});",
              "label": "secure",
              "vulnerability_type": "CORS Misconfiguration (Reflected Origin)",
              "explanation": "The reflected origin is strictly validated against a hardcoded whitelist of trusted domains."
            },
            {
              "id": 2917,
              "code": "const data = req.query.input;\nres.send(`<h1>Error: ${data}</h1>`);",
              "label": "insecure",
              "vulnerability_type": "Cross-Site Scripting (Reflected Header)",
              "explanation": "Reflects unescaped user input into an HTML header tag, allowing XSS."
            },
            {
              "id": 2918,
              "code": "const data = req.query.input;\nres.send(`<h1>Error: ${validator.escape(data)}</h1>`);",
              "label": "secure",
              "vulnerability_type": "Cross-Site Scripting (Reflected Header)",
              "explanation": "Applies HTML entity escaping to the user input before embedding it in the HTML tag."
            },
            {
              "id": 2919,
              "code": "const data = req.body.data;\nconst result = atob(data);",
              "label": "insecure",
              "vulnerability_type": "Weak Encoding (atob)",
              "explanation": "Using client-side Base64 decoding (`atob`) on the server is a code smell and can lead to unexpected character encoding issues."
            },
            {
              "id": 2920,
              "code": "const data = req.body.data;\nconst result = Buffer.from(data, 'base64').toString('utf8');",
              "label": "secure",
              "vulnerability_type": "Weak Encoding (atob)",
              "explanation": "Uses the native Node.js `Buffer` API for safe and consistent Base64 decoding/encoding."
            },
            {
              "id": 2921,
              "code": "const user_id = req.query.id;\nconst query = `UPDATE profile SET active = 1 WHERE user_id = ${user_id}`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (Numeric ID Update)",
              "explanation": "Concatenates the numeric ID into the SQL UPDATE query, vulnerable to injection."
            },
            {
              "id": 2922,
              "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `UPDATE profile SET active = 1 WHERE user_id = ?`;\ndb.query(query, [user_id]);",
              "label": "secure",
              "vulnerability_type": "SQL Injection (Numeric ID Update)",
              "explanation": "The ID is validated as an integer and passed via a parameterized query."
            },
            {
              "id": 2923,
              "code": "app.get('/redirect', (req, res) => {\n  res.redirect(req.query.next);\n});",
              "label": "insecure",
              "vulnerability_type": "Open Redirect (Simple)",
              "explanation": "Redirects to an arbitrary, user-controlled URL, enabling phishing attacks."
            },
            {
              "id": 2924,
              "code": "app.get('/redirect', (req, res) => {\n  const next = req.query.next;\n  if (next && next.startsWith('/') && !next.startsWith('//')) {\n    res.redirect(next);\n  } else {\n    res.redirect('/home');\n  }\n});",
              "label": "secure",
              "vulnerability_type": "Open Redirect (Simple)",
              "explanation": "Validates the URL to ensure it is a safe relative path and prevents protocol-relative URLs (`//`) which bypass the check."
            },
            {
              "id": 2925,
              "code": "const user = req.body;\nif (user.role === 'admin') { /* grant access */ }",
              "label": "insecure",
              "vulnerability_type": "Authorization Bypass (Client Body Role)",
              "explanation": "Authorization relies on a role property supplied directly in the request body, allowing easy client-side bypass."
            },
            {
              "id": 2926,
              "code": "const user = db.getUserSession(req.session.id);\nif (user.role === 'admin') { /* grant access */ }",
              "label": "secure",
              "vulnerability_type": "Authorization Bypass (Client Body Role)",
              "explanation": "The authorization decision is based on a trusted role retrieved from the secure session store."
            },
            {
              "id": 2927,
              "code": "const password = req.body.pass;\nconst hash = pbkdf2Sync(password, 'salt-key', 1000, 32, 'sha256');",
              "label": "insecure",
              "vulnerability_type": "Weak Cryptography (Low Iterations)",
              "explanation": "The iteration count (1000) for PBKDF2 is dangerously low, making the hash vulnerable to offline brute-force attacks."
            },
            {
              "id": 2928,
              "code": "const password = req.body.pass;\nconst salt = crypto.randomBytes(16).toString('hex');\nconst hash = pbkdf2Sync(password, salt, 310000, 64, 'sha512');",
              "label": "secure",
              "vulnerability_type": "Weak Cryptography (Low Iterations)",
              "explanation": "Uses a high iteration count (310000), a random salt, and a strong algorithm (SHA-512) for PBKDF2."
            },
            {
              "id": 2929,
              "code": "const data = req.query.input;\nres.send(`<div style=\"background: ${data}\"></div>`);",
              "label": "insecure",
              "vulnerability_type": "XSS (CSS Value Injection)",
              "explanation": "Injects unescaped input into a CSS property value, allowing script execution via `url('javascript:...')`."
            },
            {
              "id": 2930,
              "code": "const data = req.query.input;\nconst safeData = data.match(/^(rgb|#|url)\\([\\w\\s.,'\"-/\\(\\)]*\\)$/i) ? data : 'none';\nres.send(`<div style=\"background: ${safeData}\"></div>`);",
              "label": "secure",
              "vulnerability_type": "XSS (CSS Value Injection)",
              "explanation": "Uses a strict regex whitelist to ensure the input is a valid, non-executable CSS value."
            },
            {
              "id": 2931,
              "code": "const cmd = 'ls ' + req.query.dir;\nexec(cmd, (err, stdout) => res.send(stdout));",
              "label": "insecure",
              "vulnerability_type": "Command Injection (Simple)",
              "explanation": "Concatenates unvalidated user input into a shell command, enabling execution of arbitrary commands."
            },
            {
              "id": 2932,
              "code": "const dir = req.query.dir.replace(/[^\\w\\-.]/g, '');\nexecFile('ls', [dir], (err, stdout) => res.send(stdout));",
              "label": "secure",
              "vulnerability_type": "Command Injection (Simple)",
              "explanation": "Sanitizes the input and uses the safer `execFile` function to bypass the shell."
            },
            {
              "id": 2933,
              "code": "const user_id = req.query.id;\nconst query = `SELECT * FROM audits WHERE user_id = ${user_id} ORDER BY timestamp`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (Numeric ID)",
              "explanation": "Concatenates the numeric ID, allowing logic injection to manipulate the query."
            },
            {
              "id": 2934,
              "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `SELECT * FROM audits WHERE user_id = ? ORDER BY timestamp`;\ndb.query(query, [user_id]);",
              "label": "secure",
              "vulnerability_type": "SQL Injection (Numeric ID)",
              "explanation": "The ID is cast to integer and passed via a parameterized query."
            },
            {
              "id": 2935,
              "code": "const key = req.query.key;\nconst iv = 'a-fixed-iv';\nconst cipher = createCipheriv('aes-256-cbc', process.env.KEY, iv);",
              "label": "insecure",
              "vulnerability_type": "Weak Cryptography (Fixed IV)",
              "explanation": "Uses a fixed, hardcoded Initialization Vector (IV), which makes the encryption vulnerable to chosen-plaintext attacks."
            },
            {
              "id": 2936,
              "code": "const iv = crypto.randomBytes(16);\nconst cipher = createCipheriv('aes-256-gcm', process.env.KEY, iv);",
              "label": "secure",
              "vulnerability_type": "Weak Cryptography (Fixed IV)",
              "explanation": "Uses a cryptographically random IV generated for each encryption and the stronger GCM mode."
            },
            {
              "id": 2937,
              "code": "const data = req.body.input;\ndocument.getElementById('title').textContent = data;",
              "label": "insecure",
              "vulnerability_type": "DOM-based XSS (Unsafe API Usage)",
              "explanation": "While `textContent` is generally safe, in some legacy browsers or contexts, it could still be exploited or be combined with other unsafe patterns."
            },
            {
              "id": 2938,
              "code": "const data = req.body.input;\ndocument.getElementById('title').textContent = data.replace(/[<>]/g, '');",
              "label": "secure",
              "vulnerability_type": "DOM-based XSS (Unsafe API Usage)",
              "explanation": "Although `textContent` is mostly safe, the **most secure** approach for content is to additionally strip `<` and `>` characters to prevent unexpected rendering."
            },
            {
              "id": 2939,
              "code": "app.get('/file', (req, res) => {\n  fs.promises.stat(req.query.path);\n  res.send('ok');\n});",
              "label": "insecure",
              "vulnerability_type": "Path Traversal (File Stat)",
              "explanation": "Allows the attacker to check for the existence and properties of arbitrary files on the system via traversal."
            },
            {
              "id": 2940,
              "code": "app.get('/file', (req, res) => {\n  const path = path.join('/var/data', path.basename(req.query.path));\n  fs.promises.stat(path);\n  res.send('ok');\n});",
              "label": "secure",
              "vulnerability_type": "Path Traversal (File Stat)",
              "explanation": "Restricts the path to a safe base directory and uses `path.basename` to sanitize the filename."
            },
            {
              "id": 2941,
              "code": "const url = req.query.link;\nres.redirect(url);",
              "label": "insecure",
              "vulnerability_type": "Open Redirect (Simple)",
              "explanation": "Redirects to an arbitrary, user-controlled URL, enabling phishing attacks."
            },
            {
              "id": 2942,
              "code": "const url = req.query.link;\nif (url.startsWith(process.env.TRUSTED_DOMAIN) || url.startsWith('/')) {\n  res.redirect(url);\n} else {\n  res.redirect('/home');\n}",
              "label": "secure",
              "vulnerability_type": "Open Redirect (Simple)",
              "explanation": "The URL is validated against a whitelist (trusted domain) or restricted to relative paths."
            },
            {
              "id": 2943,
              "code": "res.header('Set-Cookie', 'user=test; secure');",
              "label": "insecure",
              "vulnerability_type": "Missing Cookie Flags (HttpOnly)",
              "explanation": "The cookie lacks the `HttpOnly` flag, making it accessible to client-side scripts."
            },
            {
              "id": 2944,
              "code": "res.cookie('user', 'test', { secure: true, httpOnly: true, sameSite: 'strict' });",
              "label": "secure",
              "vulnerability_type": "Missing Cookie Flags (HttpOnly)",
              "explanation": "Uses the framework function to set all necessary security flags (`secure`, `httpOnly`, `sameSite`)."
            },
            {
              "id": 2945,
              "code": "const user_id = req.query.id;\nconst query = `DELETE FROM items WHERE owner_id = ${user_id}`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (Numeric ID Delete)",
              "explanation": "Concatenates the numeric ID, allowing logic injection into the DELETE query."
            },
            {
              "id": 2946,
              "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `DELETE FROM items WHERE owner_id = ?`;\ndb.query(query, [user_id]);",
              "label": "secure",
              "vulnerability_type": "SQL Injection (Numeric ID Delete)",
              "explanation": "The ID is validated as an integer and passed via a parameterized query."
            },
            {
              "id": 2947,
              "code": "const html = '<div>' + req.query.msg + '</div>';\nconst pdf = pdfLib.generate(html);",
              "label": "insecure",
              "vulnerability_type": "Injection (PDF HTML)",
              "explanation": "Injects unescaped HTML into the PDF generation process, which can lead to XSS or file access if a browser engine is used."
            },
            {
              "id": 2948,
              "code": "const safeMsg = sanitizeHtml(req.query.msg);\nconst html = `<div>${safeMsg}</div>`;\nconst pdf = pdfLib.generate(html);",
              "label": "secure",
              "vulnerability_type": "Injection (PDF HTML)",
              "explanation": "Sanitizes the user-supplied HTML using a dedicated library (`sanitizeHtml`) before feeding it to the PDF engine."
            },
            {
              "id": 2949,
              "code": "app.get('/status', (req, res) => {\n  res.send('Version: ' + process.version);\n});",
              "label": "insecure",
              "vulnerability_type": "Information Leakage (Node Version)",
              "explanation": "Exposes the exact version of the Node.js runtime, aiding attackers in targeting known vulnerabilities."
            },
            {
              "id": 2950,
              "code": "app.get('/status', (req, res) => {\n  res.send('Status: OK');\n});",
              "label": "secure",
              "vulnerability_type": "Information Leakage (Node Version)",
              "explanation": "Replaces the specific version number with a generic status message."
            },
            {
              "id": 2951,
              "code": "const data = req.query.input;\nres.send(`<a target='_blank' href='${data}'></a>`);",
              "label": "insecure",
              "vulnerability_type": "Open Redirect / Tabnabbing (Unvalidated Target)",
              "explanation": "Injects an unvalidated URL into a link with `target='_blank'`, making it vulnerable to both Open Redirect and Tabnabbing attacks."
            },
            {
              "id": 2952,
              "code": "const data = req.query.input;\nconst safeData = validator.isURL(data) ? data : '#';\nres.send(`<a target='_blank' rel='noopener noreferrer' href='${safeData}'></a>`);",
              "label": "secure",
              "vulnerability_type": "Open Redirect / Tabnabbing (Unvalidated Target)",
              "explanation": "Validates the URL and adds `rel='noopener noreferrer'` to mitigate Tabnabbing and limit referrer information."
            },
            {
              "id": 2953,
              "code": "const user_id = req.query.id;\nconst query = `UPDATE settings SET value = 'new' WHERE user_id = ${user_id}`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (Numeric ID Update)",
              "explanation": "Concatenates the numeric ID, allowing logic injection."
            },
            {
              "id": 2954,
              "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `UPDATE settings SET value = 'new' WHERE user_id = ?`;\ndb.query(query, [user_id]);",
              "label": "secure",
              "vulnerability_type": "SQL Injection (Numeric ID Update)",
              "explanation": "The ID is validated as an integer and passed via a parameterized query."
            },
            {
              "id": 2955,
              "code": "const file = req.query.file;\nexec(`cat ${file}`, (err, stdout) => res.send(stdout));",
              "label": "insecure",
              "vulnerability_type": "Command Injection (Shell Cat)",
              "explanation": "Concatenates user input into a shell command, enabling execution of arbitrary commands."
            },
            {
              "id": 2956,
              "code": "const file = path.basename(req.query.file);\nconst safeFile = path.join('/var/data/safe', file);\nexecFile('cat', [safeFile], (err, stdout) => res.send(stdout));",
              "label": "secure",
              "vulnerability_type": "Command Injection (Shell Cat)",
              "explanation": "Restricts the file path to a safe directory and uses `execFile` to bypass the shell."
            },
            {
              "id": 2957,
              "code": "const password = req.body.pass;\nconst hash = createHash('md4').update(password).digest('hex');",
              "label": "insecure",
              "vulnerability_type": "Weak Cryptography (MD4)",
              "explanation": "Uses the cryptographically broken MD4 hashing algorithm."
            },
            {
              "id": 2958,
              "code": "const password = req.body.pass;\nconst hash = pbkdf2Sync(password, process.env.SALT, 310000, 64, 'sha512');",
              "label": "secure",
              "vulnerability_type": "Weak Cryptography (MD4)",
              "explanation": "Uses the strong, modern PBKDF2 with high iterations and SHA-512."
            },
            {
              "id": 2959,
              "code": "app.get('/data', (req, res) => {\n  res.send('Data from ' + req.headers.host);\n});",
              "label": "insecure",
              "vulnerability_type": "Header Reflection (Host)",
              "explanation": "Reflects the unvalidated `Host` header, allowing an attacker to spoof the site origin in the response."
            },
            {
              "id": 2960,
              "code": "app.get('/data', (req, res) => {\n  res.send('Data from ' + process.env.TRUSTED_HOST);\n});",
              "label": "secure",
              "vulnerability_type": "Header Reflection (Host)",
              "explanation": "The reflected host is replaced with a trusted, environment-configured value."
            },
            {
              "id": 2961,
              "code": "const data = req.body.input;\nres.send(data);",
              "label": "insecure",
              "vulnerability_type": "Cross-Site Scripting (Reflected Body)",
              "explanation": "Reflects the raw, unescaped request body data into the response, allowing XSS."
            },
            {
              "id": 2962,
              "code": "const data = req.body.input;\nres.send(validator.escape(data));",
              "label": "secure",
              "vulnerability_type": "Cross-Site Scripting (Reflected Body)",
              "explanation": "Applies HTML entity escaping to the raw reflected body content."
            },
            {
              "id": 2963,
              "code": "app.post('/update', (req, res) => {\n  db.users.update(req.body);\n  res.send('Updated');\n});",
              "label": "insecure",
              "vulnerability_type": "Mass Assignment (ORMs - Update)",
              "explanation": "Passes the entire request body to the ORM's update method, allowing modification of unauthorized fields."
            },
            {
              "id": 2964,
              "code": "app.post('/update', (req, res) => {\n  const { email, address } = req.body;\n  db.users.update(req.user.id, { email, address });\n  res.send('Updated');\n});",
              "label": "secure",
              "vulnerability_type": "Mass Assignment (ORMs - Update)",
              "explanation": "Uses destructuring to explicitly whitelist updateable fields and ensures the update uses the trusted session ID."
            },
            {
              "id": 2965,
              "code": "const user_id = req.query.id;\nconst query = `DELETE FROM products WHERE id = ${user_id} AND active = 1`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (Numeric Delete)",
              "explanation": "Concatenates the numeric ID, allowing logic injection to bypass the `AND active = 1` condition."
            },
            {
              "id": 2966,
              "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `DELETE FROM products WHERE id = ? AND active = 1`;\ndb.query(query, [user_id]);",
              "label": "secure",
              "vulnerability_type": "SQL Injection (Numeric Delete)",
              "explanation": "The ID is validated as an integer and passed via a parameterized query."
            },
            {
              "id": 2967,
              "code": "app.get('/log', (req, res) => {\n  console.log('User action: ' + req.query.action);\n});",
              "label": "insecure",
              "vulnerability_type": "Log Injection (Console)",
              "explanation": "Printing raw user input to the console or logs can lead to log forging if the input contains newline characters."
            },
            {
              "id": 2968,
              "code": "app.get('/log', (req, res) => {\n  const safeAction = req.query.action.replace(/[\\r\\n]/g, '_');\n  console.log(`User action: ${safeAction}`);\n});",
              "label": "secure",
              "vulnerability_type": "Log Injection (Console)",
              "explanation": "Sanitizes the input by replacing newline characters with safe underscores."
            },
            {
              "id": 2969,
              "code": "const html = '<h1>' + req.query.msg + '</h1>';\nres.send(html);",
              "label": "insecure",
              "vulnerability_type": "Cross-Site Scripting (HTML Header)",
              "explanation": "Concatenates unescaped user input into an HTML header tag."
            },
            {
              "id": 2970,
              "code": "const safeMsg = validator.escape(req.query.msg);\nconst html = `<h1>${safeMsg}</h1>`;\nres.send(html);",
              "label": "secure",
              "vulnerability_type": "Cross-Site Scripting (HTML Header)",
              "explanation": "Applies HTML escaping to the user input before embedding it in the HTML tag."
            },
            {
              "id": 2971,
              "code": "const password = req.body.pass;\nconst hash = crypto.createHmac('sha1', 'static').update(password).digest('hex');",
              "label": "insecure",
              "vulnerability_type": "Weak Cryptography (SHA-1 HMAC + Static Key)",
              "explanation": "Uses the weak SHA-1 algorithm and a hardcoded static key for HMAC, making the system vulnerable."
            },
            {
              "id": 2972,
              "code": "const password = req.body.pass;\nconst key = process.env.HMAC_SECRET;\nconst hash = crypto.createHmac('sha512', key).update(password).digest('hex');",
              "label": "secure",
              "vulnerability_type": "Weak Cryptography (SHA-1 HMAC + Static Key)",
              "explanation": "Uses a strong key from the environment and the robust SHA-512 algorithm for HMAC."
            },
            {
              "id": 2973,
              "code": "app.get('/api', (req, res) => {\n  res.set('X-Content-Type-Options', 'no-sniff');\n  res.send('data');\n});",
              "label": "insecure",
              "vulnerability_type": "Misspelled Security Header",
              "explanation": "The header value is misspelled (`no-sniff` instead of `nosniff`), rendering the header ineffective."
            },
            {
              "id": 2974,
              "code": "app.get('/api', (req, res) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.send('data');\n});",
              "label": "secure",
              "vulnerability_type": "Misspelled Security Header",
              "explanation": "The header value is correctly spelled as `nosniff`, ensuring the browser disables content type guessing."
            },
            {
              "id": 2975,
              "code": "const user_id = req.query.id;\nconst query = `SELECT * FROM users WHERE id = ${user_id} LIMIT 1`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (Numeric ID)",
              "explanation": "Concatenates the numeric ID, allowing logic injection."
            },
            {
              "id": 2976,
              "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `SELECT * FROM users WHERE id = ? LIMIT 1`;\ndb.query(query, [user_id]);",
              "label": "secure",
              "vulnerability_type": "SQL Injection (Numeric ID)",
              "explanation": "The ID is validated as an integer and passed via a parameterized query."
            },
            {
              "id": 2977,
              "code": "app.get('/download', (req, res) => {\n  const filename = req.query.name;\n  res.download(filename);\n});",
              "label": "insecure",
              "vulnerability_type": "Path Traversal (Uncontrolled Download)",
              "explanation": "Allows the user to request any file path for download, enabling path traversal."
            },
            {
              "id": 2978,
              "code": "app.get('/download', (req, res) => {\n  const filename = path.basename(req.query.name);\n  res.download(path.join(process.cwd(), 'downloads', filename));\n});",
              "label": "secure",
              "vulnerability_type": "Path Traversal (Uncontrolled Download)",
              "explanation": "Restricts the download path to a safe, controlled directory and sanitizes the filename."
            },
            {
              "id": 2979,
              "code": "const data = req.query.url;\nres.send(`<iframe src=\"${data}\"></iframe>`);",
              "label": "insecure",
              "vulnerability_type": "XSS (Iframe Source Injection)",
              "explanation": "Injects an unescaped URL into an `iframe`'s `src` attribute, allowing XSS via `javascript:` scheme."
            },
            {
              "id": 2980,
              "code": "const data = req.query.url;\\nconst safeData = validator.isURL(data, { protocols: ['https'] }) ? data : '#';\\nres.send(`<iframe src=\\\"${safeData}\\\"></iframe>`);",
              "label": "secure",
              "vulnerability_type": "XSS (Iframe Source Injection)",
              "explanation": "Validates the URL to ensure it uses only the secure `https` protocol before injection, mitigating `javascript:` XSS."
            },
            {
              "id": 2981,
              "code": "const data = req.body.input;\nconst result = eval(data);",
              "label": "insecure",
              "vulnerability_type": "Code Injection (Eval)",
              "explanation": "Executes arbitrary, unvalidated code received from the user, leading to immediate remote code execution."
            },
            {
              "id": 2982,
              "code": "const data = req.body.input;\nres.status(403).send('Code execution forbidden.');",
              "label": "secure",
              "vulnerability_type": "Code Injection (Eval)",
              "explanation": "Removes the dangerous `eval()` function, eliminating the code injection vulnerability."
            },
            {
              "id": 2983,
              "code": "const user_id = req.query.id;\nconst query = `UPDATE logs SET read = 1 WHERE user_id = ${user_id}`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (Numeric Update)",
              "explanation": "Concatenates the numeric ID, allowing logic injection to modify unintended records."
            },
            {
              "id": 2984,
              "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `UPDATE logs SET read = 1 WHERE user_id = ?`;\ndb.query(query, [user_id]);",
              "label": "secure",
              "vulnerability_type": "SQL Injection (Numeric Update)",
              "explanation": "The ID is validated as an integer and passed via a parameterized query."
            },
            {
              "id": 2985,
              "code": "const cmd = 'start ' + req.query.app;\nexec(cmd);",
              "label": "insecure",
              "vulnerability_type": "Command Injection (Program Start)",
              "explanation": "Allows injection into the program name executed via a shell, enabling arbitrary command execution."
            },
            {
              "id": 2986,
              "code": "const app = req.query.app.replace(/[^a-zA-Z0-9]/g, '');\nexecFile('start', [app]);",
              "label": "secure",
              "vulnerability_type": "Command Injection (Program Start)",
              "explanation": "Sanitizes the program name to a safe character set and uses `execFile` to bypass the shell."
            },
            {
              "id": 2987,
              "code": "const password = req.body.pass;\nconst hash = createHash('sha256').update(password + 'static').digest('hex');",
              "label": "insecure",
              "vulnerability_type": "Weak Cryptography (Static Salt)",
              "explanation": "Uses a single, static salt, making the hash susceptible to pre-computation and rainbow table attacks."
            },
            {
              "id": 2988,
              "code": "const password = req.body.pass;\nconst hash = bcrypt.hashSync(password, 12);",
              "label": "secure",
              "vulnerability_type": "Weak Cryptography (Static Salt)",
              "explanation": "Uses the secure, adaptive bcrypt algorithm with a high work factor and built-in random salting."
            },
            {
              "id": 2989,
              "code": "app.get('/profile', (req, res) => {\n  const user = db.getById(req.query.id);\n  res.json(user);\n});",
              "label": "insecure",
              "vulnerability_type": "IDOR (Unchecked Resource ID)",
              "explanation": "Allows a user to request any profile ID (`req.query.id`) without checking if they are authorized to view that resource (Insecure Direct Object Reference)."
            },
            {
              "id": 2990,
              "code": "app.get('/profile', (req, res) => {\n  const id = req.query.id;\n  if (id !== req.user.id && req.user.role !== 'admin') {\n    return res.status(403).send('Forbidden');\n  }\n  const user = db.getById(id);\n  res.json(user);\n});",
              "label": "secure",
              "vulnerability_type": "IDOR (Unchecked Resource ID)",
              "explanation": "Implements an explicit authorization check: the user can only view their own ID OR an admin role is required."
            },
            {
              "id": 2991,
              "code": "res.set('Content-Security-Policy', \"script-src 'self' 'unsafe-inline';\");",
              "label": "insecure",
              "vulnerability_type": "Weak CSP Policy ('unsafe-inline')",
              "explanation": "Using `'unsafe-inline'` in the CSP completely defeats XSS protection offered by the policy."
            },
            {
              "id": 2992,
              "code": "res.set('Content-Security-Policy', \"script-src 'self' 'nonce-randomstring'; object-src 'none';\");",
              "label": "secure",
              "vulnerability_type": "Weak CSP Policy ('unsafe-inline')",
              "explanation": "Removes `'unsafe-inline'` and enforces a strict, nonce-based CSP, allowing only trusted scripts to execute."
            },
            {
              "id": 2993,
              "code": "const username = req.query.user;\nres.send(`<p>Welcome, ${username}</p>`);",
              "label": "insecure",
              "vulnerability_type": "Cross-Site Scripting (Reflected Parameter)",
              "explanation": "Reflects unescaped user input into the HTML body."
            },
            {
              "id": 2994,
              "code": "const username = validator.escape(req.query.user);\nres.send(`<p>Welcome, ${username}</p>`);",
              "label": "secure",
              "vulnerability_type": "Cross-Site Scripting (Reflected Parameter)",
              "explanation": "Applies HTML entity escaping to the user input."
            },
            {
              "id": 2995,
              "code": "const sql = `SELECT * FROM articles WHERE active = 1 ORDER BY ${req.query.sort}`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (Order By)",
              "explanation": "The `ORDER BY` clause is constructed using unsanitized user input, allowing attackers to inject additional SQL commands."
            },
            {
              "id": 2996,
              "code": "const sortField = ['title', 'date'].includes(req.query.sort) ? req.query.sort : 'date';\nconst sql = `SELECT * FROM articles WHERE active = 1 ORDER BY ${sortField}`;",
              "label": "secure",
              "vulnerability_type": "SQL Injection (Order By)",
              "explanation": "Uses a strict whitelist to validate the sort column name, preventing injection."
            },
            {
              "id": 2997,
              "code": "app.get('/info', (req, res) => {\n  res.send('Server uptime: ' + process.uptime());\n});",
              "label": "insecure",
              "vulnerability_type": "Information Leakage (Uptime)",
              "explanation": "Exposes the server's exact uptime, which can aid an attacker in planning denial-of-service (DoS) or resource-exhaustion attacks."
            },
            {
              "id": 2998,
              "code": "app.get('/info', (req, res) => {\n  res.send('Service is healthy');\n});",
              "label": "secure",
              "vulnerability_type": "Information Leakage (Uptime)",
              "explanation": "Replaces the sensitive technical detail with a generic health status."
            },
            {
              "id": 2999,
              "code": "const user_id = req.query.id;\nconst query = `UPDATE accounts SET balance = balance - 100 WHERE id = ${user_id}`;",
              "label": "insecure",
              "vulnerability_type": "SQL Injection (Numeric Transaction)",
              "explanation": "Concatenates the numeric ID into a financial transaction query, allowing injection to modify the `WHERE` clause."
            },
            {
              "id": 3000,
              "code": "const user_id = parseInt(req.query.id, 10);\nconst query = `UPDATE accounts SET balance = balance - 100 WHERE id = ?`;\ndb.query(query, [user_id]);",
              "label": "secure",
              "vulnerability_type": "SQL Injection (Numeric Transaction)",
              "explanation": "The numeric ID is cast to integer and passed via a parameterized query, ensuring transaction integrity."
            }
       
    

]